===== C:\flutter_apps\im_legends\.dart_tool\dartpad\web_plugin_registrant.dart =====
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:app_links_web/app_links_web.dart';
import 'package:firebase_core_web/firebase_core_web.dart';
import 'package:firebase_messaging_web/firebase_messaging_web.dart';
import 'package:flutter_native_splash/flutter_native_splash_web.dart';
import 'package:flutter_secure_storage_web/flutter_secure_storage_web.dart';
import 'package:image_picker_for_web/image_picker_for_web.dart';
import 'package:permission_handler_html/permission_handler_html.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  AppLinksPluginWeb.registerWith(registrar);
  FirebaseCoreWeb.registerWith(registrar);
  FirebaseMessagingWeb.registerWith(registrar);
  FlutterNativeSplashWeb.registerWith(registrar);
  FlutterSecureStorageWeb.registerWith(registrar);
  ImagePickerPlugin.registerWith(registrar);
  WebPermissionHandler.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}
===== C:\flutter_apps\im_legends\.dart_tool\flutter_build\dart_plugin_registrant.dart =====
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.8

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:image_picker_android/image_picker_android.dart';
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:sqflite_android/sqflite_android.dart';
import 'package:url_launcher_android/url_launcher_android.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:image_picker_ios/image_picker_ios.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:url_launcher_ios/url_launcher_ios.dart';
import 'package:app_links_linux/app_links_linux.dart';
import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:flutter_local_notifications_linux/flutter_local_notifications_linux.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:file_selector_macos/file_selector_macos.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:image_picker_macos/image_picker_macos.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:sqflite_darwin/sqflite_darwin.dart';
import 'package:url_launcher_macos/url_launcher_macos.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:flutter_local_notifications_windows/flutter_local_notifications_windows.dart';
import 'package:flutter_secure_storage_windows/flutter_secure_storage_windows.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        AndroidFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerAndroid.registerWith();
      } catch (err) {
        print(
          '`image_picker_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteAndroid.registerWith();
      } catch (err) {
        print(
          '`sqflite_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherAndroid.registerWith();
      } catch (err) {
        print(
          '`url_launcher_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        IOSFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerIOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherIOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        AppLinksPluginLinux.registerWith();
      } catch (err) {
        print(
          '`app_links_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorLinux.registerWith();
      } catch (err) {
        print(
          '`file_selector_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        LinuxFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerLinux.registerWith();
      } catch (err) {
        print(
          '`image_picker_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherLinux.registerWith();
      } catch (err) {
        print(
          '`url_launcher_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FileSelectorMacOS.registerWith();
      } catch (err) {
        print(
          '`file_selector_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        MacOSFlutterLocalNotificationsPlugin.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SqfliteDarwin.registerWith();
      } catch (err) {
        print(
          '`sqflite_darwin` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherMacOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        FileSelectorWindows.registerWith();
      } catch (err) {
        print(
          '`file_selector_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FlutterLocalNotificationsWindows.registerWith();
      } catch (err) {
        print(
          '`flutter_local_notifications_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FlutterSecureStorageWindows.registerWith();
      } catch (err) {
        print(
          '`flutter_secure_storage_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerWindows.registerWith();
      } catch (err) {
        print(
          '`image_picker_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherWindows.registerWith();
      } catch (err) {
        print(
          '`url_launcher_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}
===== C:\flutter_apps\im_legends\lib\core\di\dependency_injection.dart =====
import 'package:get_it/get_it.dart';
import '../../features/champion/data/repo/champion_repo.dart';
import '../../features/champion/data/service/champion_service.dart';
import '../../features/champion/logic/cubit/champion_cubit.dart';
import '../../features/profile/data/repo/profile_repo.dart';
import '../../features/profile/data/service/profile_service.dart';
import '../../features/profile/logic/cubit/profile_cubit.dart';
import '../../features/home/data/repo/leader_board_repo.dart';
import '../../features/home/data/service/leader_board_service.dart';
import '../../features/home/logic/cubit/leader_board_cubit.dart';
import '../../features/add_match/data/repo/add_match_repo.dart';
import '../../features/add_match/logic/cubit/add_match_cubit.dart';
import '../../features/notification/data/repos/notification_repo.dart';
import '../../features/notification/logic/cubit/notifications_cubit.dart';
import '../../features/auth/data/service/auth_service.dart';
import '../../features/auth/data/repo/auth_repo.dart';
import '../../features/auth/logic/cubit/auth_cubit.dart';

final getIt = GetIt.instance;

Future<void> setupGetIt() async {
  // Auth Dependencies
  getIt.registerLazySingleton<AuthService>(() => AuthService());
  getIt.registerLazySingleton<AuthRepo>(
    () => AuthRepo(authService: getIt<AuthService>()),
  );

  // Leaderboard Dependencies
  getIt.registerLazySingleton<LeaderboardService>(() => LeaderboardService());
  getIt.registerLazySingleton<LeaderBoardRepo>(
    () => LeaderBoardRepo(leaderboardService: getIt<LeaderboardService>()),
  );
  getIt.registerFactory<AuthCubit>(
    () => AuthCubit(authRepo: getIt<AuthRepo>()),
  );
  getIt.registerFactory<LeaderBoardCubit>(
    () => LeaderBoardCubit(repo: getIt<LeaderBoardRepo>()),
  );

  // Add Match Dependencies
  getIt.registerLazySingleton<AddMatchRepo>(() => AddMatchRepo());
  getIt.registerFactory<AddMatchCubit>(
    () => AddMatchCubit(addMatchRepo: getIt<AddMatchRepo>()),
  );

  //  Champion Dependencies
  getIt.registerLazySingleton<ChampionService>(() => ChampionService());
  getIt.registerLazySingleton<ChampionRepo>(
    () => ChampionRepo(championService: getIt<ChampionService>()),
  );
  getIt.registerFactory<ChampionCubit>(
    () => ChampionCubit(repository: getIt<ChampionRepo>()),
  );

  //  Profile Dependencies
  getIt.registerLazySingleton<ProfileService>(() => ProfileService());
  getIt.registerLazySingleton<ProfileRepo>(
    () => ProfileRepo(profileService: getIt<ProfileService>()),
  );
  getIt.registerFactory<ProfileCubit>(
    () => ProfileCubit(profileRepo: getIt<ProfileRepo>()),
  );

  // Notification Dependencies
  getIt.registerLazySingleton<NotificationRepo>(() => NotificationRepo());
  getIt.registerFactory<NotificationsCubit>(
    () => NotificationsCubit(notificationRepo: getIt<NotificationRepo>()),
  );
}
===== C:\flutter_apps\im_legends\lib\core\models\players_states_model.dart =====
class PlayerStatsModel {
  final String playerId;
  final String playerName;
  final String? profileImage;

  final int matchesPlayed;
  final int wins;
  final int losses;
  final int goalsScored;
  final int goalsReceived;
  final int goalDifference;
  final int points;
  final int? rank;

  PlayerStatsModel({
    required this.playerId,
    required this.playerName,
    this.profileImage,
    this.matchesPlayed = 0,
    this.wins = 0,
    this.losses = 0,
    this.goalsScored = 0,
    this.goalsReceived = 0,
    this.goalDifference = 0,
    this.points = 0,
    this.rank,
  });

  PlayerStatsModel copyWith({
    String? playerId,
    String? playerName,
    String? profileImage,
    int? matchesPlayed,
    int? wins,
    int? losses,
    int? goalsScored,
    int? goalsReceived,
    int? goalDifference,
    int? points,
    int? rank,
  }) {
    return PlayerStatsModel(
      playerId: playerId ?? this.playerId,
      playerName: playerName ?? this.playerName,
      profileImage: profileImage ?? this.profileImage,
      matchesPlayed: matchesPlayed ?? this.matchesPlayed,
      wins: wins ?? this.wins,
      losses: losses ?? this.losses,
      goalsScored: goalsScored ?? this.goalsScored,
      goalsReceived: goalsReceived ?? this.goalsReceived,
      goalDifference: goalDifference ?? this.goalDifference,
      points: points ?? this.points,
      rank: rank ?? this.rank,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\models\user_data.dart =====
class UserData {
  final String name;
  final String email;
  final String phoneNumber;
  final int age;
  final String? profileImageUrl;

  UserData({
    required this.name,
    required this.email,
    required this.phoneNumber,
    required this.age,
    this.profileImageUrl,
  });

  /// Factory for creating a UserData object from a Supabase map
  factory UserData.fromMap(Map<String, dynamic> map) {
    return UserData(
      name: map['name'] ?? '',
      email: map['email'] ?? '',
      phoneNumber: map['phone_number'] ?? '',
      age: map['age'] ?? 0,
      profileImageUrl: map['profile_image'],
    );
  }

  /// Converts UserData into a map for inserting/updating Supabase
  Map<String, dynamic> toMap(String uid) {
    return {
      'id': uid,
      'name': name,
      'phone_number': phoneNumber,
      'age': age,
      'email': email,
      'profile_image': profileImageUrl,
      'created_at': DateTime.now().toIso8601String(),
    };
  }

  UserData copyWith({String? profileImageUrl}) {
    return UserData(
      name: name,
      email: email,
      phoneNumber: phoneNumber,
      age: age,
      profileImageUrl: profileImageUrl ?? this.profileImageUrl,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\router\app_router.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../features/add_match/logic/cubit/add_match_cubit.dart';
import '../../features/add_match/ui/add_match_screen.dart';
import '../../features/auth/data/service/auth_service.dart';
import '../../features/auth/logic/cubit/auth_cubit.dart';
import '../../features/auth/ui/login_screen.dart';
import '../../features/auth/ui/sign_up_screen.dart';
import '../../features/champion/logic/cubit/champion_cubit.dart';
import '../../features/champion/ui/champion_screen.dart';
import '../../features/history/logic/cubit/match_history_cubit.dart';
import '../../features/history/ui/history_screen.dart';
import '../../features/home/logic/cubit/leader_board_cubit.dart';
import '../../features/home/ui/home_screen.dart';
import '../../features/notification/data/models/notification_model.dart';
import '../../features/notification/logic/cubit/notifications_cubit.dart';
import '../../features/notification/ui/notifications_screen.dart';
import '../../features/notification/ui/widgets/notification_details_screen.dart';
import '../../features/onboarding/ui/on_boarding_screen.dart';
import '../../features/profile/logic/cubit/profile_cubit.dart';
import '../../features/profile/ui/profile_screen.dart';
import '../di/dependency_injection.dart';
import '../widgets/main_scaffold.dart';
import '../widgets/not_screen_found.dart';
import 'route_paths.dart';

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

final GoRouter router = GoRouter(
  navigatorKey: navigatorKey,
  initialLocation: Routes.onBoardingScreen,
  errorBuilder: (_, __) => const NotFoundScreen(),
  redirect: _authRedirect,
  routes: [
    // Public routes
    GoRoute(
      path: Routes.onBoardingScreen,
      builder: (_, __) => const OnBoardingScreen(),
    ),
    GoRoute(
      path: Routes.loginScreen,
      builder: (_, __) => _withAuthProviders(const LoginScreen()),
    ),
    GoRoute(
      path: Routes.signUpScreen,
      builder: (_, __) => _withAuthProviders(const SignUpScreen()),
    ),
    GoRoute(
      path: Routes.notificationDetailsScreen,
      builder: (_, state) {
        final notification = state.extra as NotificationModel;
        return NotificationDetailsScreen(notification: notification);
      },
    ),

    // Main shell routes
    ShellRoute(
      builder: (_, __, child) => _withMainProviders(MainScaffold(child: child)),
      routes: [
        GoRoute(
          path: Routes.homeScreen,
          builder: (_, __) => const HomeScreen(),
        ),
        GoRoute(
          path: Routes.addMatchScreen,
          builder: (_, __) => const AddMatchScreen(),
        ),
        GoRoute(
          path: Routes.championsScreen,
          builder: (_, __) => const ChampionScreen(),
        ),
        GoRoute(
          path: Routes.historyScreen,
          builder: (_, __) => const HistoryScreen(),
        ),
        GoRoute(
          path: Routes.profileScreen,
          builder: (_, __) => const ProfileScreen(),
        ),
        GoRoute(
          path: Routes.notificationsScreen,
          builder: (_, __) => const NotificationsScreen(),
        ),
      ],
    ),
  ],
);

// -------------------------
// Helpers
// -------------------------

Widget _withAuthProviders(Widget child) {
  return MultiBlocProvider(
    providers: [
      BlocProvider(create: (_) => getIt<AuthCubit>()),
      BlocProvider(create: (_) => getIt<NotificationsCubit>()),
    ],
    child: child,
  );
}

Widget _withMainProviders(Widget child) {
  return MultiBlocProvider(
    providers: [
      BlocProvider(create: (_) => getIt<LeaderBoardCubit>()..loadLeaderboard()),
      BlocProvider(create: (_) => MatchHistoryCubit()..getMatchHistory()),
      BlocProvider(create: (_) => getIt<AddMatchCubit>()),
      BlocProvider(create: (_) => getIt<ProfileCubit>()..fetchProfile()),
      BlocProvider(create: (_) => getIt<ChampionCubit>()..fetchTopThree()),
      BlocProvider(
        create: (_) => getIt<NotificationsCubit>()..fetchNotifications(),
      ),
    ],
    child: child,
  );
}

Future<String?> _authRedirect(BuildContext context, GoRouterState state) async {
  final isLoggedIn = await AuthService.isLoggedIn();

  if (!isLoggedIn && !Routes.publicRoutes.contains(state.matchedLocation)) {
    return Routes.onBoardingScreen;
  }
  if (isLoggedIn && state.matchedLocation == Routes.onBoardingScreen) {
    return Routes.homeScreen;
  }
  return null;
}
===== C:\flutter_apps\im_legends\lib\core\router\route_paths.dart =====
abstract class Routes {
  // Public routes
  static const String onBoardingScreen = '/onboarding';
  static const String loginScreen = '/login';
  static const String signUpScreen = '/signup';

  // Protected main navigation routes
  static const String homeScreen = '/home';
  static const String addMatchScreen = '/add-match';
  static const String championsScreen = '/champions';
  static const String historyScreen = '/history';
  static const String profileScreen = '/profile';

  // Protected standalone routes
  static const String notificationsScreen = '/notifications';
  static const String notificationDetailsScreen = '/notification-details';

  /// Public route paths that don't require authentication
  static const List<String> publicRoutes = [
    onBoardingScreen,
    loginScreen,
    signUpScreen,
  ];
}
===== C:\flutter_apps\im_legends\lib\core\service\auth_service.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';

import 'supa_base_service.dart';

class AuthService extends SupaBaseService {
  Future<AuthResponse> signUp(String email, String password) async {
    final response = await supabase.auth.signUp(
      email: email,
      password: password,
    );
    if (response.user != null)
      await secureStorage.saveUserId(response.user!.id);
    return response;
  }

  Future<AuthResponse> login(String email, String password) async {
    final response = await supabase.auth.signInWithPassword(
      email: email,
      password: password,
    );
    if (response.user != null)
      await secureStorage.saveUserId(response.user!.id);
    return response;
  }

  Future<void> logout() async => await supabase.auth.signOut();
}
===== C:\flutter_apps\im_legends\lib\core\service\database_service.dart =====

import 'supa_base_service.dart';

class DatabaseService extends SupaBaseService {
  Future<List<Map<String, dynamic>>> fetchAllMatches() async {
    return await supabase.from('matches').select('*');
  }

  Future<List<Map<String, dynamic>>> fetchMatchesForPlayer(
    String userId,
  ) async {
    return await supabase
        .from('matches')
        .select('*')
        .or('winner_id.eq.$userId,loser_id.eq.$userId');
  }
}
===== C:\flutter_apps\im_legends\lib\core\service\notification_service.dart =====
// import 'package:flutter/foundation.dart';
// import '../../features/notification/data/models/notification_model.dart';
// import 'supa_base_service.dart';

// class NotificationService extends SupaBaseService {
//   Future<void> insertNotification(NotificationModel model) async {
//     await supabase.from('user_notifications').insert(model.toSupabase());
//     debugPrint('âœ… Notification inserted');
//   }

//   Future<List<NotificationModel>> getUserNotifications(String userId) async {
//     final response = await supabase
//         .from('user_notifications')
//         .select()
//         .eq('user_id', userId)
//         .order('created_at', ascending: false);

//     return (response as List)
//         .map((row) => NotificationModel.fromSupabase(row))
//         .toList();
//   }

//   Future<void> markAsRead(String notificationId) async {
//     await supabase
//         .from('user_notifications')
//         .update({'is_read': true})
//         .eq('notification_id', notificationId);
//   }

//   Future<void> deleteNotification(String id) async {
//     await supabase
//         .from('user_notifications')
//         .delete()
//         .eq('notification_id', id);
//   }
// }
===== C:\flutter_apps\im_legends\lib\core\service\storage_service.dart =====
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'supa_base_service.dart';

class StorageService extends SupaBaseService {
  Future<String> uploadProfileImage(File image, String userId) async {
    final fileName = 'profile_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final filePath = '$userId/$fileName';
    await supabase.storage.from('profile_images').upload(filePath, image);
    final publicUrl = supabase.storage
        .from('profile_images')
        .getPublicUrl(filePath);
    debugPrint('âœ… Uploaded image: $publicUrl');
    return publicUrl;
  }

  Future<void> deleteProfileImage(String path) async {
    await supabase.storage.from('profile_images').remove([path]);
    debugPrint('âœ… Deleted image: $path');
  }
}
===== C:\flutter_apps\im_legends\lib\core\service\supa_base_service.dart =====
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../features/notification/data/models/notification_model.dart';
import '../utils/secure_storage.dart';

class SupaBaseService {
  final supabase = Supabase.instance.client;
  final SecureStorage secureStorage = SecureStorage();

  /// ---------------------------
  /// USER DATA METHODS
  /// ---------------------------
  // Insert user data
  Future<void> insertUserData(Map<String, dynamic> userData) async {
    try {
      await supabase.from('users').insert(userData);
      debugPrint('âœ… User profile inserted successfully');
    } on PostgrestException catch (e) {
      debugPrint("âŒ Database error inserting user profile: ${e.message}");
      throw Exception('Database error: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error inserting user profile: $e");
      throw Exception('Unexpected error inserting user profile: $e');
    }
  }

  // Fetch user data by Id
  Future<Map<String, dynamic>?> fetchUserProfileById(String userId) async {
    try {
      final response = await supabase
          .from('users')
          .select()
          .eq('id', userId)
          .single();
      return response;
    } catch (e) {
      debugPrint("âŒ Error fetching user session data: $e");
      return null;
    }
  }

  /// Fetch current user data
  Future<Map<String, dynamic>?> fetchCurrentUserData() async {
    final user = supabase.auth.currentUser;
    if (user == null) return null;

    try {
      // Fetch user profile
      final userResponse = await supabase
          .from('users')
          .select()
          .eq('id', user.id)
          .single();

      // Fetch tokens
      final tokensResponse = await supabase
          .from('user_tokens')
          .select('token')
          .eq('user_id', user.id);

      // Fetch notifications
      final notificationsResponse = await supabase
          .from('user_notifications')
          .select()
          .eq('user_id', user.id)
          .order('created_at', ascending: false);

      return {
        'user': userResponse,
        'tokens': List<String>.from(
          tokensResponse.map((row) => row['token'] as String),
        ),
        'notifications': notificationsResponse.map((row) {
          return {
            'id': row['notification_id'],
            'title': row['title'],
            'message': row['message'],
            'created_at': row['created_at'],
            'type': row['type'],
            'is_read': row['is_read'],
          };
        }).toList(),
      };
    } catch (e) {
      debugPrint("âŒ Error fetching current user session data: $e");
      return null;
    }
  }

  /// ---------------------------
  /// AUTHENTICATION METHODS
  /// ---------------------------

  Future<AuthResponse> signUpUser({
    required String email,
    required String password,
  }) async {
    try {
      final response = await supabase.auth.signUp(
        email: email,
        password: password,
      );
      final userId = response.user?.id;
      if (userId != null) {
        await secureStorage.saveUserId(userId);
      }

      debugPrint('âœ… User signed up successfully: ${response.user?.id}');
      return response;
    } on AuthException catch (e) {
      debugPrint("âŒ Sign-up failed: ${e.message}");
      throw Exception('Sign-up failed: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error during sign-up: $e");
      throw Exception('Unexpected error during sign-up: $e');
    }
  }

  Future<AuthResponse> loginUser({
    required String email,
    required String password,
  }) async {
    try {
      final response = await supabase.auth.signInWithPassword(
        email: email,
        password: password,
      );
      final userId = response.user?.id;
      if (userId != null) {
        await secureStorage.saveUserId(userId);
      }

      debugPrint('âœ… User logged in successfully: ${response.user?.id}');
      return response;
    } on AuthException catch (e) {
      debugPrint("âŒ Login failed: ${e.message}");
      throw Exception('Login failed: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error during login: $e");
      throw Exception('Unexpected error during login: $e');
    }
  }

  Future<void> logoutUser() async {
    try {
      await supabase.auth.signOut();

      debugPrint('âœ… User logged out successfully');
    } catch (e) {
      debugPrint("âŒ Error during logout: $e");
      throw Exception('Error during logout: $e');
    }
  }

  User? get currentUser => supabase.auth.currentUser;

  /// ---------------------------
  /// STORAGE METHODS
  /// ---------------------------

  Future<String> uploadProfileImage(File imageFile, String userId) async {
    final fileName = 'profile_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final filePath = '$userId/$fileName';

    try {
      await supabase.storage.from('profile_images').upload(filePath, imageFile);
      final publicUrl = supabase.storage
          .from('profile_images')
          .getPublicUrl(filePath);
      debugPrint('âœ… Profile image uploaded successfully: $publicUrl');
      return publicUrl;
    } on StorageException catch (e) {
      debugPrint("âŒ Failed to upload profile image: ${e.message}");
      throw Exception('Failed to upload profile image: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error while uploading profile image: $e");
      throw Exception('Unexpected error while uploading profile image: $e');
    }
  }

  Future<void> deleteProfileImage(String filePath) async {
    try {
      await supabase.storage.from('profile_images').remove([filePath]);
      debugPrint('âœ… Profile image deleted successfully: $filePath');
    } on StorageException catch (e) {
      debugPrint("âŒ Failed to delete profile image: ${e.message}");
      throw Exception('Failed to delete profile image: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error while deleting profile image: $e");
      throw Exception('Unexpected error while deleting profile image: $e');
    }
  }

  /// ---------------------------
  /// TOKEN MANAGEMENT METHODS
  /// ---------------------------

  Future<void> saveOrUpdateToken(String userId, String token) async {
    try {
      // First, check if token already exists
      final existingTokens = await supabase
          .from('user_tokens')
          .select('token')
          .eq('user_id', userId)
          .eq('token', token);

      if (existingTokens.isEmpty) {
        // Token doesn't exist, insert it
        await supabase.from('user_tokens').upsert({
          'user_id': userId,
          'token': token,
          'created_at': DateTime.now().toIso8601String(),
        });
        debugPrint('âœ… New FCM token saved successfully');
      } else {
        // Token already exists, update timestamp
        await supabase
            .from('user_tokens')
            .update({'updated_at': DateTime.now().toIso8601String()})
            .eq('user_id', userId)
            .eq('token', token);
        debugPrint('âœ… FCM token updated successfully');
      }
    } on PostgrestException catch (e) {
      debugPrint("âŒ Failed to save/update FCM token: ${e.message}");
      throw Exception('Failed to save/update FCM token: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error saving/updating FCM token: $e");
      throw Exception('Unexpected error saving/updating FCM token: $e');
    }
  }

  Future<List<String>> getUserTokens(String userId) async {
    try {
      final response = await supabase
          .from('user_tokens')
          .select('token')
          .eq('user_id', userId);

      return List<String>.from(response.map((row) => row['token'] as String));
    } catch (e) {
      debugPrint("âŒ Error fetching user tokens: $e");
      return [];
    }
  }

  Future<void> removeUserToken(String userId, String token) async {
    try {
      await supabase
          .from('user_tokens')
          .delete()
          .eq('user_id', userId)
          .eq('token', token);
      debugPrint('âœ… User token removed successfully');
    } on PostgrestException catch (e) {
      debugPrint("âŒ Failed to remove user token: ${e.message}");
      throw Exception('Failed to remove user token: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error removing user token: $e");
      throw Exception('Unexpected error removing user token: $e');
    }
  }

  Future<void> removeAllTokens(String userId) async {
    try {
      await supabase.from('user_tokens').delete().eq('user_id', userId);
      debugPrint('âœ… All user tokens removed successfully');
    } on PostgrestException catch (e) {
      debugPrint("âŒ Failed to remove all user tokens: ${e.message}");
      throw Exception('Failed to remove all user tokens: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error removing all user tokens: $e");
      throw Exception('Unexpected error removing all user tokens: $e');
    }
  }

  /// ---------------------------
  /// NOTIFICATION METHODS
  /// ---------------------------

  // Method 1: Insert using model
  Future<void> insertNotificationFromModel(
    NotificationModel notification,
  ) async {
    try {
      await supabase
          .from('user_notifications')
          .insert(notification.toSupabase());
      debugPrint('âœ… Notification inserted successfully');
    } on PostgrestException catch (e) {
      debugPrint("âŒ Failed to insert notification: ${e.message}");
      throw Exception('Failed to insert notification: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error inserting notification: $e");
      throw Exception('Unexpected error inserting notification: $e');
    }
  }

  // Method 2: Insert with parameters (your existing method, updated)
  Future<void> insertNotification({
    required String userId,
    required String title,
    required String message,
    required NotificationType type, // Changed to enum
    String? notificationId,
  }) async {
    try {
      await supabase.from('user_notifications').insert({
        'user_id': Supabase.instance.client.auth.currentUser!.id,
        'notification_id':
            notificationId ?? DateTime.now().millisecondsSinceEpoch.toString(),
        'title': title,
        'message': message,
        'type': type.name, // Store as string
        'is_read': false,
        'created_at': DateTime.now().toIso8601String(),
      });
      debugPrint('âœ… Notification inserted successfully');
    } on PostgrestException catch (e) {
      debugPrint("âŒ Failed to insert notification: ${e.message}");
      throw Exception('Failed to insert notification: ${e.message}');
    } catch (e) {
      debugPrint("âŒ Unexpected error inserting notification: $e");
      throw Exception('Unexpected error inserting notification: $e');
    }
  }

  // Updated get method using the model
  Future<List<NotificationModel>> getUserNotifications(String userId) async {
    try {
      final response = await supabase
          .from('user_notifications')
          .select()
          .eq('user_id', userId)
          .order('created_at', ascending: false);

      return (response as List).map((row) {
        return NotificationModel.fromSupabase(row);
      }).toList();
    } catch (e) {
      debugPrint("âŒ Error fetching user notifications: $e");
      return [];
    }
  }

  // Additional helpful methods
  Future<void> markAsRead(String notificationId) async {
    try {
      await supabase
          .from('user_notifications')
          .update({'is_read': true})
          .eq('notification_id', notificationId);
      debugPrint('âœ… Notification marked as read');
    } catch (e) {
      debugPrint("âŒ Error marking notification as read: $e");
      throw Exception('Failed to mark notification as read: $e');
    }
  }

  Future<void> deleteNotification(String notificationId) async {
    try {
      await supabase
          .from('user_notifications')
          .delete()
          .eq('notification_id', notificationId);
      debugPrint('âœ… Notification deleted successfully');
    } catch (e) {
      debugPrint("âŒ Error deleting notification: $e");
      throw Exception('Failed to delete notification: $e');
    }
  }
}
===== C:\flutter_apps\im_legends\lib\core\service\token_service.dart =====
import 'package:flutter/foundation.dart';
import 'supa_base_service.dart';

class TokenService extends SupaBaseService {
  Future<void> saveToken(String userId, String token) async {
    final existing = await supabase
        .from('user_tokens')
        .select('token')
        .eq('user_id', userId)
        .eq('token', token);

    if (existing.isEmpty) {
      await supabase.from('user_tokens').insert({
        'user_id': userId,
        'token': token,
        'created_at': DateTime.now().toIso8601String(),
      });
      debugPrint('âœ… New token saved');
    } else {
      await supabase
          .from('user_tokens')
          .update({'updated_at': DateTime.now().toIso8601String()})
          .eq('user_id', userId)
          .eq('token', token);
      debugPrint('âœ… Token updated');
    }
  }

  Future<List<String>> getTokens(String userId) async {
    final res = await supabase
        .from('user_tokens')
        .select('token')
        .eq('user_id', userId);
    return List<String>.from(res.map((t) => t['token'] as String));
  }

  Future<void> removeToken(String userId, String token) async {
    await supabase
        .from('user_tokens')
        .delete()
        .eq('user_id', userId)
        .eq('token', token);
  }

  Future<void> removeAllTokens(String userId) async {
    await supabase.from('user_tokens').delete().eq('user_id', userId);
  }
}
===== C:\flutter_apps\im_legends\lib\core\service\user_service.dart =====
import 'package:flutter/foundation.dart';
import 'supa_base_service.dart';

class UserService extends SupaBaseService {
  Future<void> insertUser(Map<String, dynamic> data) async {
    await supabase.from('users').insert(data);
    debugPrint('âœ… User inserted');
  }

  Future<Map<String, dynamic>?> fetchUserById(String userId) async {
    return await supabase.from('users').select().eq('id', userId).maybeSingle();
  }

  Future<List<Map<String, dynamic>>> fetchAllUsers() async {
    return await supabase.from('users').select('id, name, profile_image');
  }

  Future<Map<String, dynamic>?> fetchCurrentUserData() async {
    final user = currentUser;
    if (user == null) return null;
    return await fetchUserById(user.id);
  }
}
===== C:\flutter_apps\im_legends\lib\core\themes\text_styles\bebas_text_styles.dart =====
import 'package:flutter/material.dart';
import '../app_font_weight.dart';
import '../../utils/app_assets.dart';
import 'text_style_factory.dart';

class BebasTextStyles {
  static const _font = AppAssets.fontBebasNeue;

  // White Bold
  static final whiteBold12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold24 = TextStyleFactory.create(
    font: _font,
    size: 24,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  // Grey Regular
  static final greyRegular12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );

  // Grey Bold
  static final greyBold12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: Colors.grey,
  );
  static final greyBold14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.bold,
    color: Colors.grey,
  );
  static final greyBold16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.bold,
    color: Colors.grey,
  );
  static final greyBold18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.bold,
    color: Colors.grey,
  );
  static final greyBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: Colors.grey,
  );
}
===== C:\flutter_apps\im_legends\lib\core\themes\text_styles\borel_text_styles.dart =====
import 'package:flutter/material.dart';

import '../../utils/app_assets.dart';
import '../app_colors.dart';
import '../app_font_weight.dart';
import 'text_style_factory.dart';

class BorelTextStyles {
  static const _font = AppAssets.fontBorel;
  static final whiteBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  static final greyRegular12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final redBold12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );

  static final greyRegular14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final redBold14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );

  static final greyRegular16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final redBold16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );

  static final greyRegular18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final redBold18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );

  static final greyRegular20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final redBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
}
===== C:\flutter_apps\im_legends\lib\core\themes\text_styles\roboto_text_styles.dart =====
import 'package:flutter/material.dart';
import '../app_colors.dart';
import '../app_font_weight.dart';
import '../../utils/app_assets.dart';
import 'text_style_factory.dart';

class RobotoTextStyles {
  static const _font = AppAssets.fontRoboto;

  static final greyRegular12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final whiteBold12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  static final greyRegular14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final whiteBold14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  static final greyRegular16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final whiteSemiBold16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.semiBold,
    color: Colors.white,
  );

  static final greyRegular18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final whiteBold18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  static final greyBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: Colors.grey,
  );
  static final whiteBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  static final whiteBold24 = TextStyleFactory.create(
    font: _font,
    size: 24,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  static final errorRed12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
}
===== C:\flutter_apps\im_legends\lib\core\themes\text_styles\tajawal_text_styles.dart =====
import 'package:flutter/material.dart';

import '../app_colors.dart';
import '../app_font_weight.dart';
import 'text_style_factory.dart';

class TajawalTextStyles {
  static const _font = 'Tajawal';

  // Grey Regular
  static final greyRegular12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );
  static final greyRegular20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.regular,
    color: Colors.grey,
  );

  // White Bold
  static final whiteBold12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );
  static final whiteBold20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: Colors.white,
  );

  // Error Red
  static final errorRed12 = TextStyleFactory.create(
    font: _font,
    size: 12,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
  static final errorRed14 = TextStyleFactory.create(
    font: _font,
    size: 14,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
  static final errorRed16 = TextStyleFactory.create(
    font: _font,
    size: 16,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
  static final errorRed18 = TextStyleFactory.create(
    font: _font,
    size: 18,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
  static final errorRed20 = TextStyleFactory.create(
    font: _font,
    size: 20,
    weight: FontWeightHelper.bold,
    color: AppColors.darkRedColor,
  );
}
===== C:\flutter_apps\im_legends\lib\core\themes\text_styles\text_style_factory.dart =====
import 'package:flutter/material.dart';

class TextStyleFactory {
  static TextStyle create({
    required String font,
    required double size,
    required FontWeight weight,
    required Color color,
  }) {
    return TextStyle(
      fontFamily: font,
      fontSize: size,
      fontWeight: weight,
      color: color,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\themes\app_colors.dart =====
import 'package:flutter/material.dart';

class AppColors {
  static const Color darkColor = Color(0xFF191919);
  static const Color lightDarkColor = Color(0xFF2A2D3A);
  static const Color greyColor = Color(0xFFDEDEDE);
  static const Color darkRedColor = Color(0xFF940721);
  static const Color goldColor = Color(0xFFFFB800);
  static const Color winColor = Colors.green;
  static const Color loseColor = Color.fromARGB(144, 185, 185, 185);
}
===== C:\flutter_apps\im_legends\lib\core\themes\app_font_weight.dart =====
import 'package:flutter/material.dart';

class FontWeightHelper {
  static const FontWeight thin = FontWeight.w100;
  static const FontWeight extraLight = FontWeight.w200;
  static const FontWeight light = FontWeight.w300;
  static const FontWeight regular = FontWeight.w400;
  static const FontWeight medium = FontWeight.w500;
  static const FontWeight semiBold = FontWeight.w600;
  static const FontWeight bold = FontWeight.w700;
  static const FontWeight extraBold = FontWeight.w800;
  static const FontWeight black = FontWeight.w900;
}
===== C:\flutter_apps\im_legends\lib\core\themes\app_texts_style.dart =====
export 'text_styles/bebas_text_styles.dart';
export 'text_styles/roboto_text_styles.dart';
export 'text_styles/borel_text_styles.dart';
export 'text_styles/tajawal_text_styles.dart';
===== C:\flutter_apps\im_legends\lib\core\utils\functions\date_formate.dart =====
import 'package:intl/intl.dart';

DateTime onlyDate(DateTime dt) => DateTime(dt.year, dt.month, dt.day);

// Short date and time
String formatShort(DateTime dateTime) {
  return DateFormat('d MMM, h:mm a').format(dateTime); // â†’ 20 Jul, 3:45 PM
}

// Full readable format
String formatFull(DateTime dateTime) {
  return DateFormat(
    'EEE, d MMM yyyy Â· h:mm a',
  ).format(dateTime); // â†’ Sat, 20 Jul 2025 Â· 3:45 PM
}

String formatSmart(DateTime date) {
  final now = DateTime.now();
  final today = DateTime(now.year, now.month, now.day);
  final taskDate = DateTime(date.year, date.month, date.day);

  if (taskDate == today) {
    return 'Today Â· ${DateFormat('h:mm a').format(date)}';
  }
  if (taskDate == today.add(const Duration(days: 1))) {
    return 'Tomorrow Â· ${DateFormat('h:mm a').format(date)}';
  }
  return DateFormat('EEE, d MMM Â· h:mm a').format(date);
}
===== C:\flutter_apps\im_legends\lib\core\utils\functions\get_rank_color.dart =====

import 'package:flutter/material.dart';

Color getRankColor(int rank) {
  switch (rank) {
    case 1:
      return Colors.amber.shade600; // Gold for Rank 1
    case 2:
      return const Color(0xFFC0C0C0); // Silver for Rank 2
    case 3:
      return Colors.orange.shade900; // Bronze for Rank 3
    default:
      return Colors.grey.shade800; // Normal color for other ranks
  }
}
===== C:\flutter_apps\im_legends\lib\core\utils\functions\image_picker.dart =====
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:image_picker/image_picker.dart';

class ImagePickerHelper {
  static Future<File?> showImageSourceActionSheet(BuildContext context) async {
    return showModalBottomSheet<File?>(
      context: context,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20.r)),
      ),
      builder: (_) {
        return SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(vertical: 16.h, horizontal: 20.w),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                ListTile(
                  leading: const Icon(
                    Icons.photo_library,
                    color: Colors.blueAccent,
                  ),
                  title: const Text('Choose from Gallery'),
                  onTap: () async {
                    Navigator.pop(
                      context,
                      await _pickImageFromSource(ImageSource.gallery),
                    );
                  },
                ),
                ListTile(
                  leading: const Icon(
                    Icons.camera_alt,
                    color: Colors.blueAccent,
                  ),
                  title: const Text('Take a Photo'),
                  onTap: () async {
                    Navigator.pop(
                      context,
                      await _pickImageFromSource(ImageSource.camera),
                    );
                  },
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  /// Handles picking image from camera or gallery
  static Future<File?> _pickImageFromSource(ImageSource source) async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: source, imageQuality: 75);
    return pickedFile != null ? File(pickedFile.path) : null;
  }
}
===== C:\flutter_apps\im_legends\lib\core\utils\functions\refresh_page.dart =====
  import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../features/champion/logic/cubit/champion_cubit.dart';
import '../../../features/history/logic/cubit/match_history_cubit.dart';
import '../../../features/home/logic/cubit/leader_board_cubit.dart';
import '../../../features/profile/logic/cubit/profile_cubit.dart';

Future<void> onRefresh(BuildContext context) async {
    await Future.wait([
      context.read<LeaderBoardCubit>().loadLeaderboard(),
      context.read<MatchHistoryCubit>().getMatchHistory(),
      context.read<ProfileCubit>().fetchProfile(),
      context.read<ChampionCubit>().fetchTopThree(),
    ]);
  }
===== C:\flutter_apps\im_legends\lib\core\utils\app_assets.dart =====
class AppAssets {
  //Svgs
  static const String appSvgLogo = 'assets/svgs/logo.svg';

  //Images
  static const String appLogoPng = 'assets/images/ImLogo.png';
  static const String championBannerjpg = 'assets/images/champion_baner.jpg';

  // Font family names
  static const String fontBebasNeue = 'BebasNeue';
  static const String fontBorel = 'Borel';
  static const String fontTajawal = 'Tajawal';
  static const String fontRoboto = 'RobotoCondensed';
}
===== C:\flutter_apps\im_legends\lib\core\utils\notification_messages.dart =====
import 'package:intl/intl.dart';

import '../../features/notification/data/models/notification_model.dart';

class NotificationMessages {
  static final DateFormat _dateFormat = DateFormat('yyyy-MM-dd HH:mm');

  static NotificationModel loginMessage({
    required String userId,
    required String userName,
    required String email,
  }) {
    final now = DateTime.now();
    return NotificationModel(
      id: now.millisecondsSinceEpoch.toString(),
      userId: userId,
      title: "Welcome Back! ðŸ‘‹",
      message:
          "Hi $userName, you logged in successfully on ${_dateFormat.format(now)}.\nEmail: $email",
      time: now,
      type: NotificationType.system,
      isRead: false,
    );
  }

  static NotificationModel signUpMessage({
    required String userId,
    required String userName,
    required String email,
  }) {
    final now = DateTime.now();
    return NotificationModel(
      id: now.millisecondsSinceEpoch.toString(),
      userId: userId,
      title: "Welcome to IM Legends! ðŸŽ‰",
      message:
          "Hi $userName, your account was created on ${_dateFormat.format(now)}.\nEmail: $email",
      time: now,
      type: NotificationType.system,
      isRead: false,
    );
  }

  static NotificationModel winnerMessage({
    required String userId,
    required String userName,
  }) {
    final now = DateTime.now();
    return NotificationModel(
      id: now.millisecondsSinceEpoch.toString(),
      userId: userId,
      title: "Congratulations! ðŸŽ‰",
      message: "Hi $userName, you won the game on ${_dateFormat.format(now)}",
      time: now,
      type: NotificationType.welcome,
      isRead: false,
    );
  }

  static NotificationModel loserMessage({
    required String userId,
    required String userName,
  }) {
    final now = DateTime.now();
    return NotificationModel(
      id: now.millisecondsSinceEpoch.toString(),
      userId: userId,
      title: "Unlucky, $userName ðŸ˜”",
      message: "Hi $userName, you lost the game on ${_dateFormat.format(now)}",
      time: now,
      type: NotificationType.welcome,
      isRead: false,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\utils\regex.dart =====
class AppRegex {
  static bool isEmailValid(String email) {
    return RegExp(
      r'^.+@[a-zA-Z]+\.{1}[a-zA-Z]+(\.{0,1}[a-zA-Z]+)$',
    ).hasMatch(email);
  }

  static bool isPasswordValid(String password) {
    return RegExp(
      r"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$",
    ).hasMatch(password);
  }

  static bool hasLowerCase(String password) {
    return RegExp(r'^(?=.*[a-z])').hasMatch(password);
  }

  static bool hasUpperCase(String password) {
    return RegExp(r'^(?=.*[A-Z])').hasMatch(password);
  }

  static bool hasNumber(String password) {
    return RegExp(r'^(?=.*?[0-9])').hasMatch(password);
  }

  static bool hasSpecialCharacter(String password) {
    return RegExp(r'^(?=.*?[#?!@$%^&*-])').hasMatch(password);
  }

  static bool hasMinLength(String password) {
    return RegExp(r'^(?=.{8,})').hasMatch(password);
  }

  static bool isPhoneNumberValid(String phoneNumber) {
    return RegExp(
      r'^(01[0125][0-9]{8})$|^(?:\+20)(1[0125][0-9]{8})$',
    ).hasMatch(phoneNumber);
  }
}
===== C:\flutter_apps\im_legends\lib\core\utils\secure_storage.dart =====
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class SecureStorage {
  final _storage = const FlutterSecureStorage();

  Future<void> saveToken(String token) async {
    await _storage.write(key: 'token', value: token);
  }

  Future<String?> getToken() async {
    return await _storage.read(key: 'token');
  }

  Future<void> clearToken() async {
    await _storage.delete(key: 'token');
  }

  Future<void> saveUserId(String userId) async {
    await _storage.write(key: 'user_id', value: userId);
  }

  Future<String?> getUserId() async {
    return await _storage.read(key: 'user_id');
  }

  Future<void> clearUserId() async {
    await _storage.delete(key: 'user_id');
  }
}
===== C:\flutter_apps\im_legends\lib\core\utils\shared_prefs.dart =====

import 'package:shared_preferences/shared_preferences.dart';
class SharedPrefStorage {
  SharedPrefStorage._();
  static final SharedPrefStorage instance = SharedPrefStorage._();

  late final SharedPreferences _prefs;
  bool _initialized = false;

  /// ---------------------------
  /// Initialize SharedPreferences (call once in main)
  /// ---------------------------
  Future<void> init() async {
    if (_initialized) return;
    _prefs = await SharedPreferences.getInstance();
    _initialized = true;
  }

  void _checkInit() {
    if (!_initialized) {
      throw Exception('SharedPrefs not initialized. Call init() first.');
    }
  }

  /// ---------------------------
  /// Basic getters/setters
  /// ---------------------------
  Future<bool> setString(String key, String value) async {
    _checkInit();
    return _prefs.setString(key, value);
  }

  String? getString(String key) {
    _checkInit();
    return _prefs.getString(key);
  }

  Future<bool> setBool(String key, bool value) async {
    _checkInit();
    return _prefs.setBool(key, value);
  }

  bool? getBool(String key) {
    _checkInit();
    return _prefs.getBool(key);
  }

  Future<bool> setInt(String key, int value) async {
    _checkInit();
    return _prefs.setInt(key, value);
  }

  int? getInt(String key) {
    _checkInit();
    return _prefs.getInt(key);
  }

  Future<bool> setDouble(String key, double value) async {
    _checkInit();
    return _prefs.setDouble(key, value);
  }

  double? getDouble(String key) {
    _checkInit();
    return _prefs.getDouble(key);
  }

  Future<bool> setStringList(String key, List<String> value) async {
    _checkInit();
    return _prefs.setStringList(key, value);
  }

  List<String>? getStringList(String key) {
    _checkInit();
    return _prefs.getStringList(key);
  }

  /// ---------------------------
  /// Notification-specific methods (scoped by userId)
  /// ---------------------------

  // Future<bool> setNotifications(
  //   String userId,
  //   List<NotificationModel> notifications,
  // ) async {
  //   _checkInit();
  //   final jsonList = notifications.map((n) => json.encode(n.toJson())).toList();
  //   return _prefs.setStringList('notifications_$userId', jsonList);
  // }

  // List<NotificationModel> getNotifications(String userId) {
  //   _checkInit();
  //   final jsonList = _prefs.getStringList('notifications_$userId') ?? [];
  //   return jsonList
  //       .map(
  //         (jsonString) => NotificationModel.fromJson(json.decode(jsonString)),
  //       )
  //       .toList();
  // }

  /// Remove all notifications for a specific user
  // Future<bool> clearUserNotifications(String userId) async {
  //   _checkInit();
  //   return _prefs.remove('notifications_$userId');
  // }

  /// Deduplicate notifications by id for a specific user
  // Future<void> removeDuplicateNotifications(String userId) async {
  //   final notifications = getNotifications(userId);
  //   final unique = {for (var n in notifications) n.id: n}.values.toList();
  //   await setNotifications(userId, unique);
  // }

  /// ---------------------------
  /// General helpers
  /// ---------------------------
  Future<bool> remove(String key) async {
    _checkInit();
    return _prefs.remove(key);
  }

  Future<bool> clearAll() async {
    _checkInit();
    return _prefs.clear();
  }

  bool containsKey(String key) {
    _checkInit();
    return _prefs.containsKey(key);
  }
}
===== C:\flutter_apps\im_legends\lib\core\utils\spacing.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

SizedBox verticalSpacing(double height) => SizedBox(height: height.h);
SizedBox horizontalSpacing(double width) => SizedBox(width: width.h);
===== C:\flutter_apps\im_legends\lib\core\widgets\animated_page.dart =====
import 'package:flutter/material.dart';

class AnimatedPage extends StatelessWidget {
  final Widget child;
  const AnimatedPage({required this.child});

  @override
  Widget build(BuildContext context) {
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 300),
      switchInCurve: Curves.easeOutCubic,
      switchOutCurve: Curves.easeInCubic,
      transitionBuilder: (child, animation) {
        return FadeTransition(
          opacity: animation,
          child: SlideTransition(
            position: Tween<Offset>(
              begin: const Offset(0.1, 0),
              end: Offset.zero,
            ).animate(animation),
            child: ScaleTransition(
              scale: Tween<double>(begin: 0.98, end: 1.0).animate(animation),
              child: child,
            ),
          ),
        );
      },
      child: child,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\custom_app_bar.dart =====
// custom_app_bar.dart
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_svg/svg.dart';
import 'package:go_router/go_router.dart';
import 'package:im_legends/core/router/route_paths.dart';
import 'package:im_legends/features/notification/logic/cubit/notifications_cubit.dart';
import 'package:im_legends/features/profile/logic/cubit/profile_cubit.dart';

import '../themes/app_texts_style.dart';
import '../utils/app_assets.dart';
import '../utils/spacing.dart';
import 'notification_icon.dart';

class CustomAppBar extends StatelessWidget {
  final String title;
  const CustomAppBar({super.key, required this.title});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.only(top: 40, left: 20, right: 20, bottom: 10),
      decoration: const BoxDecoration(
        color: Color(0xFF191919),
        borderRadius: BorderRadius.vertical(bottom: Radius.circular(16)),
        boxShadow: [
          BoxShadow(
            color: Color(0xFF323743),
            offset: Offset(0, 4),
            blurRadius: 8,
          ),
        ],
      ),
      child: Row(
        children: [
          Expanded(
            child: Center(
              child: Text(title, style: BebasTextStyles.whiteBold20),
            ),
          ),
          // Notifications from cubit
          BlocBuilder<NotificationsCubit, NotificationsState>(
            builder: (context, state) {
              if (state is NotificationsSuccess) {
                final unreadCount = state.notifications
                    .where((notification) => !notification.isRead)
                    .length;
                return NotificationIcon(unreadCount: unreadCount);
              } else {
                return const NotificationIcon(unreadCount: 0);
              }
            },
          ),
          horizontalSpacing(8),
          GestureDetector(
            onTap: () => context.go(Routes.profileScreen),
            child: CircleAvatar(
              radius: 20,
              backgroundColor: Colors.white,
              child: ClipOval(
                child: SizedBox(
                  width: 36,
                  height: 36,
                  child: BlocBuilder<ProfileCubit, ProfileState>(
                    builder: (context, state) {
                      if (state is ProfileSuccess) {
                        final profile = state.player.user;
                        if (profile.profileImageUrl == null ||
                            profile.profileImageUrl!.isEmpty) {
                          return SvgPicture.asset(
                            AppAssets.appSvgLogo,
                            fit: BoxFit.cover,
                            width: 36,
                            height: 36,
                          );
                        }
                        return CachedNetworkImage(
                          imageUrl: profile.profileImageUrl!,
                          fit: BoxFit.cover,
                          width: 36,
                          height: 36,
                          placeholder: (context, url) =>
                              const CircularProgressIndicator(strokeWidth: 2),
                          errorWidget: (context, url, error) =>
                              SvgPicture.asset(
                                AppAssets.appSvgLogo,
                                fit: BoxFit.cover,
                                width: 36,
                                height: 36,
                              ),
                        );
                      } else {
                        return SvgPicture.asset(
                          AppAssets.appSvgLogo,
                          fit: BoxFit.cover,
                          width: 36,
                          height: 36,
                        );
                      }
                    },
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\custom_bottom_navigation_bar.dart =====
import 'package:flutter/material.dart';
import '../themes/app_colors.dart';

class CustomBottomNavBar extends StatefulWidget {
  final Function(int) onTabSelected;
  final int selectedIndex;

  const CustomBottomNavBar({
    super.key,
    required this.onTabSelected,
    required this.selectedIndex,
  });

  @override
  State<CustomBottomNavBar> createState() => _CustomBottomNavBarState();
}

class _CustomBottomNavBarState extends State<CustomBottomNavBar>
    with TickerProviderStateMixin {
  @override
  Widget build(BuildContext context) {
    final items = [
      {'icon': Icons.home, 'label': 'Home'},
      {'icon': Icons.star, 'label': 'Champions'},
      {'icon': Icons.history, 'label': 'History'},
      {'icon': Icons.person, 'label': 'Profile'},
    ];

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: const Color(0xFF191919),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFF191919).withAlpha((0.2 * 255).toInt()),
            blurRadius: 10,
          ),
        ],
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: List.generate(items.length, (index) {
          final item = items[index];
          final isSelected = index == widget.selectedIndex;
          return GestureDetector(
            onTap: () => widget.onTabSelected(index),
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 300),
              padding: EdgeInsets.symmetric(
                horizontal: 12,
                vertical: isSelected ? 6 : 8,
              ),
              decoration: BoxDecoration(
                color: isSelected
                    ? AppColors.darkRedColor.withAlpha((0.2 * 255).toInt())
                    : Colors.transparent,
                borderRadius: BorderRadius.circular(16),
              ),
              child: Row(
                children: [
                  AnimatedScale(
                    scale: isSelected ? 1.3 : 1.0,
                    duration: const Duration(milliseconds: 300),
                    curve: Curves.easeOutBack,
                    child: Icon(
                      item['icon'] as IconData,
                      color: isSelected ? Colors.white : AppColors.greyColor,
                      size: 24,
                    ),
                  ),
                  const SizedBox(width: 6),
                  AnimatedSize(
                    duration: const Duration(milliseconds: 300),
                    curve: Curves.easeInOut,
                    child: Text(
                      isSelected ? item['label'] as String : '',
                      style: const TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          );
        }),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\custom_text_button.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../themes/app_colors.dart';
import '../themes/app_texts_style.dart';

class CustomTextButton extends StatelessWidget {
  const CustomTextButton({
    super.key,
    required this.buttonText,
    this.textStyle,
    required this.onPressed,
    this.borderRadius,
    this.backgroundColor,
    this.buttonWidth,
    this.buttonHeight,
    this.verticalPadding,
    this.horizontalPadding,
    this.isLoading = false,
    this.icon,
  });
  final String buttonText;
  final TextStyle? textStyle;
  final VoidCallback? onPressed;
  final double? borderRadius;
  final Color? backgroundColor;
  final double? buttonWidth;
  final double? buttonHeight;
  final double? verticalPadding;
  final double? horizontalPadding;
  final bool isLoading;
  final Icon? icon;

  @override
  Widget build(BuildContext context) {
    return TextButton(
      style: ButtonStyle(
        shape: WidgetStateProperty.all(
          RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(borderRadius ?? 16),
          ),
        ),
        backgroundColor: WidgetStateProperty.all(
          backgroundColor ?? AppColors.darkRedColor,
        ),
        padding: WidgetStateProperty.all(
          EdgeInsets.symmetric(
            vertical: verticalPadding?.h ?? 12.h,
            horizontal: horizontalPadding?.w ?? 14.w,
          ),
        ),
        fixedSize: WidgetStateProperty.all(
          Size(buttonWidth ?? double.maxFinite, buttonHeight?.h ?? 50.h),
        ),
        tapTargetSize: MaterialTapTargetSize.shrinkWrap,
        minimumSize: WidgetStateProperty.all(const Size(double.infinity, 52)),
      ),
      onPressed: isLoading ? null : onPressed,
      child: isLoading
          ? SizedBox(
              width: 24.w,
              height: 24.h,
              child: const CircularProgressIndicator(
                strokeWidth: 2.5,
                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
              ),
            )
          : Text(buttonText, style: textStyle ?? RobotoTextStyles.whiteBold20),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\gradient_background.dart =====
import 'package:flutter/material.dart';

class GradientBackground extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry padding;

  const GradientBackground({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.symmetric(horizontal: 20.0, vertical: 16.0),
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: MediaQuery.of(context).size.width, // full width
      height: MediaQuery.of(context).size.height,
      decoration: const BoxDecoration(
        gradient: const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [Color(0xFF2A3441), Color(0xFF1E2832), Color(0xFF1E2832)],
          stops: [0.0, 0.7, 1.0],
        ),
      ),
      child: SafeArea(
        child: Padding(padding: padding, child: child),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\logo_top_bar.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:flutter_svg/svg.dart';

import '../themes/app_texts_style.dart';
import '../utils/app_assets.dart';

class LogoTopBar extends StatelessWidget {
  const LogoTopBar({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Logo with subtle glow effect
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: const RadialGradient(
                colors: [Color(0xFF2A3441), Color(0xFF1E2832)],
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withAlpha((0.3 * 255).toInt()),
                  blurRadius: 8,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: SvgPicture.asset(
              AppAssets.appSvgLogo,
              height: 32.h,
              width: 32.w,
            ),
          ),

          const SizedBox(width: 12),

          // App name with gradient text
          ShaderMask(
            shaderCallback: (bounds) => const LinearGradient(
              colors: [Colors.white, Color(0xFFE8E8E8)],
            ).createShader(bounds),
            child: Text('IM Legends', style: RobotoTextStyles.whiteBold20),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\main_scaffold.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:go_router/go_router.dart';

import '../router/route_paths.dart';
import 'animated_page.dart';
import 'custom_bottom_navigation_bar.dart';

class MainScaffold extends StatelessWidget {
  final Widget child;
  const MainScaffold({super.key, required this.child});

  static final List<String> _tabs = [
    Routes.homeScreen,
    Routes.championsScreen,
    Routes.historyScreen,
    Routes.profileScreen,
  ];

  int _getCurrentIndex(BuildContext context) {
    final location = GoRouter.of(context);
    final index = _tabs.indexWhere(
      (path) => location.routerDelegate.currentConfiguration.fullPath
          .startsWith(path),
    );
    return index == -1 ? 0 : index;
  }

  void _onTabSelected(BuildContext context, int index) {
    HapticFeedback.selectionClick();
    context.go(_tabs[index]);
  }

  @override
  Widget build(BuildContext context) {
    final currentIndex = _getCurrentIndex(context);

    return Scaffold(
      body: AnimatedPage(child: child),

      bottomNavigationBar: Container(
        decoration: BoxDecoration(
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha((0.15 * 255).toInt()),
              blurRadius: 8,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: CustomBottomNavBar(
          selectedIndex: currentIndex,
          onTabSelected: (i) => _onTabSelected(context, i),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\notification_icon.dart =====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../router/route_paths.dart';

class NotificationIcon extends StatelessWidget {
  final int unreadCount;
  const NotificationIcon({super.key, required this.unreadCount});

  @override
  Widget build(BuildContext context) {
    return Stack(
      clipBehavior: Clip.none,
      children: [
        IconButton(
          icon: const Icon(Icons.notifications_rounded, color: Colors.white),
          onPressed: () {
            context.push(Routes.notificationsScreen);
          },
        ),
        if (unreadCount > 0)
          Positioned(
            right: 6,
            top: 6,
            child: Container(
              padding: const EdgeInsets.all(4),
              decoration: const BoxDecoration(
                color: Colors.red,
                shape: BoxShape.circle,
              ),
              constraints: const BoxConstraints(minWidth: 18, minHeight: 18),
              child: Center(
                child: Text(
                  unreadCount > 9 ? '9+' : unreadCount.toString(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\core\widgets\not_screen_found.dart =====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../router/route_paths.dart';
import '../themes/app_colors.dart';
import '../themes/app_texts_style.dart';

class NotFoundScreen extends StatelessWidget {
  const NotFoundScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF1E1E2C), Color(0xFF3A3A4F)],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(
                  Icons.error_outline,
                  size: 100,
                  color: AppColors.darkRedColor,
                ),
                const SizedBox(height: 24),
                Text(
                  'Oops! Page not found.',
                  style: RobotoTextStyles.greyBold20, // make text bigger
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 16),
                Text(
                  'The page you are looking for does not exist.\nTry going back to home.',
                  style: RobotoTextStyles.greyBold20, // normal text style
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),
                ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.darkRedColor,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 32,
                      vertical: 16,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 5,
                  ),
                  onPressed: () {
                    context.go(Routes.homeScreen);
                  },
                  child: Text('Go to Home', style: RobotoTextStyles.greyBold20),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\data\models\match_model.dart =====
class MatchModel {
  final String winnerId;
  final String loserId;
  final int winnerScore;
  final int loserScore;
  final DateTime createdAt;

  MatchModel({
    required this.winnerId,
    required this.loserId,
    required this.winnerScore,
    required this.loserScore,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now();

  // Convert to JSON for Supabase insert
  Map<String, dynamic> toJson() {
    return {
      'winner_id': winnerId,
      'loser_id': loserId,
      'winner_score': winnerScore,
      'loser_score': loserScore,
      'created_at': createdAt.toIso8601String(),
    };
  }

  // Factory to parse from Supabase
  factory MatchModel.fromJson(Map<String, dynamic> json) {
    return MatchModel(
      winnerId: json['winner_id'] as String,
      loserId: json['loser_id'] as String,
      winnerScore: json['winner_score'] as int,
      loserScore: json['loser_score'] as int,
      createdAt: DateTime.parse(json['created_at'] as String),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\data\repo\add_match_repo.dart =====
import 'package:flutter/material.dart';
import '../service/add_match_service.dart';
import '../models/match_model.dart';

class AddMatchRepo {
  final AddMatchService _addMatchService = AddMatchService();

  // Get Users List
  Future<List<Map<String, dynamic>>> getAllUsers() async {
    try {
      final users = await _addMatchService.fetchAllUsers();
      return users;
    } catch (e) {
      debugPrint("âŒ Error fetching users list: $e");
      return [];
    }
  }

  // Insert a match
  Future<bool> addMatch(MatchModel match) async {
    try {
      return await _addMatchService.insertMatch(match);
    } catch (e) {
      debugPrint("âŒ Error inserting match: $e");
      return false;
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\data\service\add_match_service.dart =====
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../models/match_model.dart';

class AddMatchService {
  final supabase = Supabase.instance.client;

  // Fetch all users' IDs, names, and profile images
  Future<List<Map<String, dynamic>>> fetchAllUsers() async {
    try {
      final response = await supabase
          .from('users')
          .select('id, name, profile_image')
          .order('name', ascending: true);

      return response
          .map(
            (user) => {
              'id': user['id'] as String,
              'name': user['name'] as String,
              'profile_image': user['profile_image'] as String?,
            },
          )
          .toList();
    } catch (e) {
      debugPrint("âŒ Error fetching all users: $e");
      return [];
    }
  }

  // Insert new match into Supabase
  Future<bool> insertMatch(MatchModel match) async {
    try {
      final response = await supabase
          .from('matches')
          .insert(match.toJson())
          .select();

      debugPrint("âœ… Match inserted: $response");
      return true;
    } catch (e) {
      debugPrint("âŒ Error inserting match: $e");
      return false;
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\logic\cubit\add_match_cubit.dart =====
import 'package:bloc/bloc.dart';
import '../../data/models/match_model.dart';
import '../../data/repo/add_match_repo.dart';
import 'package:meta/meta.dart';

part 'add_match_state.dart';

class AddMatchCubit extends Cubit<AddMatchState> {
  final AddMatchRepo addMatchRepo;

  AddMatchCubit({required this.addMatchRepo}) : super(AddMatchInitial());

  // Fetch players
  Future<void> getPlayersList() async {
    emit(AddMatchLoading());
    try {
      final players = await addMatchRepo.getAllUsers();
      emit(AddMatchPlayersSuccess(players));
    } catch (e) {
      emit(AddMatchFailure(e.toString()));
    }
  }

  // Insert a match
  Future<void> addMatch(MatchModel match) async {
    emit(AddMatchLoading());
    try {
      final success = await addMatchRepo.addMatch(match);
      if (success) {
        emit(AddMatchInsertSuccess("âœ… Match inserted successfully"));
      } else {
        emit(AddMatchFailure("âš ï¸ Failed to insert match"));
      }
    } catch (e) {
      emit(AddMatchFailure(e.toString()));
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\logic\cubit\add_match_state.dart =====
part of 'add_match_cubit.dart';

@immutable
sealed class AddMatchState {}

final class AddMatchInitial extends AddMatchState {}

final class AddMatchLoading extends AddMatchState {}

// For players list
final class AddMatchPlayersSuccess extends AddMatchState {
  final List<Map<String, dynamic>> players;
  AddMatchPlayersSuccess(this.players);
}

// For insert match success
final class AddMatchInsertSuccess extends AddMatchState {
  final String message;
  AddMatchInsertSuccess(this.message);
}

final class AddMatchFailure extends AddMatchState {
  final String error;
  AddMatchFailure(this.error);
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\players_bottom_sheet.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../logic/cubit/add_match_cubit.dart';
import 'player_tile.dart';
import '../../../../../core/themes/app_texts_style.dart';

class PlayerBottomSheet extends StatefulWidget {
  final String? selectedPlayer;
  final void Function(String id, String name, String imageUrl) onSelect;
  final String? excludedPlayer;

  const PlayerBottomSheet({
    super.key,
    required this.selectedPlayer,
    required this.onSelect,
    this.excludedPlayer,
  });

  @override
  State<PlayerBottomSheet> createState() => _PlayerBottomSheetState();
}

class _PlayerBottomSheetState extends State<PlayerBottomSheet> {
  @override
  void initState() {
    super.initState();
    context.read<AddMatchCubit>().getPlayersList();
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      height: MediaQuery.of(context).size.height * 0.6,
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [Color(0xFF1A1D26), Color(0xFF141620)],
        ),
        borderRadius: BorderRadius.vertical(top: Radius.circular(24.r)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.6 * 255).toInt()),
            blurRadius: 24,
            offset: const Offset(0, -8),
          ),
        ],
      ),
      child: Column(
        children: [
          _buildHandleBar(),
          _buildHeader(),
          Expanded(
            child: BlocBuilder<AddMatchCubit, AddMatchState>(
              builder: (context, state) {
                if (state is AddMatchLoading) {
                  return const Center(child: CircularProgressIndicator());
                } else if (state is AddMatchFailure) {
                  return _buildError(state.error);
                } else if (state is AddMatchPlayersSuccess) {
                  final filteredPlayers = state.players
                      .where((p) => p['id'] != widget.excludedPlayer)
                      .map(
                        (p) => {
                          'id': p['id'] as String,
                          'name': p['name'] as String,
                          'profile_image': p['profile_image'] as String? ?? '',
                        },
                      )
                      .toList();

                  if (filteredPlayers.isEmpty) {
                    return _buildEmpty();
                  }

                  return ListView.builder(
                    padding: EdgeInsets.symmetric(horizontal: 16.w),
                    itemCount: filteredPlayers.length,
                    itemBuilder: (context, index) {
                      final player = filteredPlayers[index];
                      final isSelected = widget.selectedPlayer == player['id'];

                      return PlayerTile(
                        playerName: player['name'] as String,
                        isSelected: isSelected,
                        index: index,
                        playerImage: player['profile_image'] ?? '',
                        playerId: player['id'] as String,
                        onSelect: (selectedId, selectedName, selectedImage) {
                          widget.onSelect(
                            selectedId,
                            selectedName,
                            selectedImage,
                          );
                          Navigator.pop(context);
                        },
                      );
                    },
                  );
                }
                return const SizedBox.shrink();
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildHandleBar() => Container(
    margin: EdgeInsets.only(top: 12.h),
    width: 40.w,
    height: 4.h,
    decoration: BoxDecoration(
      color: Colors.white.withAlpha((0.15 * 255).toInt()),
      borderRadius: BorderRadius.circular(2.r),
    ),
  );

  Widget _buildHeader() => Padding(
    padding: EdgeInsets.all(20.w),
    child: Row(
      children: [
        Icon(Icons.sports_esports_rounded, color: Colors.blue, size: 24.sp),
        SizedBox(width: 12.w),
        Text('Choose Player', style: BebasTextStyles.whiteBold20),
        const Spacer(),
        BlocBuilder<AddMatchCubit, AddMatchState>(
          builder: (context, state) {
            if (state is AddMatchPlayersSuccess) {
              final filteredCount = state.players
                  .map((p) => p['id'] as String)
                  .where((id) => id != widget.excludedPlayer)
                  .length;
              return Text(
                '$filteredCount players',
                style: TextStyle(
                  color: Colors.white.withAlpha((0.6 * 255).toInt()),
                  fontSize: 12.sp,
                ),
              );
            }
            return const SizedBox.shrink();
          },
        ),
      ],
    ),
  );

  Widget _buildError(String error) => Center(
    child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(Icons.error_outline, color: Colors.red, size: 48.sp),
        SizedBox(height: 16.h),
        Text(
          'Error loading players',
          style: TextStyle(color: Colors.red, fontSize: 16.sp),
        ),
        SizedBox(height: 8.h),
        Text(
          error,
          style: TextStyle(color: Colors.white, fontSize: 14.sp),
          textAlign: TextAlign.center,
        ),
      ],
    ),
  );

  Widget _buildEmpty() => Center(
    child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Icon(
          Icons.person_off_outlined,
          color: Colors.white.withAlpha((0.4 * 255).toInt()),
          size: 48.sp,
        ),
        SizedBox(height: 16.h),
        Text(
          'No players available',
          style: TextStyle(
            color: Colors.white.withAlpha((0.6 * 255).toInt()),
            fontSize: 16.sp,
          ),
        ),
      ],
    ),
  );
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\player_field_animations.dart =====
import 'package:flutter/material.dart';

class PlayerFieldAnimations {
  final TickerProvider vsync;

  late AnimationController scaleController;
  late AnimationController rotationController;
  late AnimationController glowController;

  late Animation<double> scaleAnimation;
  late Animation<double> rotationAnimation;
  late Animation<double> glowAnimation;

  PlayerFieldAnimations({required this.vsync}) {
    _setupAnimations();
  }

  void _setupAnimations() {
    scaleController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: vsync,
    );

    rotationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: vsync,
    );

    glowController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: vsync,
    );

    scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: scaleController, curve: Curves.easeInOut),
    );

    rotationAnimation = Tween<double>(begin: 0.0, end: 0.5).animate(
      CurvedAnimation(parent: rotationController, curve: Curves.elasticOut),
    );

    glowAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(parent: glowController, curve: Curves.easeInOut));
  }

  // ðŸ”¹ Control methods
  void startScaleDown() => scaleController.forward();
  void resetScale() => scaleController.reverse();

  void startRotation() => rotationController.forward(from: 0);

  void startGlow() => glowController.repeat(reverse: true);
  void stopGlow() => glowController.stop();

  void dispose() {
    scaleController.dispose();
    rotationController.dispose();
    glowController.dispose();
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\player_field_avatar.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

class PlayerFieldAvatar extends StatelessWidget {
  final bool isSelected;
  final String? imageUrl;

  const PlayerFieldAvatar({super.key, required this.isSelected, this.imageUrl});

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      width: 40.w,
      height: 40.h,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        gradient: !isSelected || imageUrl == null
            ? LinearGradient(
                colors: [
                  Colors.grey.withAlpha((0.4 * 255).toInt()),
                  Colors.grey.withAlpha((0.2 * 255).toInt()),
                ],
              )
            : null,
      ),
      child: ClipOval(
        child: isSelected && imageUrl != null && imageUrl!.isNotEmpty
            ? Image.network(
                imageUrl!,
                fit: BoxFit.cover,
                errorBuilder: (_, __, ___) =>
                    Icon(Icons.person, color: Colors.white, size: 20.sp),
              )
            : Icon(
                isSelected ? Icons.person : Icons.person_outline,
                color: Colors.white,
                size: 20.sp,
              ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\player_field_drop_down_arrow.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

class PlayerFieldDropdownArrow extends StatelessWidget {
  final Animation<double> rotationAnimation;
  final bool isSelected;

  const PlayerFieldDropdownArrow({
    super.key,
    required this.rotationAnimation,
    required this.isSelected,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: rotationAnimation,
      builder: (context, child) => Transform.rotate(
        angle: rotationAnimation.value * 3.14159,
        child: Icon(
          Icons.keyboard_arrow_down_rounded,
          color: isSelected
              ? const Color(0xFF4A90E2)
              : Colors.white.withAlpha((0.7 * 255).toInt()),
          size: 28.sp,
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\player_field_info.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../../core/themes/app_colors.dart';
import '../../../../../core/themes/app_texts_style.dart';

class PlayerFieldInfo extends StatelessWidget {
  final String? selectedPlayer;
  final String hint;

  const PlayerFieldInfo({super.key, this.selectedPlayer, required this.hint});

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          AnimatedDefaultTextStyle(
            duration: const Duration(milliseconds: 300),
            style: BebasTextStyles.whiteBold20.copyWith(
              color: selectedPlayer == null ? Colors.white54 : Colors.white,
              fontSize: selectedPlayer != null ? 20.sp : 16.sp,
              fontWeight: selectedPlayer != null
                  ? FontWeight.bold
                  : FontWeight.normal,
            ),
            child: Text(
              selectedPlayer ?? hint,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          if (selectedPlayer != null) SizedBox(height: 4.h),
          if (selectedPlayer != null)
            Text(
              'Player Selected',
              style: TextStyle(
                color: AppColors.greyColor,
                fontSize: 10.sp,
                fontWeight: FontWeight.w500,
              ),
            ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\player_select_field.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../logic/cubit/add_match_cubit.dart';
import '../../../../../core/themes/app_colors.dart';
import 'player_field_avatar.dart';
import 'player_field_drop_down_arrow.dart';
import 'player_field_info.dart';
import 'player_field_animations.dart';
import 'players_bottom_sheet.dart';

class PlayerSelectField extends StatefulWidget {
  final void Function(String id)? onSelected;
  final String hint;
  final String? excludedPlayer;

  const PlayerSelectField({
    super.key,
    this.onSelected,
    this.hint = 'Select Player',
    this.excludedPlayer,
  });

  @override
  State<PlayerSelectField> createState() => _PlayerSelectFieldState();
}

class _PlayerSelectFieldState extends State<PlayerSelectField>
    with TickerProviderStateMixin {
  String? selectedPlayerId;
  String? selectedPlayerName;
  String? selectedPlayerImage;
  bool isPressed = false;

  late PlayerFieldAnimations animations;

  @override
  void initState() {
    super.initState();
    animations = PlayerFieldAnimations(vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) animations.startGlow();
    });
  }

  @override
  void dispose() {
    animations.dispose();
    super.dispose();
  }

  void _onTapDown() {
    setState(() => isPressed = true);
    animations.scaleController.forward();
  }

  void _onTapUp() {
    setState(() => isPressed = false);
    animations.scaleController.reverse();
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8.h, horizontal: 16.w),
      child: GestureDetector(
        onTapDown: (_) => _onTapDown(),
        onTapUp: (_) => _onTapUp(),
        onTapCancel: _onTapUp,
        onTap: () => _showPlayerDialog(context),
        child: AnimatedBuilder(
          animation: Listenable.merge([
            animations.scaleAnimation,
            animations.glowAnimation,
          ]),
          builder: (context, child) => Transform.scale(
            scale: animations.scaleAnimation.value,
            child: _buildFieldContainer(),
          ),
        ),
      ),
    );
  }

  Widget _buildFieldContainer() {
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 16.w),
      height: 56.h,
      decoration: BoxDecoration(
        color: AppColors.darkColor,
        borderRadius: BorderRadius.circular(16.r),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.2 * 255).toInt()),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          PlayerFieldAvatar(
            isSelected: selectedPlayerId != null,
            imageUrl: selectedPlayerImage,
          ),
          SizedBox(width: 16.w),
          PlayerFieldInfo(
            selectedPlayer: selectedPlayerName,
            hint: widget.hint,
          ),
          PlayerFieldDropdownArrow(
            rotationAnimation: animations.rotationAnimation,
            isSelected: selectedPlayerId != null,
          ),
        ],
      ),
    );
  }

  void _showPlayerDialog(BuildContext context) {
    animations.rotationController.forward();
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (dialogContext) => BlocProvider.value(
        value: context.read<AddMatchCubit>(),
        child: PlayerBottomSheet(
          selectedPlayer: selectedPlayerId,
          excludedPlayer: widget.excludedPlayer,
          onSelect: (id, name, imageUrl) => _selectPlayer(id, name, imageUrl),
        ),
      ),
    ).then((_) => animations.rotationController.reverse());
  }

  void _selectPlayer(String id, String name, String imageUrl) {
    setState(() {
      selectedPlayerId = id;
      selectedPlayerName = name;
      selectedPlayerImage = imageUrl;
    });

    widget.onSelected?.call(id);

    animations.glowController.forward().then(
      (_) => animations.glowController.reverse(),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\player_select_field\player_tile.dart =====
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../../core/themes/app_texts_style.dart';

class PlayerTile extends StatelessWidget {
  final String playerName;
  final String playerImage;
  final String playerId;
  final bool isSelected;
  final int index;

  /// Updated: callback returns full player info (id, name, image)
  final void Function(String id, String name, String imageUrl) onSelect;

  const PlayerTile({
    super.key,
    required this.playerName,
    required this.isSelected,
    required this.index,
    required this.onSelect,
    required this.playerImage,
    required this.playerId,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      margin: EdgeInsets.symmetric(vertical: 6.h),
      padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 16.h),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16.r),
        gradient: isSelected
            ? const LinearGradient(
                colors: [Color(0xFF2A4A6B), Color(0xFF1E3A5F)],
              )
            : null,
        color: isSelected ? null : Colors.white.withAlpha((0.03 * 255).toInt()),
        border: isSelected
            ? Border.all(color: const Color(0xFF4A90E2), width: 2)
            : Border.all(
                color: Colors.white.withAlpha((0.08 * 255).toInt()),
                width: 1,
              ),
      ),
      child: InkWell(
        borderRadius: BorderRadius.circular(16.r),
        onTap: () =>
            onSelect(playerId, playerName, playerImage),
        child: Row(
          children: [
            _buildAvatar(),
            SizedBox(width: 16.w),
            Expanded(
              child: Text(
                playerName,
                style: BebasTextStyles.whiteBold20.copyWith(
                  fontSize: 16.sp,
                  color: isSelected
                      ? Colors.white
                      : Colors.white.withAlpha((0.95 * 255).toInt()),
                  fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                ),
              ),
            ),
            if (isSelected)
              Icon(Icons.check_circle_rounded, color: Colors.blue, size: 24.sp),
          ],
        ),
      ),
    );
  }

  Widget _buildAvatar() {
    final hasImage = playerImage.isNotEmpty;

    return Container(
      width: 40.w,
      height: 40.h,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        gradient: LinearGradient(
          colors: [
            Colors.primaries[index % Colors.primaries.length].withAlpha(
              (0.9 * 255).toInt(),
            ),
            Colors.primaries[(index + 1) % Colors.primaries.length].withAlpha(
              (0.7 * 255).toInt(),
            ),
          ],
        ),
      ),
      child: Center(
        child: hasImage
            ? ClipOval(
                child: CachedNetworkImage(
                  imageUrl: playerImage,
                  fit: BoxFit.cover,
                  width: 40.w,
                  height: 40.h,
                  placeholder: (context, url) => const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  ),
                  errorWidget: (context, url, error) =>
                      const Icon(Icons.person, color: Colors.white),
                ),
              )
            : const Icon(Icons.person, color: Colors.white),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\score_input_field\score_control_button.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

class ScoreControlButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  final bool isEnabled;
  final Color accentColor;

  const ScoreControlButton({
    super.key,
    required this.icon,
    required this.onTap,
    required this.isEnabled,
    required this.accentColor,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: isEnabled ? onTap : null,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        width: 32.w,
        height: 32.h,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(8.r),
          gradient: isEnabled
              ? LinearGradient(
                  colors: [
                    accentColor.withAlpha((0.3 * 255).toInt()),
                    accentColor.withAlpha((0.2 * 255).toInt()),
                  ],
                )
              : LinearGradient(
                  colors: [
                    Colors.grey.withAlpha((0.2 * 255).toInt()),
                    Colors.grey.withAlpha((0.1 * 255).toInt()),
                  ],
                ),
          border: Border.all(
            color: isEnabled
                ? accentColor.withAlpha((0.4 * 255).toInt())
                : Colors.grey.withAlpha((0.3 * 255).toInt()),
            width: 1,
          ),
        ),
        child: Icon(
          icon,
          color: isEnabled
              ? Colors.white
              : Colors.white.withAlpha((0.4 * 255).toInt()),
          size: 16.sp,
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\score_input_field\score_count_animations.dart =====
import 'package:flutter/material.dart';

class ScoreFieldAnimations {
  final TickerProvider vsync;

  late AnimationController scaleController;
  late AnimationController glowController;
  late AnimationController scoreChangeController;

  late Animation<double> scaleAnimation;
  late Animation<double> glowAnimation;
  late Animation<double> scoreChangeAnimation;

  ScoreFieldAnimations({required this.vsync}) {
    _setupAnimations();
  }

  void _setupAnimations() {
    scaleController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: vsync,
    );

    glowController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: vsync,
    );

    scoreChangeController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: vsync,
    );

    scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: scaleController, curve: Curves.easeInOut),
    );

    glowAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(parent: glowController, curve: Curves.easeInOut));

    scoreChangeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: scoreChangeController, curve: Curves.elasticOut),
    );

    glowController.repeat(reverse: true);
  }

  // ðŸ”¹ Exposed control methods
  void bumpScore() {
    scaleController.forward(from: 0); // quick "pop" animation
  }

  void startGlow() {
    glowController.repeat(reverse: true);
  }

  void stopGlow() {
    glowController.stop();
  }
  void dispose() {
    scaleController.dispose();
    glowController.dispose();
    scoreChangeController.dispose();
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\score_input_field\score_count_field.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../../core/themes/app_colors.dart';
import 'score_count_animations.dart';
import 'score_input_container.dart';

class ScoreCountField extends StatefulWidget {
  final int initialScore;
  final int minScore;
  final int maxScore;
  final void Function(int)? onScoreChanged;
  final String? label;
  final bool isEditable;
  final Color? accentColor;

  const ScoreCountField({
    super.key,
    this.initialScore = 0,
    this.minScore = 0,
    this.maxScore = 100,
    this.onScoreChanged,
    this.label,
    this.isEditable = true,
    this.accentColor,
  });

  @override
  State<ScoreCountField> createState() => _ScoreCountFieldState();
}

class _ScoreCountFieldState extends State<ScoreCountField>
    with TickerProviderStateMixin {
  late int currentScore;
  late ScoreFieldAnimations animations;

  Color get accentColor => widget.accentColor ?? AppColors.darkRedColor;

  @override
  void initState() {
    super.initState();

    currentScore = widget.initialScore;

    // 1. Create the animations helper
    animations = ScoreFieldAnimations(vsync: this);

    // 2. Start any animations AFTER the first frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        animations.startGlow(); // or animations.startScaleDown(), etc.
      }
    });
  }

  @override
  void dispose() {
    animations.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8.h, horizontal: 16.w),
      child: AnimatedBuilder(
        animation: Listenable.merge([
          animations.scaleAnimation,
          animations.glowAnimation,
          animations.scoreChangeAnimation,
        ]),
        builder: (context, child) {
          return Transform.scale(
            scale:
                animations.scaleAnimation.value +
                (animations.scoreChangeAnimation.value * 0.05),
            child: ScoreInputContainer(
              accentColor: accentColor,
              initialScore: widget.initialScore,
              minScore: widget.minScore,
              maxScore: widget.maxScore,
              isEditable: widget.isEditable,
              onScoreChanged: widget.onScoreChanged,
            ),
          );
        },
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\score_input_field\score_input_container.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'score_control_button.dart';
import 'score_count_animations.dart';
import '../../../../../core/utils/spacing.dart';

class ScoreInputContainer extends StatefulWidget {
  const ScoreInputContainer({
    super.key,
    required this.accentColor,
    required this.initialScore,
    required this.minScore,
    required this.maxScore,
    this.onScoreChanged,
    this.label,
    required this.isEditable,
  });

  final int initialScore;
  final int minScore;
  final int maxScore;
  final void Function(int)? onScoreChanged;
  final String? label;
  final bool isEditable;
  final Color accentColor;

  @override
  State<ScoreInputContainer> createState() => _ScoreInputContainerState();
}

class _ScoreInputContainerState extends State<ScoreInputContainer>
    with TickerProviderStateMixin {
  late ScoreFieldAnimations animations;
  late int currentScore;

  @override
  void initState() {
    super.initState();
    currentScore = widget.initialScore;

    // setup animations
    animations = ScoreFieldAnimations(vsync: this);

    // optional: auto-start glow if editable
    if (widget.isEditable) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) animations.startGlow();
      });
    }
  }

  @override
  void dispose() {
    animations.dispose();
    super.dispose();
  }

  void _incrementScore() {
    if (!widget.isEditable || currentScore >= widget.maxScore) return;
    setState(() => currentScore++);
    widget.onScoreChanged?.call(currentScore);

    animations.bumpScore(); // ðŸŽ‰ trigger pop animation
  }

  void _decrementScore() {
    if (!widget.isEditable || currentScore <= widget.minScore) return;
    setState(() => currentScore--);
    widget.onScoreChanged?.call(currentScore);

    animations.bumpScore();
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.symmetric(vertical: 12.h, horizontal: 16.w),
      decoration: BoxDecoration(
        color: const Color(0xFF1E1E2C),
        borderRadius: BorderRadius.circular(16.r),
        border: Border.all(
          color: widget.accentColor.withAlpha((0.4 * 255).toInt()),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.4 * 255).toInt()),
            blurRadius: 6,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        children: [
          ScoreControlButton(
            icon: Icons.remove_rounded,
            onTap: _decrementScore,
            isEnabled: currentScore > widget.minScore,
            accentColor: widget.accentColor,
          ),
          horizontalSpacing(10),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.center,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                if (widget.label != null)
                  Text(
                    widget.label!,
                    style: TextStyle(
                      color: Colors.white.withAlpha((0.7 * 255).toInt()),
                      fontSize: 12.sp,
                    ),
                  ),
                SizedBox(height: 4.h),
                Text(
                  currentScore.toString(),
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 26.sp,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
          horizontalSpacing(10),
          ScoreControlButton(
            icon: Icons.add_rounded,
            onTap: _incrementScore,
            isEnabled: currentScore < widget.maxScore,
            accentColor: widget.accentColor,
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\add_match_app_bar.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/themes/text_styles/bebas_text_styles.dart';

class AddMatchAppBar extends StatelessWidget {
  const AddMatchAppBar({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.only(
        left: 16.w,
        right: 16.w,
        top: 50.h,
        bottom: 16.h,
      ),
      decoration: BoxDecoration(
        color: Colors.grey[900],
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.3 * 255).toInt()),
            blurRadius: 8.r,
            offset: Offset(0, 2.h),
          ),
        ],
      ),
      child: Row(
        children: [
          GestureDetector(
            onTap: () => context.pop(),
            child: Container(
              padding: EdgeInsets.all(8.w),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(8.r),
              ),
              child: Icon(
                Icons.arrow_back_ios_new,
                size: 20.sp,
                color: Colors.grey[700],
              ),
            ),
          ),
          SizedBox(width: 16.w),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [Text('Add Match', style: BebasTextStyles.whiteBold20)],
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\add_match_bloc_consumer.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'success_dialog.dart';
import '../../../notification/logic/cubit/notifications_cubit.dart';
import '../../../champion/logic/cubit/champion_cubit.dart';
import '../../../profile/logic/cubit/profile_cubit.dart';
import '../../../history/logic/cubit/match_history_cubit.dart';
import '../../../home/logic/cubit/leader_board_cubit.dart';
import '../../data/models/match_model.dart';
import '../../logic/cubit/add_match_cubit.dart';
import 'add_match_button.dart';

class AddMatchBlocConsumer extends StatelessWidget {
  const AddMatchBlocConsumer({
    super.key,
    required bool isAddButtonEnabled,
    required this.winnerPlayer,
    required this.loserPlayer,
    required this.winnerScore,
    required this.loserScore,
  }) : _isAddButtonEnabled = isAddButtonEnabled;

  final bool _isAddButtonEnabled;
  final String? winnerPlayer;
  final String? loserPlayer;
  final int winnerScore;
  final int loserScore;

  @override
  Widget build(BuildContext context) {
    return BlocConsumer<AddMatchCubit, AddMatchState>(
      listener: (context, state) {
        if (state is AddMatchInsertSuccess) {
          context.read<NotificationsCubit>().handleMatchResult(
            winnerId: winnerPlayer!,
            loserId: loserPlayer!,
          );
          context.read<LeaderBoardCubit>().loadLeaderboard();
          context.read<MatchHistoryCubit>().getMatchHistory();
          context.read<ProfileCubit>().fetchProfile();
          context.read<ChampionCubit>().fetchTopThree();

          // Show success dialog
          showDialog(
            context: context,
            barrierDismissible: false, // force user to press button
            builder: (dialogContext) => const SuccessDialog(),
          );
        } else if (state is AddMatchFailure) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(state.error), backgroundColor: Colors.red),
          );
        }
      },
      builder: (context, state) {
        final isLoading = state is AddMatchLoading;

        return AddMatchButton(
          isEnabled: _isAddButtonEnabled,
          isLoading: isLoading,
          onPressed: _isAddButtonEnabled
              ? () {
                  final match = MatchModel(
                    winnerId: winnerPlayer!,
                    loserId: loserPlayer!,
                    winnerScore: winnerScore,
                    loserScore: loserScore,
                  );
                  // call cubit
                  context.read<AddMatchCubit>().addMatch(match);
                }
              : null,
        );
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\add_match_button.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/spacing.dart';

class AddMatchButton extends StatefulWidget {
  final VoidCallback? onPressed;
  final bool isEnabled;
  final String text;
  final IconData icon;
  final double? width;
  final bool isLoading;
  final Widget? child;

  const AddMatchButton({
    super.key,
    this.onPressed,
    this.isEnabled = true,
    this.text = 'Add Match',
    this.icon = Icons.add,
    this.width,
    this.isLoading = false,
    this.child,
  });

  @override
  State<AddMatchButton> createState() => _AddMatchButtonState();
}

class _AddMatchButtonState extends State<AddMatchButton> {
  bool _isPressed = false;

  void _handleTapDown(TapDownDetails details) {
    if (widget.isEnabled && !widget.isLoading) {
      setState(() => _isPressed = true);
    }
  }

  void _handleTapUp(TapUpDetails details) {
    if (widget.isEnabled && !widget.isLoading) {
      setState(() => _isPressed = false);
      widget.onPressed?.call();
    }
  }

  void _handleTapCancel() {
    setState(() => _isPressed = false);
  }

  @override
  Widget build(BuildContext context) {
    final isDisabled = !widget.isEnabled || widget.isLoading;

    return GestureDetector(
      onTapDown: _handleTapDown,
      onTapUp: _handleTapUp,
      onTapCancel: _handleTapCancel,
      child: AnimatedScale(
        scale: _isPressed ? 0.95 : 1.0,
        duration: const Duration(milliseconds: 100),
        curve: Curves.easeInOut,
        child: Container(
          width: widget.width ?? 250.w,
          padding: EdgeInsets.symmetric(horizontal: 20.w, vertical: 14.h),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(16.r),
            color: isDisabled
                ? AppColors.darkRedColor.withAlpha((0.15 * 255).toInt())
                : AppColors.darkRedColor,
            boxShadow: isDisabled
                ? null
                : [
                    BoxShadow(
                      color: AppColors.darkRedColor.withAlpha(
                        (0.15 * 255).toInt(),
                      ),
                      blurRadius: 8.r,
                      offset: Offset(0, 4.h),
                    ),
                    if (_isPressed)
                      BoxShadow(
                        color: AppColors.darkRedColor.withAlpha(
                          (0.5 * 255).toInt(),
                        ),
                        blurRadius: 4.r,
                        offset: Offset(0, 2.h),
                      ),
                  ],
            border: Border.all(
              color: Colors.white.withAlpha((0.15 * 255).toInt()),
              width: 1.w,
            ),
          ),
          child: Center(
            child: widget.isLoading
                ? SizedBox(
                    height: 22.sp,
                    width: 22.sp,
                    child: const CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.white,
                    ),
                  )
                : widget.child ??
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            widget.text,
                            style: BebasTextStyles.whiteBold20.copyWith(
                              color: isDisabled ? Colors.white70 : Colors.white,
                            ),
                          ),
                          horizontalSpacing(6),
                          Icon(
                            widget.icon,
                            color: isDisabled ? Colors.white70 : Colors.white,
                            size: 18.sp,
                          ),
                        ],
                      ),
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\widgets\success_dialog.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/router/route_paths.dart';
import '../../../../core/utils/spacing.dart';

class SuccessDialog extends StatelessWidget {
  const SuccessDialog({super.key});

  @override
  Widget build(BuildContext context) {
    return Dialog(
      backgroundColor: Colors.transparent,
      insetPadding: EdgeInsets.symmetric(horizontal: 40.w),
      child: Container(
        padding: EdgeInsets.symmetric(vertical: 24.h, horizontal: 16.w),
        decoration: BoxDecoration(
          color: Colors.grey.shade900,
          borderRadius: BorderRadius.circular(20.r),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha((0.3 * 255).toInt()),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TweenAnimationBuilder<double>(
              tween: Tween(begin: 0, end: 1),
              duration: const Duration(milliseconds: 800),
              builder: (context, value, child) {
                return Transform.scale(
                  scale: value,
                  child: Icon(
                    Icons.check_circle,
                    color: Colors.greenAccent,
                    size: 60.sp,
                  ),
                );
              },
            ),
            verticalSpacing(16),
            Text(
              'Success!',
              style: TextStyle(
                color: Colors.white,
                fontSize: 22.sp,
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: 8.h),
            Text(
              'Match added successfully!',
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.white70, fontSize: 16.sp),
            ),
            SizedBox(height: 24.h),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.greenAccent,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12.r),
                  ),
                  padding: EdgeInsets.symmetric(vertical: 12.h),
                ),
                onPressed: () {
                  Navigator.pop(context);
                  context.go(Routes.homeScreen);
                },
                child: Text(
                  'Go to Home',
                  style: TextStyle(
                    color: Colors.black,
                    fontSize: 16.sp,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\add_match\ui\add_match_screen.dart =====
import 'package:flutter/material.dart';

import '../../../core/themes/text_styles/bebas_text_styles.dart';
import '../../../core/utils/spacing.dart';
import 'widgets/add_match_app_bar.dart';
import 'widgets/add_match_bloc_consumer.dart';
import 'widgets/player_select_field/player_select_field.dart';
import 'widgets/score_input_field/score_count_field.dart';

class AddMatchScreen extends StatefulWidget {
  const AddMatchScreen({super.key});

  @override
  State<AddMatchScreen> createState() => _AddMatchScreenState();
}

class _AddMatchScreenState extends State<AddMatchScreen> {
  int winnerScore = 0;
  int loserScore = 0;
  String? winnerPlayer;
  String? loserPlayer;

  void _onWinnerScoreChanged(int score) {
    setState(() {
      winnerScore = score;
      if (loserScore > winnerScore) {
        loserScore = winnerScore;
      }
    });
  }

  void _onLoserScoreChanged(int score) {
    setState(() {
      loserScore = score;
    });
  }

  void _onWinnerPlayerChanged(String playerId) {
    setState(() {
      winnerPlayer = playerId;
    });
  }

  void _onLoserPlayerChanged(String playerId) {
    setState(() {
      loserPlayer = playerId;
    });
  }

  bool get _isAddButtonEnabled =>
      winnerScore > loserScore &&
      winnerPlayer != null &&
      loserPlayer != null &&
      winnerPlayer != loserPlayer;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          const AddMatchAppBar(),
          Expanded(
            child: Column(
              children: [
                verticalSpacing(20),
                Text(
                  'Select Players and Scores',
                  style: BebasTextStyles.whiteBold24.copyWith(
                    wordSpacing: 1.5,
                    color: Colors.grey.shade300,
                  ),
                ),
                verticalSpacing(20),
                PlayerSelectField(
                  hint: 'Select Winner',
                  onSelected: _onWinnerPlayerChanged,
                  excludedPlayer: loserPlayer,
                ),
                verticalSpacing(5),
                ScoreCountField(
                  accentColor: Colors.green,
                  initialScore: winnerScore,
                  onScoreChanged: _onWinnerScoreChanged,
                ),
                verticalSpacing(50),
                PlayerSelectField(
                  hint: 'Select Loser',
                  onSelected: _onLoserPlayerChanged,
                  excludedPlayer: winnerPlayer,
                ),
                verticalSpacing(5),
                ScoreCountField(
                  accentColor: Colors.red,
                  initialScore: loserScore,
                  onScoreChanged: _onLoserScoreChanged,
                  maxScore: winnerScore,
                ),
                verticalSpacing(50),
                AddMatchBlocConsumer(
                  isAddButtonEnabled: _isAddButtonEnabled,
                  winnerPlayer: winnerPlayer,
                  loserPlayer: loserPlayer,
                  winnerScore: winnerScore,
                  loserScore: loserScore,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\data\repo\auth_repo.dart =====
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../../../core/models/user_data.dart';
import '../service/auth_service.dart';

class AuthRepo {
  final AuthService _authService;

  AuthRepo({AuthService? authService})
    : _authService = authService ?? AuthService();

  /// Sign up user and return their data
  Future<AuthResponse> signUp({
    required UserData userData,
    required String password,
    File? profileImage,
  }) async {
    try {
      return await _authService.signUp(
        userData: userData,
        password: password,
        profileImage: profileImage,
      );
    } catch (e, stackTrace) {
      debugPrint('Sign-up error: $e\n$stackTrace');
      rethrow;
    }
  }

  /// Login and return user data or auth response
  Future<AuthResponse> login({
    required String email,
    required String password,
  }) async {
    try {
      return await _authService.login(email: email, password: password);
    } catch (e, stackTrace) {
      debugPrint('Login error: $e\n$stackTrace');
      rethrow;
    }
  }

  /// Fetch user data by user ID
  Future<Map<String, dynamic>?> getUserDataById(String userId) async {
    try {
      return await _authService.getUserDataById(userId);
    } catch (e, stackTrace) {
      debugPrint('Fetch user data error: $e\n$stackTrace');
      return null;
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\data\service\auth_service.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import '../../../../core/service/supa_base_service.dart';
import '../../../../core/utils/secure_storage.dart';
import '../../../notification/data/service/firebase_notifications_service.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../../core/models/user_data.dart';

class AuthService {
  final SupaBaseService _supaBaseService = SupaBaseService();

  static Future<bool> isLoggedIn() async {
    String? token = await SecureStorage().getToken();
    return token != null && token.isNotEmpty;
  }

  /// ---------------------------
  /// SIGN UP
  /// ---------------------------
  Future<AuthResponse> signUp({
    required UserData userData,
    required String password,
    File? profileImage,
  }) async {
    try {
      // 1. Create user in Supabase Auth
      final response = await _supaBaseService.signUpUser(
        email: userData.email,
        password: password,
      );

      final uid = response.user?.id;
      if (uid == null) {
        throw Exception('Sign-up failed: UID not found.');
      }

      // 2. Upload profile image if provided
      String? imageUrl;
      if (profileImage != null) {
        imageUrl = await _supaBaseService.uploadProfileImage(profileImage, uid);
      }

      // 3. Insert user profile into 'users' table
      final updatedUserData = userData.copyWith(profileImageUrl: imageUrl);
      await _supaBaseService.insertUserData(updatedUserData.toMap(uid));

      // 4. Save FCM token for this user
      await FirebaseNotificationsService().initialize(uid);

      debugPrint('âœ… Sign-up successful: $uid');
      return response;
    } catch (e) {
      debugPrint('âŒ Sign-up error: $e');
      throw Exception('Sign-up failed: $e');
    }
  }

  /// ---------------------------
  /// LOGIN
  /// ---------------------------
  Future<AuthResponse> login({
    required String email,
    required String password,
  }) async {
    try {
      final response = await _supaBaseService.loginUser(
        email: email,
        password: password,
      );
      if (response.user?.id == null) {
        throw Exception('Login failed: user not found.');
      }
      final uid = response.user!.id;

      // Initialize Firebase notifications
      await FirebaseNotificationsService().initialize(uid);

      debugPrint('âœ… Login successful: $uid');
      return response;
    } catch (e) {
      debugPrint('âŒ Login error: $e');
      throw Exception('Login failed: $e');
    }
  }

  /// ---------------------------
  /// LOGOUT
  /// ---------------------------
  Future<void> logout() async {
    try {
      final user = _supaBaseService.currentUser;
      if (user != null) {
        await _supaBaseService.removeAllTokens(user.id);
      }

      await _supaBaseService.logoutUser();
      debugPrint('User logged out.');
    } catch (e) {
      debugPrint('âŒ Logout error: $e');
      throw Exception('Logout failed: $e');
    }
  }

  /// ---------------------------
  /// GET CURRENT USER DATA
  /// ---------------------------
  Future<Map<String, dynamic>?> getCurrentUserData() async {
    return await _supaBaseService.fetchCurrentUserData();
  }

  /// ---------------------------
  /// GET USER SESSION DATA BY ID
  /// ---------------------------
  Future<Map<String, dynamic>?> getUserDataById(String userId) async {
    return await _supaBaseService.fetchUserProfileById(userId);
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\logic\cubit\auth_cubit.dart =====
import 'dart:io';
import 'package:bloc/bloc.dart';
import 'package:meta/meta.dart';
import '../../data/repo/auth_repo.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../../core/models/user_data.dart';
part 'auth_state.dart';

class AuthCubit extends Cubit<AuthState> {
  AuthCubit({required this.authRepo}) : super(AuthInitial());

  final AuthRepo authRepo;

  Future<void> emitSignUp({
    required UserData userData,
    required String password,
    File? profileImage,
  }) async {
    emit(AuthLoading());
    try {
      final response = await authRepo.signUp(
        userData: userData,
        password: password,
        profileImage: profileImage,
      );
      emit(AuthSuccess(authResponse: response, userData: userData));
    } catch (e) {
      emit(AuthFailure(errorMessage: e.toString()));
    }
  }

  Future<void> emitLogin({
    required String email,
    required String password,
  }) async {
    emit(AuthLoading());
    try {
      final response = await authRepo.login(email: email, password: password);
      final userDataMap = await authRepo.getUserDataById(response.user!.id);
      final userData = userDataMap != null
          ? UserData(
              name: userDataMap['name'] ?? '',
              email: userDataMap['email'] ?? '',
              phoneNumber: userDataMap['phone_number'] ?? '',
              age: userDataMap['age'] ?? 0,
              profileImageUrl: userDataMap['profile_image'],
            )
          : null;
      emit(AuthSuccess(authResponse: response, userData: userData));
    } catch (e) {
      emit(AuthFailure(errorMessage: e.toString()));
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\logic\cubit\auth_state.dart =====
part of 'auth_cubit.dart';

@immutable
sealed class AuthState {}

final class AuthInitial extends AuthState {}

final class AuthLoading extends AuthState {}

class AuthSuccess extends AuthState {
  final AuthResponse authResponse;
  final UserData? userData;

  AuthSuccess({required this.authResponse, this.userData});
}

final class AuthFailure extends AuthState {
  final String errorMessage;
  AuthFailure({required this.errorMessage});
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\widgets\app_text_form_field.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/themes/app_colors.dart';

class AppTextFormField extends StatelessWidget {
  const AppTextFormField({
    super.key,
    required this.hintText,
    this.contentPadding,
    this.focusedBorder,
    this.enabledBorder,
    this.inputTextStyle,
    this.hintStyle,
    this.isObscureText,
    this.suffixIcon,
    this.innerBackgroundColor,
    this.controller,
    required this.validator,
    required this.keyboardType,
  });
  final String hintText;
  final EdgeInsetsGeometry? contentPadding;
  final InputBorder? focusedBorder;
  final InputBorder? enabledBorder;
  final TextStyle? inputTextStyle;
  final TextStyle? hintStyle;
  final TextInputType keyboardType;

  final bool? isObscureText;
  final Widget? suffixIcon;
  final Color? innerBackgroundColor;
  final TextEditingController? controller;
  final Function(String?) validator;
  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(
        isDense: true,
        contentPadding:
            contentPadding ??
            EdgeInsets.symmetric(horizontal: 20.w, vertical: 18.h),
        focusedBorder:
            focusedBorder ??
            OutlineInputBorder(
              borderSide: const BorderSide(
                color: AppColors.greyColor,
                width: 1.3,
              ),
              borderRadius: BorderRadius.circular(16.0),
            ),
        enabledBorder:
            enabledBorder ??
            OutlineInputBorder(
              borderSide: const BorderSide(
                color: Color.fromARGB(95, 185, 185, 185),
                width: 1.4,
              ),
              borderRadius: BorderRadius.circular(16.0),
            ),
        errorBorder: OutlineInputBorder(
          borderSide: const BorderSide(color: Colors.red, width: 1.4),
          borderRadius: BorderRadius.circular(16.0),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderSide: const BorderSide(color: Colors.red, width: 1.4),
          borderRadius: BorderRadius.circular(16.0),
        ),
        hintText: hintText,
        hintStyle: hintStyle ?? TextStyle(fontSize: 14.sp, color: Colors.grey),
        suffixIcon: suffixIcon,
        filled: true,
        fillColor: innerBackgroundColor ?? Colors.transparent,
      ),

      obscureText: isObscureText ?? false,
      style:
          inputTextStyle ??
          TextStyle(
            fontSize: 16.sp,
            color: Colors.white,
            fontFamily: 'RobotoCondensed',
          ),
      validator: (value) {
        return validator(value);
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\widgets\login_bloc_consumer.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import '../../../notification/logic/cubit/notifications_cubit.dart';
import '../../logic/cubit/auth_cubit.dart';
import 'login_form.dart';
import '../../../../core/router/route_paths.dart';

class LoginBlocConsumer extends StatelessWidget {
  const LoginBlocConsumer({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiBlocListener(
      listeners: [
        BlocListener<AuthCubit, AuthState>(
          listener: (context, state) async {
            if (state is AuthSuccess) {
              final user = state.authResponse.user;
              if (user != null) {
                // Initialize notifications
                await context
                    .read<NotificationsCubit>()
                    .notificationRepo
                    .initialize(user.id);
                await context.read<NotificationsCubit>().sendLoginNotification(
                  userId: user.id,
                  userName:
                      state.userData?.name ??
                      user.email?.split('@').first ??
                      'User',
                  email: user.email ?? '',
                );
              }
              context.go(Routes.homeScreen);
            } else if (state is AuthFailure) {
              Navigator.pop(context); // Close loading dialog
              _showErrorDialog(context, state.errorMessage);
            }
          },
        ),
        BlocListener<NotificationsCubit, NotificationsState>(
          listener: (context, state) {
            if (state is NotificationsFailure) {
              _showErrorDialog(context, state.errorMessage);
            }
          },
        ),
      ],
      child: BlocBuilder<AuthCubit, AuthState>(
        builder: (context, state) {
          return LoginForm(
            onLogin: (email, password) {
              context.read<AuthCubit>().emitLogin(
                email: email,
                password: password,
              );
            },
            isLoading: state is AuthLoading,
          );
        },
      ),
    );
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Error'),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\widgets\login_form.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/utils/regex.dart';
import '../../../../core/utils/spacing.dart';
import '../../../../core/widgets/custom_text_button.dart';
import 'app_text_form_field.dart';

class LoginForm extends StatefulWidget {
  final void Function(String email, String password) onLogin;
  final bool isLoading;

  const LoginForm({super.key, required this.onLogin, this.isLoading = false});

  @override
  State<LoginForm> createState() => _LoginFormState();
}

class _LoginFormState extends State<LoginForm> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  bool _isPasswordVisible = false;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _submit() {
    if (_formKey.currentState?.validate() ?? false) {
      widget.onLogin(
        _emailController.text.trim(),
        _passwordController.text.trim(),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          /// --- Email Field ---
          AppTextFormField(
            controller: _emailController,
            hintText: 'Email',
            keyboardType: TextInputType.emailAddress,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Email is required';
              }
              if (!AppRegex.isEmailValid(value.trim())) {
                return 'Enter a valid email';
              }
              return null;
            },
          ),

          verticalSpacing(16.h),

          /// --- Password Field ---
          AppTextFormField(
            controller: _passwordController,
            hintText: 'Password',
            keyboardType: TextInputType.visiblePassword,
            isObscureText: !_isPasswordVisible,
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Password is required';
              }
              if (value.length < 6) {
                return 'Password must be at least 6 characters';
              }
              return null;
            },
            suffixIcon: IconButton(
              icon: Icon(
                _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                color: _isPasswordVisible ? Colors.red : Colors.grey,
              ),
              onPressed: () {
                setState(() => _isPasswordVisible = !_isPasswordVisible);
              },
            ),
          ),

          verticalSpacing(24.h),

          /// --- Login Button ---
          CustomTextButton(
            borderRadius: 12.r,
            buttonText: 'Login',
            onPressed: widget.isLoading ? null : _submit,
            isLoading: widget.isLoading,
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\widgets\sign_up_bloc_consumer.dart =====
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/models/user_data.dart';
import '../../../../core/router/route_paths.dart';
import '../../../../core/widgets/custom_text_button.dart';
import '../../../notification/logic/cubit/notifications_cubit.dart';
import '../../logic/cubit/auth_cubit.dart';
import 'sign_up_form.dart';

class SignUpBlocConsumer extends StatelessWidget {
  const SignUpBlocConsumer({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiBlocListener(
      listeners: [
        BlocListener<AuthCubit, AuthState>(
          listener: (context, state) async {
            if (state is AuthLoading) {
              _showLoadingDialog(context);
            } else if (Navigator.canPop(context)) {
              Navigator.pop(context); // Close loading dialog
            }

            if (state is AuthSuccess) {
              final user = state.authResponse.user;
              if (user != null) {
                await context
                    .read<NotificationsCubit>()
                    .notificationRepo
                    .initialize(user.id);
                // Trigger sign-up notification
                await context.read<NotificationsCubit>().sendSignUpNotification(
                  userId: user.id,
                  userName:
                      state.userData?.name ??
                      user.email?.split('@').first ??
                      'User',
                  email: user.email ?? '',
                );
              }
              context.go(Routes.homeScreen);
            } else if (state is AuthFailure) {
              _showErrorDialog(context, state.errorMessage);
            }
          },
        ),
        BlocListener<NotificationsCubit, NotificationsState>(
          listener: (context, state) {
            if (state is NotificationsFailure) {
              _showErrorDialog(context, state.errorMessage);
            }
          },
        ),
      ],
      child: BlocBuilder<AuthCubit, AuthState>(
        builder: (context, state) {
          return SignUpForm(
            onSignUp:
                (UserData userData, String password, File? profileImage) async {
                  context.read<AuthCubit>().emitSignUp(
                    userData: userData,
                    password: password,
                    profileImage: profileImage,
                  );
                },
          );
        },
      ),
    );
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Error'),
        content: Text(
          message.isEmpty ? 'An error occurred. Please try again.' : message,
        ),
        actions: [
          CustomTextButton(
            buttonText: 'OK',
            borderRadius: 8.r,
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }

  void _showLoadingDialog(BuildContext context) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (_) => const Center(child: CircularProgressIndicator()),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\widgets\sign_up_form.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/utils/app_assets.dart';
import '../../../../core/models/user_data.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/regex.dart';
import '../../../../core/utils/spacing.dart';
import 'app_text_form_field.dart';
import 'upload_image_field.dart';

class SignUpForm extends StatefulWidget {
  final void Function(UserData userData, String password, File? profileImage)
  onSignUp;
  final bool isLoading;

  const SignUpForm({super.key, required this.onSignUp, this.isLoading = false});

  @override
  State<SignUpForm> createState() => _SignUpFormState();
}

class _SignUpFormState extends State<SignUpForm> {
  final _formKey = GlobalKey<FormState>();

  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _ageController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  File? _profileImage;

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _ageController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  void _setProfileImage(File? image) {
    setState(() => _profileImage = image);
  }

  void _submit() {
    if (!_formKey.currentState!.validate()) return;

    final password = _passwordController.text.trim();
    final confirmPassword = _confirmPasswordController.text.trim();

    if (password != confirmPassword) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('Passwords do not match')));
      return;
    }

    final userData = UserData(
      name: _nameController.text.trim(),
      email: _emailController.text.trim(),
      phoneNumber: _phoneController.text.trim(),
      age: int.tryParse(_ageController.text.trim()) ?? 0,
      profileImageUrl: null,
    );

    widget.onSignUp(userData, password, _profileImage);
  }

  bool _isPasswordVisible = false;
  bool _isConfirmPasswordVisible = false;
  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        children: [
          // Upload Profile Image
          Center(
            child: Column(
              children: [
                UploadImageField(onImageSelected: _setProfileImage),
                if (_profileImage != null)
                  Padding(
                    padding: EdgeInsets.only(top: 8.h),
                    child: Text(
                      "Profile image selected",
                      style: TajawalTextStyles.greyRegular14.copyWith(
                        color: Colors.greenAccent,
                      ),
                    ),
                  ),
              ],
            ),
          ),

          verticalSpacing(24.h),
          const Divider(color: Colors.white24, thickness: 1),
          verticalSpacing(16.h),

          // Name Field
          AppTextFormField(
            controller: _nameController,
            hintText: 'Full Name',
            validator: (v) =>
                (v == null || v.trim().isEmpty) ? 'Name is required' : null,
            keyboardType: TextInputType.name,
          ),
          verticalSpacing(16.h),

          // Email Field
          AppTextFormField(
            controller: _emailController,
            hintText: 'Email Address',
            validator: _validateEmail,
            keyboardType: TextInputType.emailAddress,
          ),
          verticalSpacing(16.h),

          // Phone Field
          AppTextFormField(
            controller: _phoneController,
            hintText: 'Phone Number',
            validator: (v) => (v == null || v.trim().isEmpty)
                ? 'Phone number is required'
                : null,
            keyboardType: TextInputType.phone,
          ),
          verticalSpacing(16.h),

          // Age Field
          AppTextFormField(
            controller: _ageController,
            hintText: 'Age',
            validator: (v) {
              if (v == null || v.trim().isEmpty) return 'Age is required';
              final age = int.tryParse(v.trim());
              if (age == null || age < 10) return 'Enter a valid age (10+)';
              return null;
            },
            keyboardType: TextInputType.number,
          ),
          verticalSpacing(16.h),

          // Password Field
          AppTextFormField(
            controller: _passwordController,
            hintText: 'Password',
            isObscureText: !_isPasswordVisible,
            validator: _validatePassword,
            keyboardType: TextInputType.visiblePassword,
            suffixIcon: IconButton(
              icon: Icon(
                _isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                color: _isPasswordVisible ? Colors.red : Colors.grey,
              ),
              onPressed: () {
                setState(() {
                  _isPasswordVisible = !_isPasswordVisible;
                });
              },
            ),
          ),
          verticalSpacing(16.h),

          // Confirm Password Field
          AppTextFormField(
            controller: _confirmPasswordController,
            hintText: 'Confirm Password',
            isObscureText: !_isConfirmPasswordVisible,
            validator: (_) {
              final password = _passwordController.text.trim();
              final confirmPassword = _confirmPasswordController.text.trim();
              if (password != confirmPassword) {
                return 'Passwords do not match';
              }
              return null;
            },
            suffixIcon: IconButton(
              icon: Icon(
                _isConfirmPasswordVisible
                    ? Icons.visibility
                    : Icons.visibility_off,
                color: _isConfirmPasswordVisible ? Colors.red : Colors.grey,
              ),
              onPressed: () {
                setState(() {
                  _isConfirmPasswordVisible = !_isConfirmPasswordVisible;
                });
              },
            ),
            keyboardType: TextInputType.visiblePassword,
          ),
          verticalSpacing(24.h),

          const Divider(color: Colors.white24, thickness: 1),
          verticalSpacing(8.h),

          // Submit Button
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: widget.isLoading ? null : _submit,
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.darkRedColor,
                padding: EdgeInsets.symmetric(vertical: 14.h),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12.r),
                ),
              ),
              child: widget.isLoading
                  ? const CircularProgressIndicator(color: Colors.white)
                  : Text(
                      "Create Account",
                      style: RobotoTextStyles.whiteBold18.copyWith(
                        fontFamily: AppAssets.fontRoboto,
                      ),
                    ),
            ),
          ),

          verticalSpacing(12.h),

          // Terms & Policy
          Text(
            "By signing up, you agree to our Terms of Service & Privacy Policy",
            style: TajawalTextStyles.greyRegular14,
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  String? _validateEmail(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Email is required';
    }

    if (!AppRegex.isEmailValid(value.trim())) {
      return 'Enter a valid email';
    }

    return null;
  }

  String? _validatePassword(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Password is required';
    }
    if (value.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\widgets\upload_image_field.dart =====
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/utils/functions/image_picker.dart';
import '../../../../core/utils/spacing.dart';

class UploadImageField extends StatefulWidget {
  final Function(File? image)? onImageSelected;

  const UploadImageField({super.key, this.onImageSelected});

  @override
  State<UploadImageField> createState() => _UploadImageFieldState();
}

class _UploadImageFieldState extends State<UploadImageField> {
  File? _profileImage;

  Future<void> _pickImage() async {
    try {
      final pickedImage = await ImagePickerHelper.showImageSourceActionSheet(
        context,
      );
      if (pickedImage != null) {
        setState(() {
          _profileImage = pickedImage;
        });
        widget.onImageSelected?.call(pickedImage);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to pick image. Please try again.'),
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        GestureDetector(
          onTap: _pickImage,
          child: Semantics(
            label: 'Upload profile image',
            child: Stack(
              alignment: Alignment.bottomRight,
              children: [
                CircleAvatar(
                  radius: 48.r,
                  backgroundColor: Theme.of(context).colorScheme.surface,
                  backgroundImage: _profileImage != null
                      ? FileImage(_profileImage!)
                      : null,
                  child: _profileImage == null
                      ? Icon(
                          Icons.person,
                          size: 48.r,
                          color: Theme.of(context).colorScheme.onSurface
                              .withAlpha((0.4 * 255).toInt()),
                        )
                      : null,
                ),
                Container(
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.primary,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Theme.of(context).colorScheme.surface,
                      width: 2.w,
                    ),
                  ),
                  padding: EdgeInsets.all(6.r),
                  child: Icon(
                    Icons.edit,
                    color: Theme.of(context).colorScheme.onPrimary,
                    size: 16.r,
                  ),
                ),
              ],
            ),
          ),
        ),
        verticalSpacing(12),

        // Subtle secondary button
        TextButton.icon(
          onPressed: _pickImage,
          style: TextButton.styleFrom(
            foregroundColor: Colors.blueAccent,
            padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 8.h),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(20.r),
            ),
          ),
          icon: const Icon(Icons.upload, size: 18),
          label: const Text(
            'Upload Profile Image',
            style: TextStyle(fontWeight: FontWeight.w500),
          ),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\login_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';

import '../../../core/router/route_paths.dart';
import '../../../core/themes/app_texts_style.dart';
import '../../../core/utils/spacing.dart';
import '../../../core/widgets/gradient_background.dart';
import '../../../core/widgets/logo_top_bar.dart';
import 'widgets/login_bloc_consumer.dart';

class LoginScreen extends StatelessWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GradientBackground(
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 16.h),
            child: SingleChildScrollView(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const LogoTopBar(),
                  verticalSpacing(40.h),
                  Text(
                    'Welcome Back! ðŸ‘‹',
                    style: BebasTextStyles.whiteBold24,
                    textAlign: TextAlign.center,
                  ),
                  verticalSpacing(32),
                  const LoginBlocConsumer(),
                  verticalSpacing(24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        "Don't have an account?",
                        style: RobotoTextStyles.greyRegular16,
                      ),

                      TextButton(
                        onPressed: () => context.go(Routes.signUpScreen),
                        style: TextButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 6.w),
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          overlayColor: Colors.white12,
                        ),
                        child: Text(
                          "Sign Up",
                          style: RobotoTextStyles.greyRegular16.copyWith(
                            color: Colors.blueAccent,
                            fontWeight: FontWeight.bold,
                            decorationThickness: 1.8,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\auth\ui\sign_up_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';
import 'widgets/sign_up_bloc_consumer.dart';
import '../../../core/themes/app_texts_style.dart';
import '../../../core/widgets/gradient_background.dart';
import '../../../core/widgets/logo_top_bar.dart';
import '../../../core/utils/spacing.dart';
import '../../../core/router/route_paths.dart';

class SignUpScreen extends StatelessWidget {
  const SignUpScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GradientBackground(
        child: SafeArea(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 8.h),
            child: SingleChildScrollView(
              child: Column(
                children: [
                  const LogoTopBar(),
                  verticalSpacing(40.h),
                  Text(
                    'Welcome to IM Legends! ðŸ‘‹',
                    style: RobotoTextStyles.whiteBold20,
                    semanticsLabel: 'Sign Up to IM Legends',
                  ),
                  verticalSpacing(32),
                  const SignUpBlocConsumer(),
                  verticalSpacing(8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        "Already have an account?",
                        style: RobotoTextStyles.greyRegular16,
                      ),

                      TextButton(
                        onPressed: () => context.go(Routes.loginScreen),
                        style: TextButton.styleFrom(
                          padding: EdgeInsets.symmetric(horizontal: 6.w),
                          minimumSize: Size.zero,
                          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          overlayColor: Colors.white12,
                        ),
                        child: Text(
                          "Log In",
                          style: RobotoTextStyles.greyRegular16.copyWith(
                            color: Colors.blueAccent,
                            fontWeight: FontWeight.bold,
                            decorationThickness: 1.8,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\data\model\champion_player_model.dart =====
import '../../../../core/models/players_states_model.dart';
import '../../../../core/models/user_data.dart';

class ChampionPlayerModel {
  final UserData user;
  final PlayerStatsModel stats;


  ChampionPlayerModel({
    required this.user,
    required this.stats,
  });

  ChampionPlayerModel copyWith({
    UserData? user,
    PlayerStatsModel? stats,
    int? rank,
  }) {
    return ChampionPlayerModel(
      user: user ?? this.user,
      stats: stats ?? this.stats,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\data\repo\champion_repo.dart =====
import '../../../../core/models/players_states_model.dart';
import '../../../../core/models/user_data.dart';
import '../model/champion_player_model.dart';
import '../service/champion_service.dart';

class ChampionRepo {
  final ChampionService _championService;

  ChampionRepo({required ChampionService championService})
    : _championService = championService;

  /// Computes the Top 3 players based on matches and user stats
  Future<List<ChampionPlayerModel>> getTopThree() async {
    try {
      // Fetch raw data from Supabase
      final matches = await _championService.getMatches();
      final users = await _championService.getUsers();

      if (users.isEmpty) throw Exception('No users found');
      if (matches.isEmpty) throw Exception('No matches found');

      // Initialize stats for each user
      final Map<String, PlayerStatsModel> statsMap = {
        for (var u in users)
          u['id']: PlayerStatsModel(
            playerId: u['id'],
            playerName: u['name'],
            profileImage: u['profile_image'],
          ),
      };

      // --- Calculate stats from match results ---
      for (var match in matches) {
        final winnerId = match['winner_id'] as String;
        final loserId = match['loser_id'] as String;
        final winnerScore = match['winner_score'] as int;
        final loserScore = match['loser_score'] as int;

        final winner = statsMap[winnerId];
        final loser = statsMap[loserId];

        if (winner == null || loser == null) continue;

        //  Update winner
        statsMap[winnerId] = winner.copyWith(
          matchesPlayed: winner.matchesPlayed + 1,
          wins: winner.wins + 1,
          goalsScored: winner.goalsScored + winnerScore,
          goalsReceived: winner.goalsReceived + loserScore,
          goalDifference:
              (winner.goalsScored + winnerScore) -
              (winner.goalsReceived + loserScore),
          points: winner.points + 3,
        );

        //  Update loser
        statsMap[loserId] = loser.copyWith(
          matchesPlayed: loser.matchesPlayed + 1,
          losses: loser.losses + 1,
          goalsScored: loser.goalsScored + loserScore,
          goalsReceived: loser.goalsReceived + winnerScore,
          goalDifference:
              (loser.goalsScored + loserScore) -
              (loser.goalsReceived + winnerScore),
        );
      }

      // --- Sort leaderboard by football ranking logic ---
      final sorted = statsMap.values.toList()
        ..sort((a, b) {
          if (b.points != a.points) {
            return b.points.compareTo(a.points);
          } else if (b.goalDifference != a.goalDifference) {
            return b.goalDifference.compareTo(a.goalDifference);
          } else {
            return b.goalsScored.compareTo(a.goalsScored);
          }
        });

      // --- Build Top 3 players ---
      final topThree = <ChampionPlayerModel>[];
      for (int i = 0; i < sorted.length && i < 3; i++) {
        final stat = sorted[i];
        final userMap = users.firstWhere(
          (u) => u['id'] == stat.playerId,
          orElse: () => {},
        );

        if (userMap.isEmpty) continue;

        final user = UserData(
          name: userMap['name'] ?? '',
          email: '', // Not needed for champion screen
          phoneNumber: '',
          age: 0,
          profileImageUrl: userMap['profile_image'],
        );

        topThree.add(
          ChampionPlayerModel(
            user: user,
            stats: stat.copyWith(rank: i + 1),
          ),
        );
      }

      return topThree;
    } catch (e) {
      throw Exception('ChampionRepo Error: $e');
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\data\service\champion_service.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';

class ChampionService {
  final SupabaseClient _supabase;

  ChampionService({SupabaseClient? client})
    : _supabase = client ?? Supabase.instance.client;

  /// Fetch all matches from Supabase
  Future<List<Map<String, dynamic>>> getMatches() async {
    try {
      final response = await _supabase.from('matches').select('*');
      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      throw Exception('Failed to fetch matches: $e');
    }
  }

  /// Fetch all users (limited fields)
  Future<List<Map<String, dynamic>>> getUsers() async {
    try {
      final response = await _supabase
          .from('users')
          .select('id, name, profile_image');
      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      throw Exception('Failed to fetch users: $e');
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\logic\cubit\champion_cubit.dart =====
import 'package:bloc/bloc.dart';
import 'package:meta/meta.dart';

import '../../data/model/champion_player_model.dart';
import '../../data/repo/champion_repo.dart';

part 'champion_state.dart';

class ChampionCubit extends Cubit<ChampionState> {
  final ChampionRepo repository;

  ChampionCubit({required this.repository}) : super(ChampionInitial());

  /// Fetch only the Top 3 champions
  Future<void> fetchTopThree() async {
    emit(ChampionLoading());
    try {
      final players = await repository.getTopThree();

      if (players.isEmpty) {
        emit(ChampionFailure("âš ï¸ No champions found"));
      } else {
        emit(ChampionSuccess(players));
      }
    } catch (e) {
      emit(ChampionFailure("âŒ Failed to fetch champions: $e"));
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\logic\cubit\champion_state.dart =====
part of 'champion_cubit.dart';

@immutable
sealed class ChampionState {}

final class ChampionInitial extends ChampionState {}

final class ChampionLoading extends ChampionState {}

final class ChampionSuccess extends ChampionState {
  final List<ChampionPlayerModel> players;

  ChampionSuccess(this.players);
}

final class ChampionFailure extends ChampionState {
  final String errorMessage;

  ChampionFailure(this.errorMessage);
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\widgets\champions_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../data/model/champion_player_model.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/app_assets.dart';
import '../../../../core/utils/functions/get_rank_color.dart';

class ChampionsCard extends StatelessWidget {
  final ChampionPlayerModel champion;
  late final int rank;
  late final bool isFirst;
  late final bool isSecond;

  ChampionsCard({super.key, required this.champion}) {
    rank = champion.stats.rank ?? 0;
    isFirst = rank == 1;
    isSecond = rank == 2;
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Stack(
          alignment: Alignment.bottomRight,
          children: [
            Container(
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: getRankColor(
                    isFirst
                        ? 1
                        : isSecond
                        ? 2
                        : 3,
                  ),
                  width: isFirst ? 4.w : 3.w,
                ),
              ),
              child: CircleAvatar(
                radius: isFirst ? 50.r : 40.r,
                backgroundColor: Colors.transparent,
                child: CircleAvatar(
                  radius: isFirst ? 46.r : 36.r,
                  backgroundImage: champion.user.profileImageUrl != null
                      ? NetworkImage(champion.user.profileImageUrl!)
                      : const AssetImage(AppAssets.appLogoPng) as ImageProvider,
                ),
              ),
            ),
            Container(
              padding: EdgeInsets.all(isFirst ? 6.w : 4.w),
              decoration: BoxDecoration(
                color: getRankColor(
                  isFirst
                      ? 1
                      : isSecond
                      ? 2
                      : 3,
                ),
                shape: BoxShape.circle,
                border: Border.all(
                  color: Colors.white.withAlpha((0.3 * 255).toInt()),
                  width: 1.w,
                ),
              ),
              child: Text('#$rank', style: BebasTextStyles.whiteBold14),
            ),
          ],
        ),
        SizedBox(height: 8.h),
        Text(
          champion.user.name,
          textAlign: TextAlign.center,
          style: TextStyle(
            fontSize: isFirst ? 18.sp : 16.sp,
            fontWeight: FontWeight.bold,
            color: getRankColor(
              isFirst
                  ? 1
                  : isSecond
                  ? 2
                  : 3,
            ),
          ),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\widgets\champion_header.dart =====
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/utils/spacing.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/app_assets.dart';

class ChampionHeader extends StatelessWidget {
  final String name;
  final String? imageUrl;

  const ChampionHeader({super.key, required this.name, required this.imageUrl});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      height: 280.h,
      decoration: BoxDecoration(
        image: const DecorationImage(
          image: AssetImage(AppAssets.championBannerjpg),
          fit: BoxFit.cover,
          opacity: 0.9,
        ),
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(16.r),
          bottomRight: Radius.circular(16.r),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.2 * 255).toInt()),
            blurRadius: 6.r,
            offset: Offset(0, 3.h),
          ),
        ],
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Champion Image with Trophy Overlay
          Stack(
            alignment: Alignment.bottomRight,
            children: [
              Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  border: Border.all(color: AppColors.goldColor, width: 3.w),
                  boxShadow: [
                    BoxShadow(
                      color: AppColors.goldColor,
                      blurRadius: 8.r,
                      spreadRadius: 2.r,
                    ),
                  ],
                ),
                child: CircleAvatar(
                  radius: 80.r,
                  child: CircleAvatar(
                    radius: 150.r,
                    backgroundImage: imageUrl != null
                        ? CachedNetworkImageProvider(imageUrl!)
                        : const AssetImage(AppAssets.appLogoPng),
                  ),
                ),
              ),
              Container(
                padding: EdgeInsets.all(4.w),
                decoration: const BoxDecoration(
                  color: AppColors.goldColor,
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  Icons.emoji_events,
                  size: 18.sp,
                  color: Colors.white,
                ),
              ),
            ],
          ),
          verticalSpacing(8),
          Text(
            name,
            style: BebasTextStyles.whiteBold14.copyWith(fontSize: 32.sp),
          ),
          verticalSpacing(8),
          Text(
            'Champion',
            style: RobotoTextStyles.whiteBold20.copyWith(
              wordSpacing: 2,
              fontSize: 26.sp,
              color: Colors.white.withAlpha((0.8 * 255).toInt()),
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\widgets\champion_shimmer_loading.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:shimmer/shimmer.dart';

import '../../../../core/themes/app_colors.dart';

class ChampionShimmer extends StatelessWidget {
  const ChampionShimmer({super.key});

  @override
  Widget build(BuildContext context) {
    return Shimmer.fromColors(
      baseColor: Colors.grey.shade800,
      highlightColor: Colors.grey.shade500,
      child: SingleChildScrollView(
        physics: const NeverScrollableScrollPhysics(),
        child: Column(
          children: [
            // Header shimmer
            Container(
              height: 280.h,
              width: double.infinity,
              decoration: BoxDecoration(
                color: AppColors.darkRedColor.withAlpha((0.5 * 255).toInt()),
                borderRadius: BorderRadius.only(
                  bottomLeft: Radius.circular(16.r),
                  bottomRight: Radius.circular(16.r),
                ),
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircleAvatar(
                    radius: 50,
                    backgroundColor: Colors.white12,
                  ),
                  const SizedBox(height: 16),
                  Container(),
                ],
              ),
            ),
            SizedBox(height: 20.h),
            // Stats shimmer
            Container(
              margin: EdgeInsets.symmetric(horizontal: 12.w),
              padding: EdgeInsets.all(16.w),
              decoration: BoxDecoration(
                color: Colors.black.withAlpha((0.6 * 255).toInt()),
                borderRadius: BorderRadius.circular(16.r),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: List.generate(
                  4,
                  (index) => Column(
                    children: [
                      Container(
                        height: 24.h,
                        width: 24.h,
                        decoration: const BoxDecoration(
                          color: Colors.white12,
                          shape: BoxShape.circle,
                        ),
                      ),
                      SizedBox(height: 8.h),
                      Container(
                        height: 12.h,
                        width: 40.w,
                        color: Colors.white24,
                      ),
                      SizedBox(height: 4.h),
                      Container(
                        height: 8.h,
                        width: 30.w,
                        color: Colors.white10,
                      ),
                    ],
                  ),
                ),
              ),
            ),
            SizedBox(height: 24.h),
            // Top 3 shimmer
            Container(
              margin: EdgeInsets.symmetric(horizontal: 12.w),
              padding: EdgeInsets.symmetric(vertical: 16.h),
              decoration: BoxDecoration(
                color: Colors.black.withAlpha((0.6 * 255).toInt()),
                borderRadius: BorderRadius.circular(16.r),
              ),
              child: Column(
                children: [
                  Container(height: 20.h, width: 80.w, color: Colors.white24),
                  SizedBox(height: 32.h),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: List.generate(
                      3,
                      (index) => Container(
                        height: index == 1 ? 140.h : 120.h,
                        width: 100.w,
                        decoration: BoxDecoration(
                          color: Colors.white10,
                          borderRadius: BorderRadius.circular(16.r),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\widgets\champion_states.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import 'champion_state_item.dart';

class ChampionStats extends StatelessWidget {
  final int goals;
  final int points;
  final int wins;
  final int matches;

  const ChampionStats({
    super.key,
    required this.goals,
    required this.points,
    required this.wins,
    required this.matches,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.symmetric(vertical: 16.h, horizontal: 12.w),
      padding: EdgeInsets.only(top: 16.h, bottom: 8.h),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [
            Colors.black.withAlpha((0.3 * 255).toInt()),
            Colors.black.withAlpha((0.9 * 255).toInt()),
            Colors.black.withAlpha((0.9 * 255).toInt()),
            Colors.black.withAlpha((0.9 * 255).toInt()),
            AppColors.darkRedColor.withAlpha((0.9 * 255).toInt()),
            // const Color(0xFF020D8C).withAlpha((0.9 * 255).toInt()),
          ],
        ),
        borderRadius: BorderRadius.circular(16.r),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.3 * 255).toInt()),
            blurRadius: 8.r,
            offset: Offset(0, 4.h),
          ),
        ],
        border: Border.all(
          color: Colors.white.withAlpha((0.3 * 255).toInt()),
          width: 1.w,
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: [
          ChampionStateItem(
            label: 'Matches',
            value: matches,
            icon: Icons.sports_esports,
          ),
          ChampionStateItem(
            label: 'Wins',
            value: wins,
            icon: Icons.emoji_events,
          ),
          ChampionStateItem(label: 'Points', value: points, icon: Icons.star),
          ChampionStateItem(
            label: 'Goals',
            value: goals,
            icon: Icons.sports_soccer,
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\widgets\champion_state_item.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/app_texts_style.dart';

class ChampionStateItem extends StatelessWidget {
  const ChampionStateItem({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
  });
  final String label;
  final int value;
  final IconData icon;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          padding: EdgeInsets.all(8.w),
          decoration: const BoxDecoration(
            shape: BoxShape.circle,
            color: AppColors.darkRedColor,
          ),
          child: Icon(icon, size: 24.sp, color: Colors.white),
        ),
        SizedBox(height: 8.h),
        Text('$value', style: RobotoTextStyles.whiteBold24),
        SizedBox(height: 4.h),
        Text(label, style: BebasTextStyles.whiteBold14),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\widgets\champion_top_three.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import '../../data/model/champion_player_model.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/spacing.dart';
import 'champions_card.dart';

class ChampionTopThree extends StatelessWidget {
  final List<ChampionPlayerModel> topThree;
  const ChampionTopThree({super.key, required this.topThree});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.symmetric(vertical: 8.h, horizontal: 12.w),
      padding: EdgeInsets.only(top: 16.h, bottom: 8.h),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [
            Colors.black.withAlpha((0.3 * 255).toInt()),
            Colors.black.withAlpha((0.3 * 255).toInt()),
            Colors.black.withAlpha((0.9 * 255).toInt()),
            Colors.black.withAlpha((0.9 * 255).toInt()),
            Colors.black.withAlpha((0.9 * 255).toInt()),
            AppColors.darkRedColor.withAlpha((0.9 * 255).toInt()),
          ],
        ),
        borderRadius: BorderRadius.circular(16.r),

        border: Border.all(
          color: Colors.white.withAlpha((0.2 * 255).toInt()),
          width: 1.w,
        ),
      ),
      child: Column(
        children: [
          Text('Top 3 ', style: BebasTextStyles.whiteBold24),
          verticalSpacing(32),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              // Second place (left)
              Flexible(child: ChampionsCard(champion: topThree[1])),
              // First place (center, elevated)
              Flexible(
                child: Transform.translate(
                  offset: Offset(0, -20.h),
                  child: ChampionsCard(champion: topThree[0]),
                ),
              ),
              // Third place (right)
              Flexible(child: ChampionsCard(champion: topThree[2])),
            ],
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\champion\ui\champion_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../core/themes/app_colors.dart';
import '../../../core/utils/functions/refresh_page.dart';
import '../../../core/widgets/custom_app_bar.dart';
import '../logic/cubit/champion_cubit.dart';
import 'widgets/champion_header.dart';
import 'widgets/champion_shimmer_loading.dart';
import 'widgets/champion_states.dart';
import 'widgets/champion_top_three.dart';

class ChampionScreen extends StatelessWidget {
  const ChampionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          const CustomAppBar(title: 'Champions'),
          Expanded(
            child: BlocBuilder<ChampionCubit, ChampionState>(
              builder: (context, state) {
                if (state is ChampionLoading) {
                  return const ChampionShimmer();
                } else if (state is ChampionSuccess) {
                  final champion = state.players[0];
                  final topThree = state.players;
                  return RefreshIndicator(
                    onRefresh: () => onRefresh(context),
                    backgroundColor: AppColors.lightDarkColor,
                    color: Colors.white,
                    child: SingleChildScrollView(
                      physics: const AlwaysScrollableScrollPhysics(),
                      child: Column(
                        children: [
                          ChampionHeader(
                            name: champion.user.name,
                            imageUrl: champion.user.profileImageUrl,
                          ),
                          ChampionStats(
                            goals: champion.stats.goalDifference,
                            points: champion.stats.points,
                            wins: champion.stats.wins,
                            matches: champion.stats.matchesPlayed,
                          ),
                          ChampionTopThree(topThree: topThree),
                        ],
                      ),
                    ),
                  );
                } else if (state is ChampionFailure) {
                  return Center(child: Text(state.errorMessage));
                }
                return const SizedBox.shrink();
              },
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\data\models\match_history_card_model.dart =====
class MatchHistoryCardModel {
  final String matchId;
  final String winnerName;
  final String loserName;
  final String winnerImage;
  final String loserImage;
  final int winnerScore;
  final int loserScore;
  final DateTime matchDate;

  MatchHistoryCardModel({
    required this.matchId,
    required this.winnerName,
    required this.loserName,
    required this.winnerImage,
    required this.loserImage,
    required this.winnerScore,
    required this.loserScore,
    required this.matchDate,
  });

  factory MatchHistoryCardModel.fromJson(Map<String, dynamic> json) {
    return MatchHistoryCardModel(
      matchId: json['id'] as String,
      winnerName: json['winner']['name'] as String,
      loserName: json['loser']['name'] as String,
      winnerImage: json['winner']['profile_image'] as String? ?? '',
      loserImage: json['loser']['profile_image'] as String? ?? '',
      winnerScore: (json['winner_score'] as num).toInt(),
      loserScore: (json['loser_score'] as num).toInt(),
      matchDate: DateTime.parse(json['created_at'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': matchId,
      'winner_name': winnerName,
      'loser_name': loserName,
      'winner_image': winnerImage,
      'loser_image': loserImage,
      'winner_score': winnerScore,
      'loser_score': loserScore,
      'match_date': matchDate.toIso8601String(),
    };
  }

  MatchHistoryCardModel copyWith({
    String? matchId,
    String? winnerName,
    String? loserName,
    String? winnerImage,
    String? loserImage,
    int? winnerScore,
    int? loserScore,
    DateTime? matchDate,
  }) {
    return MatchHistoryCardModel(
      matchId: matchId ?? this.matchId,
      winnerName: winnerName ?? this.winnerName,
      loserName: loserName ?? this.loserName,
      winnerImage: winnerImage ?? this.winnerImage,
      loserImage: loserImage ?? this.loserImage,
      winnerScore: winnerScore ?? this.winnerScore,
      loserScore: loserScore ?? this.loserScore,
      matchDate: matchDate ?? this.matchDate,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\data\repo\history_repo.dart =====
import '../models/match_history_card_model.dart';
import '../service/history_service.dart';

class HistoryRepo {
  final HistoryService historyService = HistoryService();

  Future<List<MatchHistoryCardModel>> fetchMatches() async {
    final matches = await historyService.fetchMatches();

    return matches.map((match) {
      return MatchHistoryCardModel(
        matchId: match['id'] as String,
        winnerName: match['winner']['name'] as String,
        loserName: match['loser']['name'] as String,
        winnerImage: match['winner']['profile_image'] as String? ?? '',
        loserImage: match['loser']['profile_image'] as String? ?? '',
        winnerScore: (match['winner_score'] as num).toInt(), // int
        loserScore: (match['loser_score'] as num).toInt(), //  int
        matchDate: DateTime.parse(match['created_at'] as String), //  DateTime
      );
    }).toList();
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\data\service\history_service.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';

class HistoryService {
  final SupabaseClient supabase = Supabase.instance.client;

  /// Fetch matches with winner and loser info joined
  Future<List<Map<String, dynamic>>> fetchMatches() async {
    try {
      final response = await supabase
          .from('matches')
          .select('''
            id,
            winner_score,
            loser_score,
            created_at,
            winner:users!matches_winner_fkey (
              id,
              name,
              profile_image
            ),
            loser:users!matches_loser_fkey (
              id,
              name,
              profile_image
            )
          ''')
          .order('created_at', ascending: false);

      // Supabase returns dynamic â†’ cast it properly
      if (response.isNotEmpty) {
        return response.cast<Map<String, dynamic>>();
      }

      return [];
    } catch (e) {
      // Log error if needed
      print('Error fetching matches: $e');
      return [];
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\logic\cubit\match_history_cubit.dart =====
import 'package:bloc/bloc.dart';
import '../../data/models/match_history_card_model.dart';
import '../../data/repo/history_repo.dart';
import 'package:meta/meta.dart';

part 'match_history_state.dart';

class MatchHistoryCubit extends Cubit<MatchHistoryState> {
  MatchHistoryCubit() : super(MatchHistoryInitial());

  Future<void> getMatchHistory() async {
    emit(MatchHistoryLoading());
    try {
      final matches = await HistoryRepo().fetchMatches();
      emit(MatchHistorySuccess(matches: matches));
    } catch (e) {
      emit(MatchHistoryError(errorMessage: e.toString()));
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\logic\cubit\match_history_state.dart =====
part of 'match_history_cubit.dart';

@immutable
sealed class MatchHistoryState {}

final class MatchHistoryInitial extends MatchHistoryState {}

final class MatchHistoryLoading extends MatchHistoryState {}

final class MatchHistorySuccess extends MatchHistoryState {
  final List<MatchHistoryCardModel> matches;
  MatchHistorySuccess({required this.matches});
}

final class MatchHistoryError extends MatchHistoryState {
  final String errorMessage;
  MatchHistoryError({required this.errorMessage});
}
===== C:\flutter_apps\im_legends\lib\features\history\ui\widgets\history_card_player_info.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/text_styles/bebas_text_styles.dart';
import '../../../../core/utils/spacing.dart';
import '../../../../core/themes/app_colors.dart';

class HistoryCardPlayerInfo extends StatelessWidget {
  final String playerName;
  final String? avatarUrl;
  final bool isWinner;

  const HistoryCardPlayerInfo({
    super.key,
    required this.playerName,
    this.avatarUrl,
    required this.isWinner,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    final nameColor = isWinner
        ? AppColors.winColor
        : theme.brightness == Brightness.dark
        ? Colors.grey.shade300
        : AppColors.loseColor;

    final avatarBgColor = isWinner ? AppColors.winColor : AppColors.loseColor;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Avatar with soft glow
        Container(
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                color: isWinner ? AppColors.winColor : Colors.black,
                blurRadius: isWinner ? 14.r : 8.r,
                spreadRadius: isWinner ? 2.r : 1.r,
              ),
            ],
          ),
          child: CircleAvatar(
            radius: 28.r,
            backgroundColor: avatarBgColor,
            backgroundImage: avatarUrl != null && avatarUrl!.isNotEmpty
                ? NetworkImage(avatarUrl!)
                : null,
            child: (avatarUrl == null || avatarUrl!.isEmpty)
                ? Icon(Icons.person, size: 24.sp, color: nameColor)
                : null,
          ),
        ),
        verticalSpacing(10),
        SizedBox(
          width: 80.w,
          child: Text(
            playerName,
            style: BebasTextStyles.whiteBold14.copyWith(color: nameColor),
            textAlign: TextAlign.center,
            softWrap: true,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\ui\widgets\history_list_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/themes/app_colors.dart';
import '../../../../core/utils/spacing.dart';
import '../../data/models/match_history_card_model.dart';
import 'history_card_player_info.dart';
import 'match_card_header.dart';
import 'score_display.dart';

class HistoryListCard extends StatelessWidget {
  final MatchHistoryCardModel match;

  const HistoryListCard({super.key, required this.match});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      margin: EdgeInsets.symmetric(horizontal: 16.w, vertical: 8.h),
      padding: EdgeInsets.all(16.w),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16.r),
        color: AppColors.darkColor,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.5 * 255).toInt()),
            blurRadius: 12.r,
            offset: Offset(0, 6.h),
          ),
        ],
        border: Border.all(color: Colors.white.withAlpha((0.5 * 255).toInt())),
      ),
      child: Column(
        children: [
          MatchCardHeader(matchDate: match.matchDate),
          verticalSpacing(20),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              HistoryCardPlayerInfo(
                playerName: match.winnerName,
                avatarUrl: match.winnerImage,
                isWinner: true,
              ),
              ScoreDisplay(match: match),
              HistoryCardPlayerInfo(
                playerName: match.loserName,
                avatarUrl: match.loserImage,
                isWinner: false,
              ),
            ],
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\ui\widgets\history_shimmer_loading.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:shimmer/shimmer.dart';

class HistoryShimmerLoading extends StatelessWidget {
  const HistoryShimmerLoading({super.key});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 12.h),
      itemCount: 5,
      itemBuilder: (context, index) {
        return Container(
          margin: EdgeInsets.only(bottom: 16.h),
          padding: EdgeInsets.all(16.w),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(16.r),
            gradient: const LinearGradient(
              colors: [Color(0xFF1E1E1E), Color(0xFF2C2C2C)],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withAlpha((0.5 * 255).toInt()),
                blurRadius: 8.r,
                offset: Offset(0, 4.h),
              ),
            ],
          ),
          child: Shimmer.fromColors(
            baseColor: Colors.grey[800]!,
            highlightColor: Colors.grey[600]!,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  width: 120.w,
                  height: 16.h,
                  decoration: BoxDecoration(
                    color: Colors.grey[700],
                    borderRadius: BorderRadius.circular(8.r),
                  ),
                ),
                SizedBox(height: 16.h),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // Player Left
                    Column(
                      children: [
                        Container(
                          width: 50.w,
                          height: 50.w,
                          decoration: BoxDecoration(
                            shape: BoxShape.circle,
                            color: Colors.grey[700],
                          ),
                        ),
                        SizedBox(height: 8.h),
                        Container(
                          width: 60.w,
                          height: 10.h,
                          color: Colors.grey[700],
                        ),
                      ],
                    ),

                    // Score
                    Container(
                      width: 50.w,
                      height: 20.h,
                      color: Colors.grey[700],
                    ),

                    // Player Right
                    Column(
                      children: [
                        Container(
                          width: 50.w,
                          height: 50.w,
                          decoration: BoxDecoration(
                            shape: BoxShape.circle,
                            color: Colors.grey[700],
                          ),
                        ),
                        SizedBox(height: 8.h),
                        Container(
                          width: 60.w,
                          height: 10.h,
                          color: Colors.grey[700],
                        ),
                      ],
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\ui\widgets\match_card_header.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/utils/functions/date_formate.dart';

class MatchCardHeader extends StatelessWidget {
  final DateTime matchDate;

  const MatchCardHeader({super.key, required this.matchDate});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: Text(
            '${formatSmart(matchDate)}',
            style: TextStyle(
              fontSize: 12.sp,
              color: Colors.white,
              fontStyle: FontStyle.italic,
            ),
            textAlign: TextAlign.left,
          ),
        ),
        Icon(Icons.sports_soccer, color: AppColors.greyColor, size: 24.sp),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\ui\widgets\score_display.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../data/models/match_history_card_model.dart';

class ScoreDisplay extends StatelessWidget {
  final MatchHistoryCardModel match;

  const ScoreDisplay({super.key, required this.match});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Text(
          '${match.winnerScore}',
          style: RobotoTextStyles.whiteBold24.copyWith(
            color: AppColors.winColor,
          ),
        ),
        Text(
          '  -  ',
          style: TextStyle(
            fontSize: 16.sp,
            color: Colors.grey[500],
            fontWeight: FontWeight.w500,
          ),
        ),
        Text(
          '${match.loserScore}',
          style: RobotoTextStyles.whiteBold24.copyWith(
            color: AppColors.loseColor,
          ),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\history\ui\history_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../core/themes/app_colors.dart';
import '../../../core/utils/functions/refresh_page.dart';
import '../../../core/widgets/custom_app_bar.dart';
import '../logic/cubit/match_history_cubit.dart';
import 'widgets/history_list_card.dart';
import 'widgets/history_shimmer_loading.dart';

class HistoryScreen extends StatelessWidget {
  const HistoryScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          const CustomAppBar(title: 'History'),
          Expanded(
            child: BlocBuilder<MatchHistoryCubit, MatchHistoryState>(
              builder: (context, state) {
                if (state is MatchHistoryLoading) {
                  return const HistoryShimmerLoading();
                } else if (state is MatchHistorySuccess) {
                  final matches = state.matches;
                  return RefreshIndicator(
                    onRefresh: () => onRefresh(context),
                    backgroundColor: AppColors.lightDarkColor,
                    color: Colors.white,
                    child: ListView.builder(
                      padding: const EdgeInsets.all(16),
                      itemCount: matches.length,
                      itemBuilder: (context, index) =>
                          HistoryListCard(match: matches[index]),
                    ),
                  );
                } else {
                  return const Center(child: Text('No data available'));
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\data\repo\leader_board_repo.dart =====
import '../../../../core/models/players_states_model.dart';
import '../service/leader_board_service.dart';

class LeaderBoardRepo {
  final LeaderboardService _leaderboardService;

  LeaderBoardRepo({required LeaderboardService leaderboardService})
    : _leaderboardService = leaderboardService;

  Future<List<PlayerStatsModel>> calculateLeaderboard() async {
    final matches = await _leaderboardService.fetchMatches();
    final users = await _leaderboardService.fetchUsers();

    final Map<String, PlayerStatsModel> stats = {
      for (var u in users)
        u['id']: PlayerStatsModel(
          playerId: u['id'],
          playerName: u['name'],
          profileImage: u['profile_image'],
        ),
    };

    for (var match in matches) {
      final winnerId = match['winner_id'] as String;
      final loserId = match['loser_id'] as String;
      final winnerScore = match['winner_score'] as int;
      final loserScore = match['loser_score'] as int;

      final winner = stats[winnerId]!;
      final loser = stats[loserId]!;

      // --- Update Winner Stats ---
      stats[winnerId] = winner.copyWith(
        matchesPlayed: winner.matchesPlayed + 1,
        wins: winner.wins + 1,
        goalsScored: winner.goalsScored + winnerScore,
        goalsReceived: winner.goalsReceived + loserScore,
        goalDifference:
            (winner.goalsScored + winnerScore) -
            (winner.goalsReceived + loserScore),
        points: winner.points + 3,
      );

      // --- Update Loser Stats ---
      stats[loserId] = loser.copyWith(
        matchesPlayed: loser.matchesPlayed + 1,
        losses: loser.losses + 1,
        goalsScored: loser.goalsScored + loserScore,
        goalsReceived: loser.goalsReceived + winnerScore,
        goalDifference:
            (loser.goalsScored + loserScore) -
            (loser.goalsReceived + winnerScore),
      );
    }
    final leaderboard = stats.values.toList()
      ..sort((a, b) {
        if (b.points != a.points) {
          return b.points.compareTo(a.points);
        } else if (b.goalDifference != a.goalDifference) {
          return b.goalDifference.compareTo(a.goalDifference);
        } else {
          return b.goalsScored.compareTo(a.goalsScored);
        }
      });

    // Assign ranks after sorting
    for (int i = 0; i < leaderboard.length; i++) {
      leaderboard[i] = leaderboard[i].copyWith(rank: i + 1);
    }

    return leaderboard;
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\data\service\leader_board_service.dart =====
import 'package:supabase_flutter/supabase_flutter.dart';

class LeaderboardService {
  final supabase = Supabase.instance.client;

  Future<List<Map<String, dynamic>>> fetchMatches() async {
  try {
      final response = await supabase.from('matches').select('*');
      return response;
    } catch (e) {
      throw Exception('Failed to fetch matches: $e');
    }
  }

  Future<List<Map<String, dynamic>>> fetchUsers() async {
    final response = await supabase
        .from('users')
        .select('id, name, profile_image');
    return response;
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\logic\cubit\leader_board_cubit.dart =====
import 'package:bloc/bloc.dart';
import 'package:meta/meta.dart';

import '../../../../core/models/players_states_model.dart';
import '../../data/repo/leader_board_repo.dart';

part 'leader_board_state.dart';

class LeaderBoardCubit extends Cubit<LeaderBoardState> {
  final LeaderBoardRepo repo;
  LeaderBoardCubit({required this.repo}) : super(LeaderBoardInitial());

  Future<void> loadLeaderboard() async {
    emit(LeaderBoardLoading());
    try {
      final leaderboard = await repo.calculateLeaderboard();
      emit(LeaderBoardSuccess(leaderboard));
    } catch (e) {
      emit(LeaderBoardFailure('Failed to load leaderboard: ${e.toString()}'));
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\logic\cubit\leader_board_state.dart =====
part of 'leader_board_cubit.dart';

@immutable
sealed class LeaderBoardState {}

final class LeaderBoardInitial extends LeaderBoardState {}

final class LeaderBoardLoading extends LeaderBoardState {}

final class LeaderBoardSuccess extends LeaderBoardState {
  final List<PlayerStatsModel> leaderboard;
  LeaderBoardSuccess(this.leaderboard);
}

final class LeaderBoardFailure extends LeaderBoardState {
  final String message;
  LeaderBoardFailure(this.message);
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\home_header_container.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';
import '../../../../core/router/route_paths.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/text_styles/bebas_text_styles.dart';
import '../../../../core/widgets/custom_text_button.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../../core/utils/spacing.dart';
import '../../logic/cubit/leader_board_cubit.dart';

class HomeHeaderContainer extends StatelessWidget {
  const HomeHeaderContainer({super.key});

  String _getGreeting() {
    final hour = DateTime.now().hour;
    if (hour < 12) return 'Good Morning';
    if (hour < 17) return 'Good Afternoon';
    return 'Good Evening';
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4.h, horizontal: 16.w),
      child: Container(
        width: double.infinity,
        padding: EdgeInsets.only(bottom: 24.h),
        decoration: BoxDecoration(
          color: AppColors.darkColor,
          borderRadius: BorderRadius.only(
            bottomLeft: Radius.circular(24.r),
            bottomRight: Radius.circular(24.r),
          ),
          border: Border(
            bottom: BorderSide(
              color: Colors.white.withAlpha((0.1 * 255).toInt()),
              width: 1,
            ),
            left: BorderSide(
              color: Colors.white.withAlpha((0.1 * 255).toInt()),
              width: 1,
            ),
            right: BorderSide(
              color: Colors.white.withAlpha((0.1 * 255).toInt()),
              width: 1,
            ),
          ),
        ),
        child: SafeArea(
          bottom: false,
          child: BlocBuilder<LeaderBoardCubit, LeaderBoardState>(
            builder: (context, state) {
              String displayName = "Player";

              if (state is LeaderBoardSuccess) {
                final currentUserId =
                    Supabase.instance.client.auth.currentUser?.id;
                final currentPlayer = state.leaderboard.firstWhere(
                  (p) => p.playerId == currentUserId,
                  orElse: () => state.leaderboard.first,
                );
                displayName = currentPlayer.playerName;
              } else if (state is LeaderBoardFailure) {
                displayName = "Error loading user";
              }

              return Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text(
                    _getGreeting(),
                    style: TextStyle(
                      fontSize: 18.sp,
                      color: AppColors.greyColor.withAlpha((0.8 * 255).toInt()),
                      fontWeight: FontWeight.w400,
                      letterSpacing: 1.1,
                    ),
                  ),
                  verticalSpacing(6),
                  Text(
                    displayName,
                    style: BebasTextStyles.whiteBold24.copyWith(
                      fontSize: 32.sp,
                      letterSpacing: 1.1,
                    ),
                  ),
                  verticalSpacing(10),
                  Container(
                    padding: EdgeInsets.symmetric(
                      horizontal: 14.w,
                      vertical: 6.h,
                    ),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(16.r),
                      color: Colors.white.withAlpha((0.1 * 255).toInt()),
                      border: Border.all(
                        color: AppColors.greyColor.withAlpha(
                          (0.2 * 255).toInt(),
                        ),
                      ),
                      boxShadow: [
                        BoxShadow(
                          color: AppColors.goldColor.withAlpha(
                            (0.2 * 255).toInt(),
                          ),
                          blurRadius: 8,
                          offset: const Offset(0, 2),
                        ),
                      ],
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.sports_esports_rounded,
                          color: AppColors.goldColor,
                          size: 18.sp,
                        ),
                        horizontalSpacing(6),
                        Text(
                          "Ready to play?",
                          style: TextStyle(
                            color: AppColors.greyColor,
                            fontSize: 13.sp,
                            fontWeight: FontWeight.w600,
                            letterSpacing: 0.5,
                          ),
                        ),
                      ],
                    ),
                  ),
                  verticalSpacing(16),
                  SizedBox(
                    width: 250.w,
                    child: CustomTextButton(
                      buttonText: 'Add Match',
                      textStyle: BebasTextStyles.whiteBold24,
                      onPressed: () {
                        context.push(Routes.addMatchScreen);
                      },
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\leader_board_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/models/players_states_model.dart';
import '../../../../core/themes/app_colors.dart';
import 'player_info.dart';
import 'rank_and_avatar.dart';
import 'states_section.dart';
import '../../../../core/utils/spacing.dart';

class LeaderBoardCard extends StatelessWidget {
  final PlayerStatsModel player;
  final bool isCurrentUser;

  const LeaderBoardCard({
    super.key,
    this.isCurrentUser = false,
    required this.player,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4.h, horizontal: 16.w),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 300),
        padding: EdgeInsets.symmetric(horizontal: 8.w, vertical: 12.h),
        height: 80.h,
        width: double.infinity,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16.r),
          color: isCurrentUser
              ? AppColors.lightDarkColor
              : const Color(0xFF1E2128),
          border: isCurrentUser
              ? Border.all(color: AppColors.darkRedColor, width: 1)
              : null,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha((0.2 * 255).toInt()),
              blurRadius: 8,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Row(
          children: [
            RankAndAvatar(
              isCurrentUser: isCurrentUser,
              rank: player.rank,
              imageUrl: player.profileImage,
            ),
            horizontalSpacing(12),
            Expanded(
              flex: 2,
              child: PlayerInfo(
                playerName: player.playerName,
                points: player.points,
              ),
            ),

            // Stats Section
            StatesSection(
              Match: player.matchesPlayed,
              goalDifference: player.goalDifference,
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\leader_board_list_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../../../core/themes/text_styles/bebas_text_styles.dart';
import '../../logic/cubit/leader_board_cubit.dart';
import 'leader_board_card.dart';

class LeadBoardListView extends StatelessWidget {
  const LeadBoardListView({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<LeaderBoardCubit, LeaderBoardState>(
      builder: (context, state) {
        if (state is LeaderBoardFailure) {
          return Center(
            child: Text(state.message, style: BebasTextStyles.whiteBold20),
          );
        } else if (state is LeaderBoardLoading) {
          return const Center(child: CircularProgressIndicator());
        } else if (state is LeaderBoardSuccess) {
          return ListView.builder(
            padding: EdgeInsets.zero,
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: state.leaderboard.length,
            itemBuilder: (context, index) {
              final player = state.leaderboard[index];
              final currentUserId =
                  Supabase.instance.client.auth.currentUser?.id;
              player.matchesPlayed;
              return LeaderBoardCard(
                isCurrentUser: currentUserId == player.playerId,
                player: player,
              );
            },
          );
        } else {
          return const Center(child: Text('Something went wrong'));
        }
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\leader_board_shimmer_loading.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:shimmer/shimmer.dart';

class LeaderBoardShimmerLoading extends StatelessWidget {
  const LeaderBoardShimmerLoading({super.key});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: EdgeInsets.symmetric(vertical: 8.h, horizontal: 16.w),
      itemCount: 8,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemBuilder: (context, index) {
        return Padding(
          padding: EdgeInsets.symmetric(vertical: 4.h),
          child: Shimmer.fromColors(
            baseColor: Colors.grey[850]!,
            highlightColor: Colors.grey[700]!,
            child: Container(
              height: 80.h,
              decoration: BoxDecoration(
                color: const Color(0xFF1E2128),
                borderRadius: BorderRadius.circular(16.r),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withAlpha((0.2 * 255).toInt()),
                    blurRadius: 6,
                    offset: const Offset(0, 3),
                  ),
                ],
              ),
              padding: EdgeInsets.symmetric(horizontal: 12.w, vertical: 8.h),
              child: Row(
                children: [
                  // Rank Circle
                  Container(
                    width: 36.w,
                    height: 36.w,
                    decoration: BoxDecoration(
                      color: Colors.grey[800],
                      shape: BoxShape.circle,
                    ),
                  ),
                  SizedBox(width: 12.w),

                  // Avatar Circle
                  Container(
                    width: 50.w,
                    height: 50.w,
                    decoration: BoxDecoration(
                      color: Colors.grey[800],
                      shape: BoxShape.circle,
                    ),
                  ),
                  SizedBox(width: 12.w),

                  // Player Name & Points
                  Expanded(
                    flex: 2,
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Container(
                          width: 120.w,
                          height: 14.h,
                          decoration: BoxDecoration(
                            color: Colors.grey[800],
                            borderRadius: BorderRadius.circular(6.r),
                          ),
                        ),
                        SizedBox(height: 8.h),
                        Container(
                          width: 60.w,
                          height: 10.h,
                          decoration: BoxDecoration(
                            color: Colors.grey[800],
                            borderRadius: BorderRadius.circular(6.r),
                          ),
                        ),
                      ],
                    ),
                  ),

                  Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Container(
                        width: 40.w,
                        height: 10.h,
                        color: Colors.grey[800],
                      ),
                      SizedBox(height: 8.h),
                      Container(
                        width: 30.w,
                        height: 10.h,
                        color: Colors.grey[800],
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\player_info.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';

import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/spacing.dart';

class PlayerInfo extends StatelessWidget {
  const PlayerInfo({super.key, required this.playerName, required this.points});

  final String playerName;
  final int points;
  final bool isCurrentUser = false;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          playerName.toUpperCase(),
          style: TajawalTextStyles.whiteBold16,
          overflow: TextOverflow.ellipsis,
        ),
        verticalSpacing(2),
        Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Icon(Icons.star, size: 14.sp, color: AppColors.goldColor),
            horizontalSpacing(4),
            Text('$points Points', style: BebasTextStyles.greyBold14),
          ],
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\rank_and_avatar.dart =====
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/utils/app_assets.dart';
import '../../../../core/utils/functions/get_rank_color.dart';

class RankAndAvatar extends StatelessWidget {
  const RankAndAvatar({
    super.key,
    this.imageUrl,
    this.rank,
    required this.isCurrentUser,
  });

  final String? imageUrl;
  final int? rank;
  final bool isCurrentUser;

  @override
  Widget build(BuildContext context) {
    final avatarSize = isCurrentUser ? 55.w : 50.w;
    return SizedBox(
      width: isCurrentUser ? 70.w : 60.w,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          // Avatar
          Center(
            child: Container(
              width: avatarSize,
              height: avatarSize,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withAlpha((0.2 * 255).toInt()),
                    blurRadius: 4,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: CircleAvatar(
                radius: avatarSize / 2,
                backgroundColor: Colors.white,
                child: ClipOval(
                  child: SizedBox(
                    width: avatarSize,
                    height: avatarSize,
                    child: imageUrl == null || imageUrl!.isEmpty
                        ? Image.asset(AppAssets.appLogoPng, fit: BoxFit.cover)
                        : CachedNetworkImage(
                            imageUrl: imageUrl!,
                            fit: BoxFit.cover,
                            width: avatarSize,
                            height: avatarSize,
                            placeholder: (context, url) => Image.asset(
                              AppAssets.appLogoPng,
                              fit: BoxFit.cover,
                            ),
                            errorWidget: (context, url, error) => Image.asset(
                              AppAssets.appLogoPng,
                              fit: BoxFit.cover,
                            ),
                          ),
                  ),
                ),
              ),
            ),
          ),

          // Rank Badge
          if (rank != null)
            Positioned(
              top: -2,
              right: -2,
              child: Container(
                width: 20.w,
                height: 20.w,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: getRankColor(rank!),
                  border: Border.all(color: Colors.white, width: 1.5),
                ),
                child: Center(
                  child: Text(
                    '$rank',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 10.sp,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\states_column.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/spacing.dart';

class StatesColumn extends StatelessWidget {
  const StatesColumn({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
  });
  final String label;
  final int value;
  final IconData icon;
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 16.sp, color: AppColors.goldColor),
            horizontalSpacing(4),
            Text(
              '$value',
              style: BebasTextStyles.whiteBold14,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
        verticalSpacing(2),
        Text(label, style: RobotoTextStyles.greyRegular12),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\widgets\states_section.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/utils/spacing.dart';
import 'states_column.dart';

class StatesSection extends StatelessWidget {
  const StatesSection({
    super.key,
    required this.Match,
    required this.goalDifference,
  });
  final int Match;
  final int goalDifference;
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 12.w, vertical: 8.h),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12.r),
        color: Colors.black.withAlpha((0.2 * 255).toInt()),
      ),
      child: Row(
        children: [
          StatesColumn(
            label: 'Matches',
            value: Match,
            icon: Icons.sports_esports,
          ),
          horizontalSpacing(8),
          StatesColumn(
            label: 'Goals',
            value: goalDifference,
            icon: Icons.sports_soccer,
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\home\ui\home_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../core/themes/app_colors.dart';
import '../../../core/utils/functions/refresh_page.dart';
import '../../../core/utils/spacing.dart';
import '../logic/cubit/leader_board_cubit.dart';
import '../../../core/widgets/custom_app_bar.dart';
import 'widgets/home_header_container.dart';
import 'widgets/leader_board_list_view.dart';
import 'widgets/leader_board_shimmer_loading.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.darkColor,
      body: Column(
        children: [
          const CustomAppBar(title: 'Leaderboard'),

          Expanded(
            child: RefreshIndicator(
              onRefresh: () => onRefresh(context),
              backgroundColor: AppColors.lightDarkColor,
              color: Colors.white,
              child: SingleChildScrollView(
                physics: const AlwaysScrollableScrollPhysics(),
                child: Padding(
                  padding: const EdgeInsets.only(bottom: 24),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const HomeHeaderContainer(),
                      verticalSpacing(16),

                      // --- Leaderboard Section
                      BlocBuilder<LeaderBoardCubit, LeaderBoardState>(
                        builder: (context, state) {
                          if (state is LeaderBoardLoading) {
                            return const LeaderBoardShimmerLoading();
                          } else if (state is LeaderBoardSuccess) {
                            return const LeadBoardListView();
                          } else if (state is LeaderBoardFailure) {
                            return Center(
                              child: Padding(
                                padding: const EdgeInsets.all(24.0),
                                child: Text(
                                  state.message,
                                  style: const TextStyle(color: Colors.white),
                                ),
                              ),
                            );
                          } else {
                            return const SizedBox.shrink();
                          }
                        },
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\data\models\notification_model.dart =====
import 'dart:convert';

import 'package:uuid/uuid.dart';

enum NotificationType { welcome, update, security, promotion, system }

class NotificationModel {
  final String id;
  final String userId;
  final String title;
  final String message;
  final DateTime time;
  bool isRead;
  final NotificationType type;

  NotificationModel({
    String? id,
    required this.userId,
    required this.title,
    required this.message,
    DateTime? time,
    this.isRead = false,
    this.type = NotificationType.system,
  }) : id = id ?? const Uuid().v4(),
       time = time ?? DateTime.now();

  factory NotificationModel.fromJson(Map<String, dynamic> json) {
    return NotificationModel(
      id: json['id'] as String?,
      userId: json['userId'] as String,
      title: json['title'] as String,
      message: json['message'] as String,
      time: DateTime.parse(json['time'] as String),
      isRead: json['isRead'] as bool,
      type: NotificationType.values.firstWhere(
        (e) => e.name == json['type'] as String,
        orElse: () => NotificationType.system,
      ),
    );
  }

  /// Factory from Supabase row
  factory NotificationModel.fromSupabase(Map<String, dynamic> row) {
    return NotificationModel(
      id: row['notification_id'] as String?,
      userId: row['user_id'] as String,
      title: row['title'] as String,
      message: row['message'] as String,
      time: DateTime.parse(row['created_at'] as String),
      isRead: row['is_read'] as bool,
      type: NotificationType.values.firstWhere(
        (e) => e.name == row['type'] as String,
        orElse: () => NotificationType.system,
      ),
    );
  }

  /// Convert to JSON
  Map<String, dynamic> toJson() => {
    'id': id,
    'userId': userId,
    'title': title,
    'message': message,
    'time': time.toIso8601String(),
    'isRead': isRead,
    'type': type.name,
  };

  /// Convert to Supabase format
  Map<String, dynamic> toSupabase() => {
    'user_id': userId,
    'notification_id': id,
    'title': title,
    'message': message,
    'created_at': time.toIso8601String(),
    'is_read': isRead,
    'type': type.name,
  };

  /// Encode / decode JSON string
  String encode() => json.encode(toJson());
  static NotificationModel decode(String encoded) =>
      NotificationModel.fromJson(json.decode(encoded) as Map<String, dynamic>);

  /// Copy with modifications
  NotificationModel copyWith({
    String? id,
    String? userId,
    String? title,
    String? message,
    DateTime? time,
    bool? isRead,
    NotificationType? type,
  }) {
    return NotificationModel(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      message: message ?? this.message,
      time: time ?? this.time,
      isRead: isRead ?? this.isRead,
      type: type ?? this.type,
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\data\repos\notification_repo.dart =====
import '../../../../core/router/route_paths.dart';
import '../../../../core/service/supa_base_service.dart';
import '../../../../core/utils/notification_messages.dart';
import '../models/notification_model.dart';
import '../service/firebase_notifications_service.dart';
import '../service/local_notifications.dart';

class NotificationRepo {
  final SupaBaseService _supabaseService = SupaBaseService();
  final FirebaseNotificationsService _firebaseService =
      FirebaseNotificationsService();
  final LocalNotificationService _localNotificationService =
      LocalNotificationService();

  /// Initialize notifications for a user
  Future<void> initialize(String userId) async {
    await _firebaseService.initialize(userId);
  }

  /// Send sign-up notification
  Future<void> sendSignUpNotification({
    required String userId,
    required String userName,
    required String email,
  }) async {
    final notification = NotificationMessages.signUpMessage(
      userId: userId,
      userName: userName,
      email: email,
    );
    await _supabaseService.insertNotificationFromModel(notification);

    // Show local notification
    await _localNotificationService.showNotification(
      id: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      title: notification.title,
      body: notification.message,
      userId: userId,
      payload: Routes.notificationsScreen,
    );
  }

  /// Send login notification
  Future<void> sendLoginNotification({
    required String userId,
    required String userName,
    required String email,
  }) async {
    final notification = NotificationMessages.loginMessage(
      userId: userId,
      userName: userName,
      email: email,
    );
    await _supabaseService.insertNotificationFromModel(notification);

    // Show local notification
    await _localNotificationService.showNotification(
      id: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      title: notification.title,
      body: notification.message,
      userId: userId,
      payload: Routes.notificationsScreen,
    );
  }

  Future<void> sendNotification(NotificationModel notification) async {
    await _supabaseService.insertNotificationFromModel(notification);

    await _localNotificationService.showNotification(
      id: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      title: notification.title,
      body: notification.message,
      userId: notification.userId,
      payload: Routes.notificationsScreen,
    );
  }

  /// Get user notifications
  Future<List<NotificationModel>> getUserNotifications(String userId) async {
    if (userId.isEmpty) return [];
    return await _supabaseService.getUserNotifications(userId);
  }

  /// Get unread notifications count
  Future<int> getUnreadCount(String userId) async {
    final notifications = await getUserNotifications(userId);
    return notifications.where((n) => !n.isRead).length;
  }

  /// Mark notification as read
  Future<void> markAsRead(String notificationId) async {
    await _supabaseService.markAsRead(notificationId);
  }

  /// Mark all notifications as read
  Future<void> markAllAsRead(String userId) async {
    final notifications = await getUserNotifications(userId);
    for (final notification in notifications.where((n) => !n.isRead)) {
      await markAsRead(notification.id);
    }
  }

  /// Delete a notification
  Future<void> deleteNotification(String notificationId) async {
    await _supabaseService.deleteNotification(notificationId);
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\data\service\firebase_notifications_service.dart =====
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';

import '../../../../core/router/app_router.dart';
import '../../../../core/router/route_paths.dart';
import '../../../../core/service/supa_base_service.dart';
import '../../../../core/utils/secure_storage.dart';
import '../models/notification_model.dart';

class FirebaseNotificationsService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final SupaBaseService _supabaseService = SupaBaseService();

  /// Initialize Firebase service for a user
  Future<void> initialize(String userId) async {
    // Request notification permissions
    await _messaging.requestPermission(alert: true, badge: true, sound: true);

    // Save or update FCM token
    final token = await _messaging.getToken();
    if (token != null) {
      await _supabaseService.saveOrUpdateToken(userId, token);
      await SecureStorage().saveToken(token);
    }

    // Handle token refresh
    _messaging.onTokenRefresh.listen((newToken) async {
      await _supabaseService.saveOrUpdateToken(userId, newToken);
    });

    // Setup message handlers
    FirebaseMessaging.onMessage.listen(
      (message) => _handleForegroundMessage(message, userId),
    );
    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessageNavigation);
    final initialMessage = await _messaging.getInitialMessage();
    if (initialMessage != null) {
      _handleMessageNavigation(initialMessage);
    }
  }

  /// Handle foreground messages
  Future<void> _handleForegroundMessage(
    RemoteMessage message,
    String userId,
  ) async {
    final notification = message.notification;
    if (notification == null) return;

    await saveNotification(message, userId);
  }

  /// Handle navigation when notification is tapped
  void _handleMessageNavigation(RemoteMessage message) {
    final context = navigatorKey.currentContext;
    if (context == null) return;

    final route = message.data['route'] ?? Routes.notificationsScreen;
    final currentRoute = ModalRoute.of(context)?.settings.name;

    if (currentRoute != route) {
      navigatorKey.currentState?.pushNamedAndRemoveUntil(
        route,
        (route) => false,
        arguments: message,
      );
    }
  }

  /// Save notification to Supabase
  Future<NotificationModel> saveNotification(
    RemoteMessage message,
    String userId,
  ) async {
    final notification = message.notification;
    if (notification == null) {
      throw Exception('No notification data');
    }

    final messageId =
        message.messageId ?? DateTime.now().millisecondsSinceEpoch.toString();
    final type = _getNotificationType(message.data);

    final notificationModel = NotificationModel(
      id: messageId,
      userId: userId,
      title: notification.title ?? 'New Notification',
      message: notification.body ?? '',
      type: type,
      isRead: false,
      time: DateTime.now(),
    );

    await _supabaseService.insertNotification(
      userId: userId,
      title: notification.title ?? 'New Notification',
      message: notification.body ?? '',
      type: type,
      notificationId: messageId,
    );

    return notificationModel;
  }

  /// Determine notification type from message data
  NotificationType _getNotificationType(Map<String, dynamic> data) {
    final typeString = data['type'] as String?;
    return typeString != null
        ? NotificationType.values.firstWhere(
            (type) => type.name == typeString,
            orElse: () => NotificationType.system,
          )
        : NotificationType.system;
  }

  /// Handle background notifications
  Future<void> handleBackgroundMessage(RemoteMessage message) async {
    final userId = await SecureStorage().getUserId();
    if (userId == null) return;

    await saveNotification(message, userId);
  }
}

@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  final userId = await SecureStorage().getUserId();
  if (userId == null) return;

  final supabaseService = SupaBaseService();
  final notification = message.notification;
  if (notification == null) return;

  final messageId =
      message.messageId ?? DateTime.now().millisecondsSinceEpoch.toString();
  final typeString = message.data['type'] as String?;
  final type = typeString != null
      ? NotificationType.values.firstWhere(
          (type) => type.name == typeString,
          orElse: () => NotificationType.system,
        )
      : NotificationType.system;

  await supabaseService.insertNotification(
    userId: userId,
    title: notification.title ?? 'New Notification',
    message: notification.body ?? '',
    type: type,
    notificationId: messageId,
  );
}
===== C:\flutter_apps\im_legends\lib\features\notification\data\service\local_notifications.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../../core/router/app_router.dart' as AppRouter;
import '../../../../core/utils/secure_storage.dart';

class LocalNotificationService {
  // Singleton
  static final LocalNotificationService _instance =
      LocalNotificationService._internal();
  factory LocalNotificationService() => _instance;
  LocalNotificationService._internal();

  final FlutterLocalNotificationsPlugin _localNotifications =
      FlutterLocalNotificationsPlugin();

  /// Initialize local notifications
  Future<void> initialize() async {
    const android = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iOS = DarwinInitializationSettings();

    const settings = InitializationSettings(android: android, iOS: iOS);

    await _localNotifications.initialize(
      settings,
      onDidReceiveNotificationResponse: (response) {
        final payload = response.payload;
        if (payload != null && payload.isNotEmpty) {
          _handleNotificationTap(payload);
        }
      },
    );

    // âœ… Ask for POST_NOTIFICATIONS permission on Android 13+
    if (Platform.isAndroid) {
      final status = await Permission.notification.status;
      if (!status.isGranted) {
        await Permission.notification.request();
      }
    }

    // âœ… Ask for permission on iOS
    await _localNotifications
        .resolvePlatformSpecificImplementation<
          IOSFlutterLocalNotificationsPlugin
        >()
        ?.requestPermissions(alert: true, badge: true, sound: true);
  }

  /// Show a local notification AND save it for the specific user
  Future<void> showNotification({
    required int id,
    required String? title,
    required String? body,
    required String userId,
    String? payload,
  }) async {
    final currentUserId = await SecureStorage().getUserId();

    // ðŸš¨ Only show if this notification belongs to the logged-in user
    if (currentUserId != userId) {
      debugPrint("â© Skipping notification for another user: $userId");
      return;
    }

    const androidDetails = AndroidNotificationDetails(
      'default_channel',
      'General Notifications',
      channelDescription: 'Used for general app notifications',
      importance: Importance.max,
      priority: Priority.high,
    );

    const details = NotificationDetails(android: androidDetails);

    await _localNotifications.show(id, title, body, details, payload: payload);
  }

  /// Handle notification tap â†’ navigate
  void _handleNotificationTap(String payload) {
    final context = AppRouter.navigatorKey.currentContext;
    if (context == null) return;
    AppRouter.navigatorKey.currentState?.pushNamed(payload);
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\logic\cubit\notifications_cubit.dart =====
import 'package:bloc/bloc.dart';
import '../../../../core/service/supa_base_service.dart';
import '../../../../core/utils/notification_messages.dart';
import '../../../../core/utils/secure_storage.dart';
import '../../data/repos/notification_repo.dart';
import '../../data/models/notification_model.dart';
import 'package:meta/meta.dart';

part 'notifications_state.dart';

class NotificationsCubit extends Cubit<NotificationsState> {
  NotificationsCubit({required this.notificationRepo})
    : super(NotificationsInitial());

  final NotificationRepo notificationRepo;
  final SecureStorage secureStorage = SecureStorage();
  final SupaBaseService supabaseService = SupaBaseService();

  /// Fetch notifications for the current user
  Future<void> fetchNotifications() async {
    emit(NotificationsLoading());
    try {
      final userId = await secureStorage.getUserId();
      if (userId == null || userId.isEmpty) {
        emit(NotificationsFailure(errorMessage: 'User ID not found'));
        return;
      }

      final notifications = await notificationRepo.getUserNotifications(userId);
      emit(NotificationsSuccess(notifications: notifications));
    } catch (e) {
      emit(NotificationsFailure(errorMessage: e.toString()));
    }
  }

  /// Send login notification
  Future<void> sendLoginNotification({
    required String userId,
    required String userName,
    required String email,
  }) async {
    try {
      await notificationRepo.sendLoginNotification(
        userId: userId,
        userName: userName,
        email: email,
      );
      await fetchNotifications(); // Refresh notifications
    } catch (e) {
      emit(
        NotificationsFailure(
          errorMessage: 'Failed to send login notification: $e',
        ),
      );
    }
  }

  /// Send sign-up notification
  Future<void> sendSignUpNotification({
    required String userId,
    required String userName,
    required String email,
  }) async {
    try {
      await notificationRepo.sendSignUpNotification(
        userId: userId,
        userName: userName,
        email: email,
      );
      await fetchNotifications(); // Refresh notifications
    } catch (e) {
      emit(
        NotificationsFailure(
          errorMessage: 'Failed to send sign-up notification: $e',
        ),
      );
    }
  }

  Future<void> handleMatchResult({
    required String winnerId,
    required String loserId,
  }) async {
    try {
      print("âš¡ WinnerId: $winnerId | LoserId: $loserId");

      final winnerData = await supabaseService.fetchUserProfileById(winnerId);
      final loserData = await supabaseService.fetchUserProfileById(loserId);

      final winnerName = winnerData?['name'] ?? 'Player';
      final loserName = loserData?['name'] ?? 'Player';

      print("ðŸ† WinnerName: $winnerName | âŒ LoserName: $loserName");

      // âœ… Create notifications
      final winnerNotification = NotificationMessages.winnerMessage(
        userId: winnerId,
        userName: winnerName,
      );

      final loserNotification = NotificationMessages.loserMessage(
        userId: loserId,
        userName: loserName,
      );

      // âœ… Send both
      await notificationRepo.sendNotification(winnerNotification);
      await notificationRepo.sendNotification(loserNotification);

      await fetchNotifications();
    } catch (e) {
      emit(
        NotificationsFailure(errorMessage: 'Failed to send match results: $e'),
      );
    }
  }

  /// Mark a single notification as read
  Future<void> markAsRead(String notificationId) async {
    try {
      await notificationRepo.markAsRead(notificationId);
      await fetchNotifications(); // Refresh state
    } catch (e) {
      emit(NotificationsFailure(errorMessage: e.toString()));
    }
  }

  /// Mark all notifications as read for the current user
  Future<void> markAllAsRead() async {
    try {
      final userId = await secureStorage.getUserId();
      if (userId == null || userId.isEmpty) {
        emit(NotificationsFailure(errorMessage: 'User ID not found'));
        return;
      }
      await notificationRepo.markAllAsRead(userId);
      await fetchNotifications(); // Refresh state
    } catch (e) {
      emit(NotificationsFailure(errorMessage: e.toString()));
    }
  }

  /// Delete a notification by ID
  Future<void> deleteNotification(String notificationId) async {
    try {
      await notificationRepo.deleteNotification(notificationId);
      await fetchNotifications(); // Refresh state
    } catch (e) {
      emit(NotificationsFailure(errorMessage: e.toString()));
    }
  }

  Future<void> resetNotificationsCount() async {
    try {
      if (state is NotificationsSuccess) {
        final currentState = state as NotificationsSuccess;

        final updatedNotifications = currentState.notifications
            .map((n) => n.copyWith(isRead: true))
            .toList();

        // ðŸ”‘ emit immediately with all read
        emit(NotificationsSuccess(notifications: updatedNotifications));
      }
    } catch (e) {
      emit(NotificationsFailure(errorMessage: e.toString()));
    }
  }

  /// Get unread notifications count
  Future<int> getUnreadCount() async {
    try {
      final userId = await secureStorage.getUserId();
      if (userId == null || userId.isEmpty) return 0;
      return await notificationRepo.getUnreadCount(userId);
    } catch (e) {
      return 0;
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\logic\cubit\notifications_state.dart =====
part of 'notifications_cubit.dart';

@immutable
sealed class NotificationsState {}

final class NotificationsInitial extends NotificationsState {}

final class NotificationsLoading extends NotificationsState {}

final class NotificationsSuccess extends NotificationsState {
  final List<NotificationModel> notifications;
  NotificationsSuccess({required this.notifications});
}

final class NotificationsFailure extends NotificationsState {
  final String errorMessage;
  NotificationsFailure({required this.errorMessage});
}
===== C:\flutter_apps\im_legends\lib\features\notification\ui\widgets\notification_app_bar.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_texts_style.dart';

class NotificationAppBar extends StatelessWidget {
  final int unreadCount;
  final VoidCallback onBack;
  final VoidCallback onMarkAllAsRead;

  const NotificationAppBar({
    super.key,
    required this.unreadCount,
    required this.onBack,
    required this.onMarkAllAsRead,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.only(
        left: 16.w,
        right: 16.w,
        top: 50.h,
        bottom: 16.h,
      ),
      decoration: BoxDecoration(
        color: Colors.grey[900],
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.3 * 255).toInt()),
            blurRadius: 8.r,
            offset: Offset(0, 2.h),
          ),
        ],
      ),
      child: Row(
        children: [
          GestureDetector(
            onTap: onBack,
            child: Container(
              padding: EdgeInsets.all(8.w),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(8.r),
              ),
              child: Icon(
                Icons.arrow_back_ios_new,
                size: 20.sp,
                color: Colors.grey[700],
              ),
            ),
          ),
          SizedBox(width: 16.w),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Notifications', style: BebasTextStyles.whiteBold20),
                if (unreadCount > 0)
                  Text(
                    '$unreadCount new notifications',
                    style: TextStyle(
                      fontSize: 14.sp,
                      color: Colors.blue[300],
                      fontWeight: FontWeight.w500,
                    ),
                  ),
              ],
            ),
          ),
          if (unreadCount > 0)
            Container(
              padding: EdgeInsets.symmetric(horizontal: 12.w, vertical: 6.h),
              decoration: BoxDecoration(
                color: Colors.blue[900],
                borderRadius: BorderRadius.circular(16.r),
                border: Border.all(color: Colors.blue[700]!),
              ),
              child: GestureDetector(
                onTap: onMarkAllAsRead,
                child: Text(
                  'Mark all read',
                  style: TextStyle(
                    fontSize: 12.sp,
                    color: Colors.blue[200],
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\ui\widgets\notification_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/themes/app_colors.dart';
import '../../../../core/utils/functions/date_formate.dart';
import '../../../../core/utils/spacing.dart';
import '../../data/models/notification_model.dart';

class NotificationCard extends StatelessWidget {
  final NotificationModel notification;
  final int index;
  final VoidCallback onDelete;
  final VoidCallback onTap;

  const NotificationCard({
    super.key,
    required this.notification,
    required this.index,
    required this.onDelete,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Dismissible(
      key: Key(notification.id),
      direction: DismissDirection.endToStart,
      background: Container(
        alignment: Alignment.centerRight,
        padding: EdgeInsets.symmetric(horizontal: 20.w),
        decoration: BoxDecoration(
          color: Colors.red[400],
          borderRadius: BorderRadius.circular(12.r),
        ),
        child: Icon(Icons.delete_outline, color: Colors.white, size: 24.sp),
      ),
      onDismissed: (direction) => onDelete(),
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          padding: EdgeInsets.all(16.w),
          decoration: BoxDecoration(
            color: Colors.grey[850],
            borderRadius: BorderRadius.circular(12.r),
            border: notification.isRead
                ? Border.all(color: Colors.grey[700]!, width: 1)
                : Border.all(color: Colors.blue[300]!, width: 1.5),
            boxShadow: [
              BoxShadow(
                color: Colors.black..withAlpha((0.6 * 255).toInt()),
                blurRadius: 6.r,
                offset: Offset(0, 2.h),
              ),
            ],
          ),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildIcon(),
              SizedBox(width: 12.w),
              _buildContent(),
              horizontalSpacing(12),

              GestureDetector(
                onTap: onDelete,
                child: Icon(Icons.delete, color: Colors.red[600], size: 20.sp),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildIcon() {
    return Container(
      width: 40.w,
      height: 40.w,
      decoration: BoxDecoration(
        color: _getNotificationColor(
          notification.type,
        ).withAlpha((0.1 * 255).toInt()),
        borderRadius: BorderRadius.circular(8.r),
      ),
      child: Icon(
        _getNotificationIcon(notification.type),
        color: _getNotificationColor(notification.type),
        size: 20.sp,
      ),
    );
  }

  Widget _buildContent() {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Expanded(
                child: Text(
                  notification.title,
                  style: TextStyle(
                    fontSize: 16.sp,
                    fontWeight: notification.isRead
                        ? FontWeight.w600
                        : FontWeight.w700,
                    color: notification.isRead
                        ? Colors.grey[300]
                        : Colors.white,
                  ),
                ),
              ),
              if (!notification.isRead)
                Container(
                  width: 8.w,
                  height: 8.w,
                  decoration: BoxDecoration(
                    color: Colors.blue[600],
                    shape: BoxShape.circle,
                  ),
                ),
            ],
          ),
          verticalSpacing(4),
          Text(
            notification.message,
            style: TextStyle(
              fontSize: 14.sp,
              color: AppColors.greyColor,
              height: 1.3,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          verticalSpacing(8),
          Text(
            "${formatSmart(notification.time)}",
            style: TextStyle(
              fontSize: 12.sp,
              color: Colors.grey[500],
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  IconData _getNotificationIcon(NotificationType type) {
    switch (type) {
      case NotificationType.welcome:
        return Icons.celebration_outlined;
      case NotificationType.update:
        return Icons.system_update_outlined;
      case NotificationType.security:
        return Icons.security_outlined;
      case NotificationType.promotion:
        return Icons.local_offer_outlined;
      case NotificationType.system:
        return Icons.settings_outlined;
    }
  }

  Color _getNotificationColor(NotificationType type) {
    switch (type) {
      case NotificationType.welcome:
        return Colors.green;
      case NotificationType.update:
        return Colors.blue;
      case NotificationType.security:
        return Colors.orange;
      case NotificationType.promotion:
        return Colors.purple;
      case NotificationType.system:
        return Colors.grey;
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\ui\widgets\notification_details_screen.dart =====
import 'package:flutter/material.dart';

import '../../data/models/notification_model.dart';

class NotificationDetailsScreen extends StatelessWidget {
  final NotificationModel notification;

  const NotificationDetailsScreen({super.key, required this.notification});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF191919),
      appBar: AppBar(
        backgroundColor: const Color(0xFF191919),
        title: const Text(
          'Notification Detail',
          style: TextStyle(color: Colors.white),
        ),
        iconTheme: const IconThemeData(color: Colors.white),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              notification.title,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 22,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 10),
            Text(
              notification.message,
              style: const TextStyle(color: Colors.grey, fontSize: 16),
            ),
            const Spacer(),
            Align(
              alignment: Alignment.bottomRight,
              child: Text(
                '${notification.time}',
                style: const TextStyle(color: Colors.grey),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\ui\widgets\notification_empty_state.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

class NotificationEmptyState extends StatelessWidget {
  const NotificationEmptyState({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 80.w,
            height: 80.w,
            decoration: BoxDecoration(
              color: Colors.grey[800],
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.notifications_none_outlined,
              size: 40.sp,
              color: Colors.grey[500],
            ),
          ),
          SizedBox(height: 16.h),
          Text(
            'No notifications yet',
            style: TextStyle(
              fontSize: 18.sp,
              fontWeight: FontWeight.w600,
              color: Colors.white,
            ),
          ),
          SizedBox(height: 8.h),
          Text(
            'When you get notifications, they\'ll appear here',
            style: TextStyle(fontSize: 14.sp, color: Colors.grey[400]),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\notification\ui\notifications_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';

import '../../../core/router/route_paths.dart';
import '../../../core/themes/app_colors.dart';
import '../logic/cubit/notifications_cubit.dart';
import 'widgets/notification_app_bar.dart';
import 'widgets/notification_card.dart';
import 'widgets/notification_empty_state.dart';

class NotificationsScreen extends StatelessWidget {
  const NotificationsScreen({super.key});

  @override
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: Column(
        children: [
          BlocBuilder<NotificationsCubit, NotificationsState>(
            builder: (context, state) {
              int unreadCount = 0;
              if (state is NotificationsSuccess) {
                unreadCount = state.notifications
                    .where((notification) => !notification.isRead)
                    .length;
              }
              return NotificationAppBar(
                unreadCount: unreadCount,
                onBack: () => Navigator.of(context).pop(),
                onMarkAllAsRead: () =>
                    context.read<NotificationsCubit>().markAllAsRead(),
              );
            },
          ),
          Expanded(
            child: BlocBuilder<NotificationsCubit, NotificationsState>(
              builder: (context, state) {
                if (state is NotificationsLoading) {
                  return const Center(
                    child: CircularProgressIndicator(color: Colors.white),
                  );
                } else if (state is NotificationsFailure) {
                  return Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: Colors.red,
                          size: 48.sp,
                        ),
                        SizedBox(height: 16.h),
                        Text(
                          'Error loading notifications',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 16.sp,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                        SizedBox(height: 8.h),
                        Text(
                          state.errorMessage,
                          style: TextStyle(color: Colors.grey, fontSize: 14.sp),
                          textAlign: TextAlign.center,
                        ),
                        SizedBox(height: 16.h),
                        ElevatedButton(
                          onPressed: () {
                            context
                                .read<NotificationsCubit>()
                                .fetchNotifications();
                          },
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blue,
                            foregroundColor: Colors.white,
                          ),
                          child: const Text('Retry'),
                        ),
                      ],
                    ),
                  );
                } else if (state is NotificationsSuccess) {
                  final notifications = state.notifications;
                  // Add these debug prints
                  print('ðŸ” Total notifications: ${notifications.length}');
                  print(
                    'ðŸ” Unique notification IDs: ${notifications.map((n) => n.id).toSet().length}',
                  );

                  // Check for duplicates
                  final ids = notifications.map((n) => n.id).toList();
                  final uniqueIds = ids.toSet();
                  if (ids.length != uniqueIds.length) {
                    print('âŒ DUPLICATES FOUND!');
                    print('All IDs: $ids');
                    print('Unique IDs: $uniqueIds');
                  }

                  if (notifications.isEmpty) {
                    return const NotificationEmptyState();
                  }
                  return RefreshIndicator(
                    onRefresh: () async {
                      context.read<NotificationsCubit>().fetchNotifications();
                    },
                    backgroundColor: AppColors.lightDarkColor,
                    color: Colors.white,
                    child: ListView.separated(
                      physics: const AlwaysScrollableScrollPhysics(),
                      padding: EdgeInsets.symmetric(
                        horizontal: 16.w,
                        vertical: 8.h,
                      ),
                      itemCount: notifications.length,
                      separatorBuilder: (context, index) =>
                          SizedBox(height: 8.h),
                      itemBuilder: (context, index) {
                        final notification = notifications[index];
                        return NotificationCard(
                          notification: notification,
                          index: index,
                          onDelete: () {
                            context
                                .read<NotificationsCubit>()
                                .deleteNotification(notification.id);

                            // Show snackbar with undo option
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                content: const Text('Notification deleted'),
                                action: SnackBarAction(
                                  label: 'Undo',
                                  onPressed: () {},
                                ),
                                duration: const Duration(seconds: 3),
                                backgroundColor: Colors.grey[800],
                              ),
                            );
                          },
                       
                          onTap: () {
                            // Mark as read first
                            context.read<NotificationsCubit>().markAsRead(
                              notification.id,
                            );

                            // Then navigate to details
                            context.push(
                              Routes.notificationDetailsScreen,
                              extra: notification,
                            );
                          },
                        );
                      },
                    ),
                  );
                } else {
                  return const NotificationEmptyState();
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\onboarding\data\models\on_boarding_info.dart =====
import 'package:flutter/material.dart';

class OnBoardingInfo {
  final String title;
  final String subTitle;
  final IconData? icon;
  final List<Color>? gradient;

  const OnBoardingInfo({
    required this.title,
    required this.subTitle,
    this.icon,
    this.gradient,
  });

  // Centralized onboarding data for friends football match tracking app
  static const List<OnBoardingInfo> cardsData = [
    OnBoardingInfo(
      title: 'Record Friend Matches',
      subTitle:
          'Store every goal, assist and epic moment from your crew\'s games.',
      icon: Icons.sports_soccer,
    // Red gradient
    ),
    OnBoardingInfo(
      title: 'Championship Mode',
      subTitle:
          'Create tournaments and crown the ultimate champion in your squad.',
      icon: Icons.emoji_events,
    ),
    OnBoardingInfo(
      title: 'Friends Leaderboard',
      subTitle: 'See who\'s dominating with goals, wins and bragging rights.',
      icon: Icons.leaderboard,

    ),
    OnBoardingInfo(
      title: 'Match History',
      subTitle: 'Never forget those legendary games and comeback victories.',
      icon: Icons.history,

    ),
    OnBoardingInfo(
      title: 'Player Stats',
      subTitle:
          'Track individual performance and become the GOAT of your group.',
      icon: Icons.bar_chart,

    ),
    OnBoardingInfo(
      title: 'Squad Management',
      subTitle:
          'Organize teams, invite friends and build your football empire.',
      icon: Icons.group,

    ),
  ];

  // Method to get cards in pairs for grid layout
  static List<List<OnBoardingInfo>> get cardsPairs {
    List<List<OnBoardingInfo>> pairs = [];
    for (int i = 0; i < cardsData.length; i += 2) {
      if (i + 1 < cardsData.length) {
        pairs.add([cardsData[i], cardsData[i + 1]]);
      } else {
        pairs.add([cardsData[i]]);
      }
    }
    return pairs;
  }

  // Method to get featured cards (first 4 for main onboarding)
  static List<OnBoardingInfo> get featuredCards => cardsData.take(4).toList();
}
===== C:\flutter_apps\im_legends\lib\features\onboarding\ui\widgets\on_boarding_custom_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/spacing.dart';

class OnBoardingCustomCard extends StatelessWidget {
  const OnBoardingCustomCard({
    super.key,
    required this.title,
    required this.subTitle,
    this.icon,
    this.gradient,
  });

  final String title;
  final String subTitle;
  final IconData? icon;
  final List<Color>? gradient;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(20.r),
        gradient: gradient != null
            ? LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: gradient!,
              )
            : const LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [Color(0xFF2A3441), Color(0xFF1E2832)],
              ),
        border: Border.all(color: const Color(0xFF3A4553), width: 1),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.3 * 255).toInt()),
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(20.r),
          child: Padding(
            padding: EdgeInsets.all(12.w),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                // Icon section - more compact
                if (icon != null) ...[
                  Container(
                    padding: EdgeInsets.all(6.w),
                    decoration: BoxDecoration(
                      color: Colors.white.withAlpha((0.15 * 255).toInt()),
                      borderRadius: BorderRadius.circular(10.r),
                    ),
                    child: Icon(icon!, color: Colors.white, size: 20.sp),
                  ),
                  SizedBox(height: 8.h),
                ],
                Flexible(
                  flex: 2,
                  child: FittedBox(
                    fit: BoxFit.scaleDown,
                    child: Text(
                      title,
                      style: BebasTextStyles.whiteBold14.copyWith(height: 1.1),
                      textAlign: TextAlign.center,
                      maxLines: 2,
                    ),
                  ),
                ),
                verticalSpacing(5),
                Flexible(
                  flex: 5,
                  child: Text(
                    subTitle,
                    style: RobotoTextStyles.greyRegular14.copyWith(
                      fontSize: 10.sp,
                      color: const Color(0xFFB0B8C1),
                      height: 1.2,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 3,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\onboarding\ui\widgets\on_boarding_grid_cards.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../data/models/on_boarding_info.dart';
import 'on_boarding_custom_card.dart';

class OnBoardingGridCards extends StatelessWidget {
  const OnBoardingGridCards({
    super.key,
    this.showAllCards = false, // Option to show all cards or just featured ones
  });

  final bool showAllCards;

  @override
  Widget build(BuildContext context) {
    final cardsToShow = showAllCards
        ? OnBoardingInfo.cardsData
        : OnBoardingInfo.featuredCards;

    return GridView.builder(
      itemCount: cardsToShow.length,
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      padding: EdgeInsets.symmetric(horizontal: 8.w),
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        crossAxisSpacing: 16.w,
        mainAxisSpacing: 16.h,
        childAspectRatio: 1.15, // Optimized for better card proportions
      ),
      itemBuilder: (context, index) {
        final card = cardsToShow[index];
        return OnBoardingCustomCard(
          title: card.title,
          subTitle: card.subTitle,
          icon: card.icon,
          gradient: card.gradient,
        );
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\onboarding\ui\widgets\on_boarding_icons.dart =====
import 'package:flutter/material.dart';

class OnBoardingIcons extends StatelessWidget {
  const OnBoardingIcons({super.key});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceAround,
      children: [
        const Text('âš½', style: TextStyle(fontSize: 20)),

        Container(height: 30, width: 1, color: const Color(0xFF2A3441)),
        const Text('ðŸ†', style: TextStyle(fontSize: 20)),

        Container(height: 30, width: 1, color: const Color(0xFF2A3441)),
        const Text('â­', style: TextStyle(fontSize: 20)),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\onboarding\ui\on_boarding_screen.dart =====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/router/route_paths.dart';
import '../../../core/themes/app_texts_style.dart';
import '../../../core/utils/spacing.dart';
import '../../../core/widgets/custom_text_button.dart';
import '../../../core/widgets/gradient_background.dart';
import '../../../core/widgets/logo_top_bar.dart';
import 'widgets/on_boarding_grid_cards.dart';
import 'widgets/on_boarding_icons.dart';

class OnBoardingScreen extends StatelessWidget {
  const OnBoardingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GradientBackground(
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: 20.0,
              vertical: 16.0,
            ),
            child: Column(
              children: [
                const LogoTopBar(),
                verticalSpacing(40),
                // Hero section
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Main headline
                    ShaderMask(
                      shaderCallback: (bounds) => const LinearGradient(
                        colors: [Colors.white, Color(0xFFE8E8E8)],
                      ).createShader(bounds),
                      child: Text(
                        'Dominate the Pitch\nWith Your Squad!',
                        style: BebasTextStyles.whiteBold24,
                        textAlign: TextAlign.center,
                      ),
                    ),

                    verticalSpacing(16),

                    // Subtitle
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 20),
                      child: Text(
                        'Challenge your friends, track your stats, and become the ultimate football legend in your crew',
                        style: RobotoTextStyles.greyRegular14.copyWith(
                          fontSize: 16,
                          color: const Color(0xFFB0B8C1),
                          height: 1.4,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ),
                    verticalSpacing(20),
                    const OnBoardingGridCards(),
                    verticalSpacing(20),

                    // Stats preview row
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 16,
                      ),
                      decoration: BoxDecoration(
                        color: const Color(0xFF1E2832),
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(
                          color: const Color(0xFF2A3441),
                          width: 1,
                        ),
                      ),
                      child: const OnBoardingIcons(),
                    ),
                    verticalSpacing(40),
                    CustomTextButton(
                      buttonText: 'Start Your Journey',
                      textStyle: RobotoTextStyles.whiteBold20,
                      onPressed: () => context.push(Routes.loginScreen),
                    ),
                    verticalSpacing(16),
                    Text(
                      'Join thousands of players already competing',
                      style: RobotoTextStyles.greyRegular12,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\data\model\profile_model.dart =====
import '../../../../core/models/players_states_model.dart';
import '../../../../core/models/user_data.dart';

class UserProfileModel {
  final UserData user;
  final PlayerStatsModel stats;

  UserProfileModel({required this.user, required this.stats});
}
===== C:\flutter_apps\im_legends\lib\features\profile\data\repo\profile_repo.dart =====
import '../../../../core/utils/secure_storage.dart';
import '../model/profile_model.dart';

import '../service/profile_service.dart';

class ProfileRepo {
  final ProfileService profileService;
  final SecureStorage secureStorage = SecureStorage();

  ProfileRepo({required this.profileService});

  /// Get full profile data + stats
  Future<UserProfileModel?> getProfileWithStats() async {
    final userId = await secureStorage.getUserId();

    if (userId == null || userId.isEmpty) {
      throw Exception("User ID not found in secure storage");
    }

    try {
      final user = await profileService.fetchUserData(userId);
      final stats = await profileService.fetchPlayerStats(userId);

      return UserProfileModel(user: user, stats: stats);
    } catch (e) {
      print("âŒ Error fetching profile with stats: $e");
      return null;
    }
  }

  /// Logout user: clears secure storage + Supabase session
  Future<void> logout() async {
    await secureStorage.clearToken();
    await profileService.logout();
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\data\service\profile_service.dart =====
import '../../../../core/models/players_states_model.dart';
import '../../../../core/models/user_data.dart';
import '../../../../core/service/supa_base_service.dart';

class ProfileService {
  final SupaBaseService supabaseService = SupaBaseService();

  /// âœ… Fetch and calculate full player stats
  Future<PlayerStatsModel> fetchPlayerStats(String userId) async {
    try {
      // 1ï¸âƒ£ Fetch all users (id, name, profile image)
      final users = await supabaseService.supabase
          .from('users')
          .select('id, name, profile_image');

      // 2ï¸âƒ£ Fetch all matches
      final matches = await supabaseService.supabase
          .from('matches')
          .select('*');

      // 3ï¸âƒ£ Initialize player stats for all users
      final Map<String, PlayerStatsModel> stats = {
        for (var u in users)
          u['id']: PlayerStatsModel(
            playerId: u['id'],
            playerName: u['name'] ?? 'Unknown',
            profileImage: u['profile_image'],
          ),
      };

      // 4ï¸âƒ£ Loop through all matches and calculate
      for (var match in matches) {
        final winnerId = match['winner_id'] as String?;
        final loserId = match['loser_id'] as String?;
        final winnerScore = (match['winner_score'] ?? 0) as int;
        final loserScore = (match['loser_score'] ?? 0) as int;

        if (winnerId == null || loserId == null) continue;

        // ðŸ† Winner stats
        final winner = stats[winnerId];
        if (winner != null) {
          stats[winnerId] = winner.copyWith(
            matchesPlayed: winner.matchesPlayed + 1,
            wins: winner.wins + 1,
            goalsScored: winner.goalsScored + winnerScore,
            goalsReceived: winner.goalsReceived + loserScore,
            goalDifference:
                (winner.goalsScored + winnerScore) -
                (winner.goalsReceived + loserScore),
            points: winner.points + 3,
          );
        }

        // âŒ Loser stats
        final loser = stats[loserId];
        if (loser != null) {
          stats[loserId] = loser.copyWith(
            matchesPlayed: loser.matchesPlayed + 1,
            losses: loser.losses + 1,
            goalsScored: loser.goalsScored + loserScore,
            goalsReceived: loser.goalsReceived + winnerScore,
            goalDifference:
                (loser.goalsScored + loserScore) -
                (loser.goalsReceived + winnerScore),
          );
        }
      }

      // 5ï¸âƒ£ Sort all players to compute ranking
      final leaderboard = stats.values.toList()
        ..sort((a, b) {
          if (b.points != a.points) {
            return b.points.compareTo(a.points);
          } else if (b.goalDifference != a.goalDifference) {
            return b.goalDifference.compareTo(a.goalDifference);
          } else {
            return b.goalsScored.compareTo(a.goalsScored);
          }
        });

      // 6ï¸âƒ£ Assign rank
      for (int i = 0; i < leaderboard.length; i++) {
        leaderboard[i] = leaderboard[i].copyWith(rank: i + 1);
      }

      // 7ï¸âƒ£ Return this specific user's stats
      final playerStats = leaderboard.firstWhere(
        (p) => p.playerId == userId,
        orElse: () => PlayerStatsModel(
          playerId: userId,
          playerName: 'Unknown Player',
          profileImage: null,
        ),
      );

      return playerStats;
    } catch (e) {
      print("âŒ Error calculating player stats: $e");
      rethrow;
    }
  }

  /// âœ… Fetch user base info
  Future<UserData> fetchUserData(String userId) async {
    try {
      final response = await supabaseService.supabase
          .from('users')
          .select()
          .eq('id', userId)
          .single();

      return UserData.fromMap(response);
    } catch (e) {
      print("âŒ Error fetching user data: $e");
      rethrow;
    }
  }

  /// âœ… Logout current user
  Future<void> logout() async {
    try {
      await supabaseService.logoutUser();
      print("âœ… User logged out successfully from ProfileService");
    } catch (e) {
      print("âŒ Logout failed: $e");
      rethrow;
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\logic\cubit\profile_cubit.dart =====
import 'package:bloc/bloc.dart';
import '../../data/model/profile_model.dart';
import 'package:meta/meta.dart';
import '../../data/repo/profile_repo.dart';

part 'profile_state.dart';

class ProfileCubit extends Cubit<ProfileState> {
  final ProfileRepo profileRepo;

  ProfileCubit({required this.profileRepo}) : super(ProfileInitial());

  /// âœ… Fetch profile with stats
  Future<void> fetchProfile() async {
    emit(ProfileLoading());
    try {
      final player = await profileRepo.getProfileWithStats();
      if (player != null) {
        emit(ProfileSuccess(player: player));
      } else {
        emit(ProfileFailure("Profile not found"));
      }
    } catch (e) {
      emit(ProfileFailure("âŒ Failed to fetch profile: $e"));
    }
  }

  /// âœ… Logout the current user
  Future<void> logout() async {
    emit(ProfileLoading());
    try {
      await profileRepo.logout();
      emit(ProfileLoggedOut()); // ðŸ”¥ new dedicated state
    } catch (e) {
      emit(ProfileFailure("âŒ Logout failed: $e"));
    }
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\logic\cubit\profile_state.dart =====
part of 'profile_cubit.dart';

@immutable
abstract class ProfileState {}

class ProfileInitial extends ProfileState {}

class ProfileLoading extends ProfileState {}

class ProfileSuccess extends ProfileState {
  final UserProfileModel player;
  ProfileSuccess({required this.player});
}

class ProfileFailure extends ProfileState {
  final String message;
  ProfileFailure(this.message);
}

class ProfileLoggedOut extends ProfileState {} // ðŸ”¥ new state
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\profile_header.dart =====
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/utils/spacing.dart';
import '../../../../core/themes/text_styles/bebas_text_styles.dart';
import '../../../../core/utils/functions/get_rank_color.dart';

class ProfileHeader extends StatelessWidget {
  final int rank;
  final String name;
  final String? imageUrl;

  const ProfileHeader({
    super.key,
    required this.rank,
    required this.name,
    required this.imageUrl,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(top: 32.h),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [
            getRankColor(rank).withAlpha((0.5 * 255).toInt()),
            Colors.black.withAlpha((0.3 * 255).toInt()),
            Colors.black,
          ],
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
        ),
        borderRadius: BorderRadius.only(
          bottomLeft: Radius.circular(24.r),
          bottomRight: Radius.circular(24.r),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.3 * 255).toInt()),
            blurRadius: 10,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 120.w,
            height: 120.w,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(
                color: Colors.white.withAlpha((0.4 * 255).toInt()),
                width: 3.w,
              ),
              boxShadow: [
                BoxShadow(
                  color: getRankColor(rank).withAlpha((0.5 * 255).toInt()),
                  blurRadius: 20,
                  spreadRadius: 2,
                ),
              ],
            ),
            child: ClipOval(
              child: CachedNetworkImage(
                imageUrl: imageUrl ?? '',
                fit: BoxFit.cover,
                placeholder: (context, url) => const Center(
                  child: CircularProgressIndicator(
                    color: Colors.white,
                    strokeWidth: 2,
                  ),
                ),
                errorWidget: (context, url, error) =>
                    const Icon(Icons.person, color: Colors.white, size: 60),
              ),
            ),
          ),
          SizedBox(height: 16.h),

          // Name
          Text(
            name,
            style: BebasTextStyles.whiteBold24.copyWith(
              fontSize: 28.sp,
              letterSpacing: 1.2,
            ),
          ),
          verticalSpacing(8),
          // Rank Badge
          Container(
            padding: EdgeInsets.symmetric(horizontal: 18.w, vertical: 6.h),
            decoration: BoxDecoration(
              color: getRankColor(rank),
              borderRadius: BorderRadius.circular(30.r),
              border: Border.all(
                color: Colors.white.withAlpha((0.4 * 255).toInt()),
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.emoji_events, size: 18.sp, color: Colors.white),
                SizedBox(width: 6.w),
                Text(
                  '#$rank',
                  style: BebasTextStyles.whiteBold20.copyWith(fontSize: 22.sp),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\profile_shimmer_loading.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:shimmer/shimmer.dart';
import '../../../../core/utils/spacing.dart';

class ProfileShimmerLoading extends StatelessWidget {
  const ProfileShimmerLoading({super.key});

  @override
  Widget build(BuildContext context) {
    return Shimmer.fromColors(
      baseColor: Colors.grey.shade800,
      highlightColor: Colors.grey.shade600,
      period: const Duration(milliseconds: 1200),
      child: Column(
        children: [
          // ==== Profile Header Shimmer ====
          Container(
            width: double.infinity,
            padding: EdgeInsets.only(top: 32.h, bottom: 24.h),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [Colors.grey.shade900, Colors.black.withAlpha(150)],
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
              ),
              borderRadius: BorderRadius.only(
                bottomLeft: Radius.circular(24.r),
                bottomRight: Radius.circular(24.r),
              ),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Profile image shimmer
                Container(
                  width: 120.w,
                  height: 120.w,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade700,
                    shape: BoxShape.circle,
                  ),
                ),
                verticalSpacing(16),
                // Name shimmer
                Container(
                  width: 120.w,
                  height: 20.h,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade700,
                    borderRadius: BorderRadius.circular(8.r),
                  ),
                ),
                verticalSpacing(10),
                // Rank shimmer badge
                Container(
                  width: 80.w,
                  height: 26.h,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade700,
                    borderRadius: BorderRadius.circular(30.r),
                  ),
                ),
              ],
            ),
          ),

          verticalSpacing(20),

          // ==== Stats Grid Shimmer ====
          Padding(
            padding: EdgeInsets.symmetric(horizontal: 16.w),
            child: GridView.builder(
              itemCount: 6,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 3,
                mainAxisSpacing: 12.h,
                crossAxisSpacing: 12.w,
                childAspectRatio: 0.9,
              ),
              itemBuilder: (context, index) {
                return Container(
                  decoration: BoxDecoration(
                    color: Colors.grey.shade800,
                    borderRadius: BorderRadius.circular(14.r),
                  ),
                  padding: EdgeInsets.all(12.w),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Container(
                        width: 30.w,
                        height: 30.w,
                        decoration: BoxDecoration(
                          color: Colors.grey.shade700,
                          shape: BoxShape.circle,
                        ),
                      ),
                      verticalSpacing(8),
                      Container(
                        width: 40.w,
                        height: 14.h,
                        decoration: BoxDecoration(
                          color: Colors.grey.shade700,
                          borderRadius: BorderRadius.circular(4.r),
                        ),
                      ),
                      verticalSpacing(6),
                      Container(
                        width: 60.w,
                        height: 10.h,
                        decoration: BoxDecoration(
                          color: Colors.grey.shade700,
                          borderRadius: BorderRadius.circular(4.r),
                        ),
                      ),
                    ],
                  ),
                );
              },
            ),
          ),

          verticalSpacing(20),

          // ==== Logout Button Shimmer ====
          Container(
            width: 200.w,
            height: 44.h,
            decoration: BoxDecoration(
              color: Colors.grey.shade800,
              borderRadius: BorderRadius.circular(8.r),
            ),
          ),

          verticalSpacing(40),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\profile_success_state.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../logic/cubit/profile_cubit.dart';
import 'states_grid_view.dart';

import '../../../../core/models/players_states_model.dart';
import '../../../../core/models/user_data.dart';
import '../../../../core/utils/spacing.dart';
import '../../../../core/widgets/custom_text_button.dart';
import 'profile_header.dart';

class profileSuccessState extends StatelessWidget {
  const profileSuccessState({
    super.key,
    required this.playerProfile,
    required this.playerStats,
  });

  final UserData playerProfile;
  final PlayerStatsModel playerStats;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Stack(
          alignment: Alignment.topRight,
          children: [
            ProfileHeader(
              rank: playerStats.rank ?? 0,
              name: playerProfile.name,
              imageUrl: playerProfile.profileImageUrl,
            ),
          ],
        ),
        // Stats Grid
        StatsGridView(
          stats: [
            {
              'label': 'Points',
              'value': playerStats.points,
              'icon': Icons.star,
            },
            {
              'label': 'Matches',
              'value': playerStats.matchesPlayed,
              'icon': Icons.sports_esports,
            },
            {
              'label': 'Wins',
              'value': playerStats.wins,
              'icon': Icons.emoji_events,
            },
            {
              'label': 'Goals Scored',
              'value': playerStats.goalsScored,
              'icon': Icons.sports_soccer,
            },
            {
              'label': 'Goals received',
              'value': playerStats.goalsReceived,
              'icon': Icons.sports_soccer,
            },
            {
              'label': 'Goal Difference',
              'value': playerStats.goalDifference,
              'icon': Icons.sports_soccer,
            },
          ],
        ),
        verticalSpacing(16),

        // Logout Button with Confirmation Dialog
        SizedBox(
          width: 200.w,
          child: CustomTextButton(
            buttonText: 'Logout',
            backgroundColor: Colors.red,
            onPressed: () {
              _showLogoutDialog(context);
            },
          ),
        ),
        verticalSpacing(32),
      ],
    );
  }

  void _showLogoutDialog(BuildContext parentContext) {
    showDialog(
      context: parentContext,
      barrierDismissible: false,
      builder: (dialogContext) {
        return AlertDialog(
          backgroundColor: Colors.grey.shade900,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(20.r),
          ),
          title: Row(
            children: [
              const Icon(Icons.warning_amber_rounded, color: Colors.redAccent),
              SizedBox(width: 8.w),
              Text(
                'Confirm Logout',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18.sp,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          content: Text(
            'Are you sure you want to log out?',
            style: TextStyle(color: Colors.grey.shade300, fontSize: 14.sp),
          ),
          actionsPadding: EdgeInsets.symmetric(horizontal: 12.w, vertical: 8.h),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(dialogContext),
              child: Text(
                'Cancel',
                style: TextStyle(color: Colors.grey.shade400, fontSize: 14.sp),
              ),
            ),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.red,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10.r),
                ),
              ),
              onPressed: () {
                Navigator.pop(dialogContext);
                // ðŸ‘‡ Use the parentContext here
                parentContext.read<ProfileCubit>().logout();
              },
              child: Text(
                'Logout',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 14.sp,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\recent_matches_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:intl/intl.dart';

class RecentMatchesCard extends StatelessWidget {
  final List<Map<String, dynamic>> matches;

  const RecentMatchesCard({super.key, required this.matches});

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.symmetric(horizontal: 16.w, vertical: 8.h),
      padding: EdgeInsets.all(16.w),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [Colors.grey.shade900, Colors.blue.shade900.withAlpha((0.3* 255).toInt()),],
        ),
        borderRadius: BorderRadius.circular(16.r),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.2* 255).toInt()),
            blurRadius: 6.r,
            offset: Offset(0, 3.h),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Recent Matches',
            style: TextStyle(
              fontSize: 18.sp,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          SizedBox(height: 12.h),
          matches.isEmpty
              ? Text(
                  'No recent matches',
                  style: TextStyle(
                    fontSize: 14.sp,
                    color: Colors.grey.shade400,
                  ),
                )
              : Column(
                  children: matches.take(3).map((match) {
                    return Padding(
                      padding: EdgeInsets.only(bottom: 8.h),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'vs ${match['opponent']}',
                            style: TextStyle(
                              fontSize: 14.sp,
                              color: Colors.white,
                            ),
                          ),
                          Text(
                            '${match['score']}',
                            style: TextStyle(
                              fontSize: 14.sp,
                              fontWeight: FontWeight.bold,
                              color: Colors.blue.shade300,
                            ),
                          ),
                          Text(
                            DateFormat(
                              'MMM d',
                            ).format(match['date'] as DateTime),
                            style: TextStyle(
                              fontSize: 12.sp,
                              color: Colors.grey.shade400,
                            ),
                          ),
                        ],
                      ),
                    );
                  }).toList(),
                ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\states_grid_view.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

import 'state_card.dart';

class StatsGridView extends StatelessWidget {
  final List<Map<String, dynamic>> stats;

  const StatsGridView({super.key, required this.stats});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: 16.w, vertical: 6.h),
      child: GridView.builder(
        itemCount: stats.length,
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 3,
          mainAxisSpacing: 12.h,
          crossAxisSpacing: 12.w,
          childAspectRatio: 0.9,
        ),
        itemBuilder: (context, index) {
          final stat = stats[index];
          return StateCard(
            label: stat['label'] as String,
            value: stat['value'],
            icon: stat['icon'] as IconData,
          );
        },
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\state_card.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import '../../../../core/themes/app_colors.dart';
import '../../../../core/themes/app_texts_style.dart';
import '../../../../core/utils/spacing.dart';

class StateCard extends StatelessWidget {
  final String label;
  final dynamic value;
  final IconData icon;

  const StateCard({
    super.key,
    required this.label,
    required this.value,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 8.w, vertical: 10.h),
      alignment: Alignment.center,
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [Colors.grey.shade900, AppColors.lightDarkColor],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(14.r),
        border: Border.all(color: const Color(0x89DEDEDE), width: .5.w),
      ),
      child: FittedBox(
        fit: BoxFit.scaleDown,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 30.sp, color: AppColors.darkRedColor),
            verticalSpacing(6),
            Text(
              "$value",
              style: BebasTextStyles.whiteBold24,
              textAlign: TextAlign.center,
            ),
            verticalSpacing(4),
            Text(
              label,
              style: RobotoTextStyles.greyRegular14,
              textAlign: TextAlign.center,
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\widgets\user_card_info.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';

class UserInfoCard extends StatelessWidget {
  final int age;
  final String email;
  final String? phoneNumber;
  final bool isOwnProfile;

  const UserInfoCard({
    super.key,
    required this.age,
    required this.email,
    this.phoneNumber,
    this.isOwnProfile = false,
  });

  String _obscureEmail(String email) {
    final parts = email.split('@');
    if (parts[0].length <= 2) return email;
    final obscured = '${parts[0][0]}***@${parts[1]}';
    return obscured;
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: EdgeInsets.symmetric(horizontal: 16.w, vertical: 8.h),
      padding: EdgeInsets.all(16.w),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Colors.grey.shade900,
            Colors.blue.shade900.withAlpha((0.6 * 255).toInt()),
          ],
        ),
        borderRadius: BorderRadius.circular(16.r),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha((0.2 * 255).toInt()),
            blurRadius: 6.r,
            offset: Offset(0, 3.h),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildInfoRow(icon: Icons.cake, label: 'Age', value: '$age years'),
          SizedBox(height: 8.h),
          _buildInfoRow(
            icon: Icons.email,
            label: 'Email',
            value: isOwnProfile ? email : _obscureEmail(email),
          ),
          if (phoneNumber != null && isOwnProfile) ...[
            SizedBox(height: 8.h),
            _buildInfoRow(
              icon: Icons.phone,
              label: 'Phone',
              value: phoneNumber!,
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoRow({
    required IconData icon,
    required String label,
    required String value,
  }) {
    return Row(
      children: [
        Icon(icon, size: 20.sp, color: Colors.blue.shade300),
        SizedBox(width: 12.w),
        Text(
          '$label: ',
          style: TextStyle(fontSize: 14.sp, color: Colors.grey.shade400),
        ),
        Expanded(
          child: Text(
            value,
            style: TextStyle(fontSize: 14.sp, color: Colors.white),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\lib\features\profile\ui\profile_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';

import '../../../core/router/route_paths.dart';
import '../../../core/themes/app_colors.dart';
import '../../../core/utils/functions/refresh_page.dart';
import '../../../core/widgets/custom_app_bar.dart';
import '../logic/cubit/profile_cubit.dart';
import 'widgets/profile_shimmer_loading.dart';
import 'widgets/profile_success_state.dart';

class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocListener<ProfileCubit, ProfileState>(
      listener: (context, state) {
        if (state is ProfileLoggedOut) {
          context.go(Routes.onBoardingScreen);
        }
      },
      child: Scaffold(
        body: Column(
          children: [
            const CustomAppBar(title: 'Profile'),
            Expanded(
              child: BlocBuilder<ProfileCubit, ProfileState>(
                builder: (context, state) {
                  if (state is ProfileLoading) {
                    return const ProfileShimmerLoading();
                  } else if (state is ProfileSuccess) {
                    final playerProfile = state.player.user;
                    final playerStats = state.player.stats;

                    return RefreshIndicator(
                      onRefresh: () => onRefresh(context),
                      backgroundColor: AppColors.lightDarkColor,
                      color: Colors.white,
                      child: SingleChildScrollView(
                        physics: const AlwaysScrollableScrollPhysics(),
                        child: profileSuccessState(
                          playerProfile: playerProfile,
                          playerStats: playerStats,
                        ),
                      ),
                    );
                  } else if (state is ProfileFailure) {
                    return Center(child: Text(state.message));
                  }

                  return const SizedBox.shrink();
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\lib\firebase_options.dart =====
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyASjHBypJQc_I87Y-90gG_eKj26c_09XSY',
    appId: '1:312322499437:android:4142929715cf2e7df43064',
    messagingSenderId: '312322499437',
    projectId: 'im-legends',
    storageBucket: 'im-legends.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDFmLQoenYZNlUforvRkugOR5VAnI3R8Jo',
    appId: '1:312322499437:ios:bcb9a1960afeafbbf43064',
    messagingSenderId: '312322499437',
    projectId: 'im-legends',
    storageBucket: 'im-legends.firebasestorage.app',
    iosBundleId: 'com.example.imLegends',
  );
}
===== C:\flutter_apps\im_legends\lib\im_legends_app.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:go_router/go_router.dart';
import 'core/utils/app_assets.dart';

class IMLegendsApp extends StatelessWidget {
  const IMLegendsApp({super.key, required this.router});

  final GoRouter router;

  @override
  Widget build(BuildContext context) {
    return ScreenUtilInit(
      designSize: const Size(393, 852),
      minTextAdapt: true,
      builder: (context, child) {
        return MaterialApp.router(
          debugShowCheckedModeBanner: false,
          title: 'IM Legends App',
          theme: ThemeData(
            scaffoldBackgroundColor: const Color(0xFF000000),
            fontFamily: AppAssets.fontRoboto,
          ),
          routerConfig: router, // Use GoRouter here
        );
      },
    );
  }
}
===== C:\flutter_apps\im_legends\lib\main_development.dart =====
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'core/di/dependency_injection.dart';
import 'core/router/app_router.dart';
import 'core/utils/shared_prefs.dart';
import 'features/notification/data/service/local_notifications.dart';
import 'features/notification/data/service/firebase_notifications_service.dart';
import 'firebase_options.dart';
import 'im_legends_app.dart';

/// === Initialize core services ===
Future<void> _initServices() async {
  // Firebase
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Local notifications
  await LocalNotificationService().initialize();

  // Supabase
  await Supabase.initialize(
    url: 'https://flutiryhpfdlpizyxqix.supabase.co',
    anonKey:
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZsdXRpcnlocGZkbHBpenl4cWl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxNTQ3NzIsImV4cCI6MjA3MTczMDc3Mn0.UhojXOtOrnvbwDKvyBVZn3Cl1gdUkr-NYuGBLQXIRi0',
  );

  // Dependency Injection
  setupGetIt();
}

/// === Main entry point ===
Future<void> main() async {
  debugProfileBuildsEnabled = true;
  WidgetsFlutterBinding.ensureInitialized();

  // Ensure screen util sizing
  await ScreenUtil.ensureScreenSize();

  // Shared Preferences
  await SharedPrefStorage.instance.init();

  // Register background handler BEFORE runApp
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  // Init services
  await _initServices();

  // Run app
  runApp(IMLegendsApp(router: router));
  // flutter run --release --flavor development --target lib/main_development.dart
}
===== C:\flutter_apps\im_legends\lib\main_production.dart =====
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import 'core/di/dependency_injection.dart';
import 'core/router/app_router.dart' as AppRouter;
import 'core/utils/shared_prefs.dart';
import 'features/notification/data/service/firebase_notifications_service.dart';
import 'features/notification/data/service/local_notifications.dart';
import 'firebase_options.dart';
import 'im_legends_app.dart';

/// === Initialize core services ===
Future<void> _initServices() async {
  // Firebase
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Local notifications
  await LocalNotificationService().initialize();

  // Supabase
  await Supabase.initialize(
    url: 'https://flutiryhpfdlpizyxqix.supabase.co',
    anonKey:
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZsdXRpcnlocGZkbHBpenl4cWl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxNTQ3NzIsImV4cCI6MjA3MTczMDc3Mn0.UhojXOtOrnvbwDKvyBVZn3Cl1gdUkr-NYuGBLQXIRi0',
  );

  // Dependency Injection
  setupGetIt();
}

/// === Main entry point ===
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Ensure screen util sizing
  await ScreenUtil.ensureScreenSize();

  // Shared Preferences
  await SharedPrefStorage.instance.init();

  // Register background handler BEFORE runApp
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  // Init services
  await _initServices();

  // Run app
  runApp(IMLegendsApp(router: AppRouter.router));
}

// flutter run --release --flavor production --target lib/main_production.dart
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\app_links_linux\lib\app_links_linux.dart =====
import 'dart:async';

import 'package:app_links_platform_interface/app_links_platform_interface.dart';
import 'package:gtk/gtk.dart';

class AppLinksPluginLinux extends AppLinksPlatform {
  static void registerWith() {
    AppLinksPlatform.instance = AppLinksPluginLinux();
  }

  StreamController<String>? _controller;
  GtkApplicationNotifier? _notifier;
  String? _initialLink;
  bool _initialLinkSent = false;
  String? _latestLink;

  // Initialize the plugin.
  // This can't be done in the constructor because
  // binary messenger hasn't been initialized at this stage.
  void _init() {
    _controller ??= StreamController.broadcast()..onListen = _onListen;

    if (_notifier == null) {
      _notifier = GtkApplicationNotifier();
      _notifier?.addCommandLineListener((args) {
        if (args.isNotEmpty) {
          _send(args.first);
        }
      });
    }
  }

  @override
  Future<Uri?> getInitialLink() async {
    _init();

    if (_initialLink case final link?) {
      return Uri.tryParse(link);
    }
    return null;
  }

  @override
  Future<String?> getInitialLinkString() async {
    _init();

    return _initialLink;
  }

  @override
  Future<Uri?> getLatestLink() async {
    _init();

    if (_latestLink case final link?) {
      return Uri.tryParse(link);
    }
    return null;
  }

  @override
  Future<String?> getLatestLinkString() async {
    _init();
    return _latestLink;
  }

  @override
  Stream<String> get stringLinkStream {
    _init();
    return _controller!.stream;
  }

  @override
  Stream<Uri> get uriLinkStream {
    _init();

    return _controller!.stream
        .where((uri) => Uri.tryParse(uri) != null)
        .map(Uri.parse);
  }

  void _onListen() {
    if (!_initialLinkSent && _initialLink != null) {
      _initialLinkSent = true;
      _controller?.add(_initialLink!);
    }
  }

  void _send(String uri) {
    if (uri.isNotEmpty) {
      _latestLink = uri;
      _initialLink ??= uri;

      if (_controller?.hasListener ?? false) {
        _initialLinkSent = true;
        _controller?.add(uri);
      }
    }
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\get_directory_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a directory using `getDirectoryPath`,
///  then displays the selected directory in a dialog.
class GetDirectoryPage extends StatelessWidget {
  /// Default Constructor
  const GetDirectoryPage({super.key});

  Future<void> _getDirectoryPath(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final String? directoryPath =
        await FileSelectorPlatform.instance.getDirectoryPath(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPath == null) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(directoryPath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to ask user to choose a directory'),
              onPressed: () => _getDirectoryPath(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPath, {super.key});

  /// The path selected in the dialog.
  final String directoryPath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directory'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPath),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\get_multiple_directories_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select one or more directories using `getDirectoryPaths`,
/// then displays the selected directories in a dialog.
class GetMultipleDirectoriesPage extends StatelessWidget {
  /// Default Constructor
  const GetMultipleDirectoriesPage({super.key});

  Future<void> _getDirectoryPaths(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final List<String> directoryPaths =
        await FileSelectorPlatform.instance.getDirectoryPaths(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPaths.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) =>
            TextDisplay(directoryPaths.join('\n')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select multiple directories'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text(
                  'Press to ask user to choose multiple directories'),
              onPressed: () => _getDirectoryPaths(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoriesPaths, {super.key});

  /// The path selected in the dialog.
  final String directoriesPaths;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directories'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoriesPaths),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\home_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Home Page of the application.
class HomePage extends StatelessWidget {
  /// Default Constructor
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final ButtonStyle style = ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('File Selector Demo Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: style,
              child: const Text('Open a text file'),
              onPressed: () => Navigator.pushNamed(context, '/open/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open an image'),
              onPressed: () => Navigator.pushNamed(context, '/open/image'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open multiple images'),
              onPressed: () => Navigator.pushNamed(context, '/open/images'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Save a file'),
              onPressed: () => Navigator.pushNamed(context, '/save/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directory dialog'),
              onPressed: () => Navigator.pushNamed(context, '/directory'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directories dialog'),
              onPressed: () =>
                  Navigator.pushNamed(context, '/multi-directories'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

import 'get_directory_page.dart';
import 'get_multiple_directories_page.dart';
import 'home_page.dart';
import 'open_image_page.dart';
import 'open_multiple_images_page.dart';
import 'open_text_page.dart';
import 'save_text_page.dart';

void main() {
  runApp(const MyApp());
}

/// MyApp is the Main Application.
class MyApp extends StatelessWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'File Selector Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const HomePage(),
      routes: <String, WidgetBuilder>{
        '/open/image': (BuildContext context) => const OpenImagePage(),
        '/open/images': (BuildContext context) =>
            const OpenMultipleImagesPage(),
        '/open/text': (BuildContext context) => const OpenTextPage(),
        '/save/text': (BuildContext context) => SaveTextPage(),
        '/directory': (BuildContext context) => const GetDirectoryPage(),
        '/multi-directories': (BuildContext context) =>
            const GetMultipleDirectoriesPage()
      },
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\open_image_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select an image file using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenImagePage extends StatelessWidget {
  /// Default Constructor
  const OpenImagePage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'images',
      extensions: <String>['jpg', 'png'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String filePath = file.path;

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => ImageDisplay(fileName, filePath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open an image'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open an image file(png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays an image in a dialog.
class ImageDisplay extends StatelessWidget {
  /// Default Constructor.
  const ImageDisplay(this.fileName, this.filePath, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The path to the selected file.
  final String filePath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: kIsWeb ? Image.network(filePath) : Image.file(File(filePath)),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\open_multiple_images_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select multiple image files using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenMultipleImagesPage extends StatelessWidget {
  /// Default Constructor
  const OpenMultipleImagesPage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup jpgsTypeGroup = XTypeGroup(
      label: 'JPEGs',
      extensions: <String>['jpg', 'jpeg'],
    );
    const XTypeGroup pngTypeGroup = XTypeGroup(
      label: 'PNGs',
      extensions: <String>['png'],
    );
    final List<XFile> files = await FileSelectorPlatform.instance
        .openFiles(acceptedTypeGroups: <XTypeGroup>[
      jpgsTypeGroup,
      pngTypeGroup,
    ]);
    if (files.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => MultipleImagesDisplay(files),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open multiple images'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open multiple images (png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class MultipleImagesDisplay extends StatelessWidget {
  /// Default Constructor.
  const MultipleImagesDisplay(this.files, {super.key});

  /// The files containing the images.
  final List<XFile> files;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Gallery'),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: Center(
        child: Row(
          children: <Widget>[
            ...files.map(
              (XFile file) => Flexible(
                  child: kIsWeb
                      ? Image.network(file.path)
                      : Image.file(File(file.path))),
            )
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\open_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a text file using `openFile`, then
/// displays its contents in a dialog.
class OpenTextPage extends StatelessWidget {
  /// Default Constructor
  const OpenTextPage({super.key});

  Future<void> _openTextFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'text',
      extensions: <String>['txt', 'json'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String fileContent = await file.readAsString();

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(fileName, fileContent),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open a text file (json, txt)'),
              onPressed: () => _openTextFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Default Constructor.
  const TextDisplay(this.fileName, this.fileContent, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The contents of the text file.
  final String fileContent;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(fileContent),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\example\lib\save_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:typed_data';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a save location using `getSavePath`,
/// then writes text to a file at that location.
class SaveTextPage extends StatelessWidget {
  /// Default Constructor
  SaveTextPage({super.key});

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  Future<void> _saveFile() async {
    final String fileName = _nameController.text;
    final FileSaveLocation? result =
        await FileSelectorPlatform.instance.getSaveLocation(
      options: SaveDialogOptions(suggestedName: fileName),
    );
    // Operation was canceled by the user.
    if (result == null) {
      return;
    }
    final String text = _contentController.text;
    final Uint8List fileData = Uint8List.fromList(text.codeUnits);
    const String fileMimeType = 'text/plain';
    final XFile textFile =
        XFile.fromData(fileData, mimeType: fileMimeType, name: fileName);
    await textFile.saveTo(result.path);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Save text into a file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: '(Optional) Suggest File Name',
                ),
              ),
            ),
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _contentController,
                decoration: const InputDecoration(
                  hintText: 'Enter File Contents',
                ),
              ),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              onPressed: _saveFile,
              child: const Text('Press to save a text file'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\lib\src\messages.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

/// A Pigeon representation of the GTK_FILE_CHOOSER_ACTION_* options.
enum PlatformFileChooserActionType {
  open,
  chooseDirectory,
  save,
}

/// A Pigeon representation of the Linux portion of an `XTypeGroup`.
class PlatformTypeGroup {
  PlatformTypeGroup({
    this.label = '',
    this.extensions = const <String>[],
    this.mimeTypes = const <String>[],
  });

  String label;

  List<String> extensions;

  List<String> mimeTypes;

  Object encode() {
    return <Object?>[
      label,
      extensions,
      mimeTypes,
    ];
  }

  static PlatformTypeGroup decode(Object result) {
    result as List<Object?>;
    return PlatformTypeGroup(
      label: result[0]! as String,
      extensions: (result[1] as List<Object?>?)!.cast<String>(),
      mimeTypes: (result[2] as List<Object?>?)!.cast<String>(),
    );
  }
}

/// Options for GKT file chooser.
///
/// These correspond to gtk_file_chooser_set_* options.
class PlatformFileChooserOptions {
  PlatformFileChooserOptions({
    this.allowedFileTypes,
    this.currentFolderPath,
    this.currentName,
    this.acceptButtonLabel,
    this.selectMultiple,
  });

  List<PlatformTypeGroup>? allowedFileTypes;

  String? currentFolderPath;

  String? currentName;

  String? acceptButtonLabel;

  /// Whether to allow multiple file selection.
  ///
  /// Nullable because it does not apply to the "save" action.
  bool? selectMultiple;

  Object encode() {
    return <Object?>[
      allowedFileTypes,
      currentFolderPath,
      currentName,
      acceptButtonLabel,
      selectMultiple,
    ];
  }

  static PlatformFileChooserOptions decode(Object result) {
    result as List<Object?>;
    return PlatformFileChooserOptions(
      allowedFileTypes:
          (result[0] as List<Object?>?)?.cast<PlatformTypeGroup>(),
      currentFolderPath: result[1] as String?,
      currentName: result[2] as String?,
      acceptButtonLabel: result[3] as String?,
      selectMultiple: result[4] as bool?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is PlatformFileChooserActionType) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is PlatformTypeGroup) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PlatformFileChooserOptions) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null
            ? null
            : PlatformFileChooserActionType.values[value];
      case 130:
        return PlatformTypeGroup.decode(readValue(buffer)!);
      case 131:
        return PlatformFileChooserOptions.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileSelectorApi {
  /// Constructor for [FileSelectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileSelectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Shows an file chooser with the given [type] and [options], returning the
  /// list of selected paths.
  ///
  /// An empty list corresponds to a cancelled selection.
  Future<List<String>> showFileChooser(PlatformFileChooserActionType type,
      PlatformFileChooserOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_linux.FileSelectorApi.showFileChooser$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[type, options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!.cast<String>();
    }
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\lib\file_selector_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

import 'src/messages.g.dart';

/// An implementation of [FileSelectorPlatform] for Linux.
class FileSelectorLinux extends FileSelectorPlatform {
  /// Creates a new plugin implementation instance.
  FileSelectorLinux({
    @visibleForTesting FileSelectorApi? api,
  }) : _hostApi = api ?? FileSelectorApi();

  final FileSelectorApi _hostApi;

  /// Registers the Linux implementation.
  static void registerWith() {
    FileSelectorPlatform.instance = FileSelectorLinux();
  }

  @override
  Future<XFile?> openFile({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.open,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: false,
        ));
    return paths.isEmpty ? null : XFile(paths.first);
  }

  @override
  Future<List<XFile>> openFiles({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.open,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: true,
        ));
    return paths.map((String path) => XFile(path)).toList();
  }

  @override
  Future<String?> getSavePath({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) async {
    final FileSaveLocation? location = await getSaveLocation(
        acceptedTypeGroups: acceptedTypeGroups,
        options: SaveDialogOptions(
          initialDirectory: initialDirectory,
          suggestedName: suggestedName,
          confirmButtonText: confirmButtonText,
        ));
    return location?.path;
  }

  @override
  Future<FileSaveLocation?> getSaveLocation({
    List<XTypeGroup>? acceptedTypeGroups,
    SaveDialogOptions options = const SaveDialogOptions(),
  }) async {
    // TODO(stuartmorgan): Add the selected type group here and return it. See
    // https://github.com/flutter/flutter/issues/107093
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.save,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: options.initialDirectory,
          currentName: options.suggestedName,
          acceptButtonLabel: options.confirmButtonText,
        ));
    return paths.isEmpty ? null : FileSaveLocation(paths.first);
  }

  @override
  Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.chooseDirectory,
        PlatformFileChooserOptions(
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: false,
        ));
    return paths.isEmpty ? null : paths.first;
  }

  @override
  Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    return _hostApi.showFileChooser(
        PlatformFileChooserActionType.chooseDirectory,
        PlatformFileChooserOptions(
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: true,
        ));
  }
}

List<PlatformTypeGroup>? _platformTypeGroupsFromXTypeGroups(
    List<XTypeGroup>? groups) {
  return groups?.map(_platformTypeGroupFromXTypeGroup).toList();
}

PlatformTypeGroup _platformTypeGroupFromXTypeGroup(XTypeGroup group) {
  final String label = group.label ?? '';
  if (group.allowsAny) {
    return PlatformTypeGroup(
      label: label,
      extensions: <String>['*'],
    );
  }
  if ((group.extensions?.isEmpty ?? true) &&
      (group.mimeTypes?.isEmpty ?? true)) {
    throw ArgumentError('Provided type group $group does not allow '
        'all files, but does not set any of the Linux-supported filter '
        'categories. "extensions" or "mimeTypes" must be non-empty for Linux '
        'if anything is non-empty.');
  }
  return PlatformTypeGroup(
      label: label,
      // Covert to GtkFileFilter's *.<extension> format.
      extensions: group.extensions
              ?.map((String extension) => '*.$extension')
              .toList() ??
          <String>[],
      mimeTypes: group.mimeTypes ?? <String>[]);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\pigeons\messages.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  input: 'pigeons/messages.dart',
  gobjectHeaderOut: 'linux/messages.g.h',
  gobjectSourceOut: 'linux/messages.g.cc',
  gobjectOptions: GObjectOptions(module: 'Ffs'),
  dartOut: 'lib/src/messages.g.dart',
  copyrightHeader: 'pigeons/copyright.txt',
))

/// A Pigeon representation of the GTK_FILE_CHOOSER_ACTION_* options.
enum PlatformFileChooserActionType { open, chooseDirectory, save }

/// A Pigeon representation of the Linux portion of an `XTypeGroup`.
class PlatformTypeGroup {
  const PlatformTypeGroup({
    this.label = '',
    this.extensions = const <String>[],
    this.mimeTypes = const <String>[],
  });

  final String label;
  final List<String> extensions;
  final List<String> mimeTypes;
}

/// Options for GKT file chooser.
///
/// These correspond to gtk_file_chooser_set_* options.
class PlatformFileChooserOptions {
  PlatformFileChooserOptions({
    required this.allowedFileTypes,
    required this.currentFolderPath,
    required this.currentName,
    required this.acceptButtonLabel,
    this.selectMultiple,
  });

  final List<PlatformTypeGroup>? allowedFileTypes;
  final String? currentFolderPath;
  final String? currentName;
  final String? acceptButtonLabel;

  /// Whether to allow multiple file selection.
  ///
  /// Nullable because it does not apply to the "save" action.
  final bool? selectMultiple;
}

@HostApi(dartHostTestHandler: 'TestFileSelectorApi')
abstract class FileSelectorApi {
  /// Shows an file chooser with the given [type] and [options], returning the
  /// list of selected paths.
  ///
  /// An empty list corresponds to a cancelled selection.
  List<String> showFileChooser(
      PlatformFileChooserActionType type, PlatformFileChooserOptions options);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\file_selector_linux\test\file_selector_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:file_selector_linux/src/messages.g.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late FakeFileSelectorApi api;
  late FileSelectorLinux plugin;

  setUp(() {
    api = FakeFileSelectorApi();
    plugin = FileSelectorLinux(api: api);
  });

  test('registers instance', () {
    FileSelectorLinux.registerWith();
    expect(FileSelectorPlatform.instance, isA<FileSelectorLinux>());
  });

  group('openFile', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect((await plugin.openFile())?.path, path);

      expect(api.passedType, PlatformFileChooserActionType.open);
      expect(api.passedOptions?.selectMultiple, false);
    });

    test('handles empty return for cancel', () async {
      api.result = <String>[];

      expect(await plugin.openFile(), null);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.openFile(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.openFile(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('openFiles', () {
    test('passes the core flags correctly', () async {
      api.result = <String>['/foo/bar', 'baz'];

      final List<XFile> files = await plugin.openFiles();

      expect(files.length, 2);
      expect(files[0].path, api.result[0]);
      expect(files[1].path, api.result[1]);

      expect(api.passedType, PlatformFileChooserActionType.open);
      expect(api.passedOptions?.selectMultiple, true);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.openFiles(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.openFiles(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getSaveLocation', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect((await plugin.getSaveLocation())?.path, path);

      expect(api.passedType, PlatformFileChooserActionType.save);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(initialDirectory: path));

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(confirmButtonText: button));

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getSavePath (deprecated)', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect(await plugin.getSavePath(), path);

      expect(api.passedType, PlatformFileChooserActionType.save);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSavePath(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getSavePath(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.getSavePath(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getDirectoryPath', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect(await plugin.getDirectoryPath(), path);

      expect(api.passedType, PlatformFileChooserActionType.chooseDirectory);
      expect(api.passedOptions?.selectMultiple, false);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getDirectoryPath(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Select Folder';
      await plugin.getDirectoryPath(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });
  });

  group('getDirectoryPaths', () {
    test('passes the core flags correctly', () async {
      api.result = <String>['/foo/bar', 'baz'];

      expect(await plugin.getDirectoryPaths(), api.result);

      expect(api.passedType, PlatformFileChooserActionType.chooseDirectory);
      expect(api.passedOptions?.selectMultiple, true);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getDirectoryPaths(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Select one or mode folders';
      await plugin.getDirectoryPaths(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('passes multiple flag correctly', () async {
      await plugin.getDirectoryPaths();

      expect(api.passedOptions?.selectMultiple, true);
    });
  });
}

/// Fake implementation that stores arguments and provides a canned response.
class FakeFileSelectorApi implements FileSelectorApi {
  List<String> result = <String>[];
  PlatformFileChooserActionType? passedType;
  PlatformFileChooserOptions? passedOptions;

  @override
  Future<List<String>> showFileChooser(PlatformFileChooserActionType type,
      PlatformFileChooserOptions options) async {
    passedType = type;
    passedOptions = options;
    return result;
  }

  @override
  // ignore: non_constant_identifier_names
  BinaryMessenger? get pigeonVar_binaryMessenger => null;

  @override
  // ignore: non_constant_identifier_names
  String get pigeonVar_messageChannelSuffix => '';
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\capabilities.dart =====
import 'package:flutter/foundation.dart';

import 'initialization_settings.dart';
import 'notification_details.dart';
import 'sound.dart';

/// Represents capabilities, implemented by the Linux notification server.
@immutable
class LinuxServerCapabilities {
  /// Constructs an instance of [LinuxServerCapabilities]
  const LinuxServerCapabilities({
    required this.otherCapabilities,
    required this.body,
    required this.bodyHyperlinks,
    required this.bodyImages,
    required this.bodyMarkup,
    required this.iconMulti,
    required this.iconStatic,
    required this.persistence,
    required this.sound,
    required this.actions,
    required this.actionIcons,
  });

  /// Set of unknown capabilities.
  /// Vendor-specific capabilities may be specified as long as they start with
  /// `x-vendor`. For example, `x-gnome-foo-cap`. Capability names must not
  /// contain spaces. They are limited to alpha-numeric characters and
  /// dashes ("-")
  final Set<String> otherCapabilities;

  /// Supports body text. Some implementations may only show the title
  /// (for instance, onscreen displays, marquee/scrollers).
  final bool body;

  /// The server supports hyperlinks in the notifications.
  final bool bodyHyperlinks;

  /// The server supports images in the notifications.
  final bool bodyImages;

  /// Supports markup in the body text. The markup is XML-based, and consists
  /// of a small subset of HTML along with a few additional tags.
  /// For more information, see Desktop Notifications Specification https://specifications.freedesktop.org/notification-spec/latest/ar01s04.html
  /// If marked up text is sent to a server
  /// that does not give this cap, the markup will show through as regular text
  /// so must be stripped clientside.
  final bool bodyMarkup;

  /// The server will render an animation of all the frames in a given
  /// image array. The client may still specify multiple frames even if this
  /// cap and/or [iconStatic] is missing, however the server is free to ignore
  /// them and use only the primary frame.
  final bool iconMulti;

  /// Supports display of exactly 1 frame of any given image array.
  /// This value is mutually exclusive with [iconMulti], it is a protocol
  /// error for the server to specify both.
  final bool iconStatic;

  /// The server supports persistence of notifications. Notifications will be
  /// retained until they are acknowledged or removed by the user or
  /// recalled by the sender. The presence of this capability allows clients to
  /// depend on the server to ensure a notification is seen and eliminate
  /// the need for the client to display a reminding function
  /// (such as a status icon) of its own.
  final bool persistence;

  /// The server supports sounds on notifications. If returned, the server must
  /// support the [AssetsLinuxSound], [LinuxNotificationDetails.suppressSound]
  /// and [LinuxInitializationSettings.defaultSuppressSound].
  final bool sound;

  /// The server will provide the specified actions to the user.
  /// Even if this capability is missing, actions may still be specified by the
  /// client, however the server is free to ignore them.
  final bool actions;

  /// Supports using icons instead of text for displaying actions.
  /// Using icons for actions must be enabled on a per-notification basis using
  /// [LinuxNotificationDetails.actionKeyAsIconName].
  final bool actionIcons;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }

    return other is LinuxServerCapabilities &&
        setEquals(other.otherCapabilities, otherCapabilities) &&
        other.body == body &&
        other.bodyHyperlinks == bodyHyperlinks &&
        other.bodyImages == bodyImages &&
        other.bodyMarkup == bodyMarkup &&
        other.iconMulti == iconMulti &&
        other.iconStatic == iconStatic &&
        other.persistence == persistence &&
        other.sound == sound &&
        other.actions == actions &&
        other.actionIcons == actionIcons;
  }

  @override
  int get hashCode =>
      otherCapabilities.hashCode ^
      body.hashCode ^
      bodyHyperlinks.hashCode ^
      bodyImages.hashCode ^
      bodyMarkup.hashCode ^
      iconMulti.hashCode ^
      iconStatic.hashCode ^
      persistence.hashCode ^
      sound.hashCode ^
      actions.hashCode ^
      actionIcons.hashCode;

  /// Creates a copy of this object,
  /// but with the given fields replaced with the new values.
  LinuxServerCapabilities copyWith({
    Set<String>? otherCapabilities,
    bool? body,
    bool? bodyHyperlinks,
    bool? bodyImages,
    bool? bodyMarkup,
    bool? iconMulti,
    bool? iconStatic,
    bool? persistence,
    bool? sound,
    bool? actions,
    bool? actionIcons,
  }) =>
      LinuxServerCapabilities(
        otherCapabilities: otherCapabilities ?? this.otherCapabilities,
        body: body ?? this.body,
        bodyHyperlinks: bodyHyperlinks ?? this.bodyHyperlinks,
        bodyImages: bodyImages ?? this.bodyImages,
        bodyMarkup: bodyMarkup ?? this.bodyMarkup,
        iconMulti: iconMulti ?? this.iconMulti,
        iconStatic: iconStatic ?? this.iconStatic,
        persistence: persistence ?? this.persistence,
        sound: sound ?? this.sound,
        actions: actions ?? this.actions,
        actionIcons: actionIcons ?? this.actionIcons,
      );

  @override
  String toString() => 'LinuxServerCapabilities(otherCapabilities: '
      '$otherCapabilities, body: $body, bodyHyperlinks: $bodyHyperlinks, '
      'bodyImages: $bodyImages, bodyMarkup: $bodyMarkup, '
      'iconMulti: $iconMulti, iconStatic: $iconStatic, '
      'persistence: $persistence, sound: $sound, actions: $actions, '
      'actionIcons: $actionIcons)';
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\enums.dart =====
import 'icon.dart';

/// Categories of notifications.
///
/// Corresponds to https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html#categories
enum LinuxNotificationCategory {
  /// A generic device-related notification
  /// that doesn't fit into any other category.
  device('device'),

  /// A device, such as a USB device, was added to the system.
  deviceAdded('device.added'),

  /// A device had some kind of error.
  deviceError('device.error'),

  /// A device, such as a USB device, was removed from the system.
  deviceRemoved('device.removed'),

  /// A generic e-mail-related notification
  /// that doesn't fit into any other category.
  email('email'),

  /// A new e-mail notification.
  emailArrived('email.arrived'),

  /// A notification stating that an e-mail has bounced.
  emailBounced('email.bounced'),

  /// A generic instant message-related notification
  /// that doesn't fit into any other
  im('im'),

  /// An instant message error notification.
  imError('im.error'),

  /// A received instant message notification.
  imReceived('im.received'),

  /// A generic network notification that
  /// doesn't fit into any other category.
  network('network'),

  /// A network connection notification,
  /// such as successful sign-on to a network service.
  /// This should not be confused with
  /// [deviceAdded] for new network devices.
  networkConnected('network.connected'),

  /// A network disconnected notification.
  /// This should not be confused with [deviceRemoved]
  /// for disconnected network devices.
  networkDisconnected('network.disconnected'),

  /// A network-related or connection-related error.
  networkError('network.error'),

  /// A generic presence change notification
  /// that doesn't fit into any other category, such as going away or idle.
  presence('presence'),

  /// An offline presence change notification.
  presenceOffile('presence.offline'),

  /// An online presence change notification.
  presenceOnline('presence.online'),

  /// A generic file transfer or download notification
  /// that doesn't fit into any other category.
  transfer('transfer'),

  /// A file transfer or download complete notification.
  transferComplete('transfer.complete'),

  /// A file transfer or download error.
  transferError('transfer.error');

  /// Constructs an instance of [LinuxNotificationCategory]
  /// with a given [name] of category.
  const LinuxNotificationCategory(this.name);

  /// Name of category.
  final String name;
}

/// The urgency level of the Linux notification.
///
/// Corresponds to https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html#urgency-levels
enum LinuxNotificationUrgency {
  /// Low urgency. Used for unimportant notifications.
  low,

  /// Normal urgency. Used for most standard notifications.
  normal,

  /// Critical urgency. Used for very important notifications.
  critical
}

/// Specifies the Linux notification icon type.
enum LinuxIconType {
  /// Icon from the Flutter Assets directory, see [AssetsLinuxIcon]
  assets,

  /// Icon from a raw image data bytes, see [ByteDataLinuxIcon].
  byteData,

  /// System theme icon, see [ThemeLinuxIcon].
  theme,

  /// Icon located at the path in the file system, see [FilePathLinuxIcon].
  filePath,
}

/// Specifies the Linux notification sound type.
enum LinuxSoundType {
  /// Sound from the Flutter Assets directory, see [AssetsLinuxSound]
  assets,

  /// System theme sound, see [ThemeLinuxSound].
  theme,
}

/// Represents the notification hint value type.
enum LinuxHintValueType {
  /// Ordered list of values of the same type.
  array,

  /// Boolean value.
  boolean,

  /// Unsigned 8 bit value.
  byte,

  /// Associative array of values.
  dict,

  /// 64-bit floating point value.
  double,

  /// Signed 16-bit integer.
  int16,

  /// Signed 32-bit integer.
  int32,

  /// Signed 64-bit integer.
  int64,

  /// Unicode text string.
  string,

  /// Value that contains a fixed set of other values.
  struct,

  /// Unsigned 16-bit integer.
  uint16,

  /// Unsigned 32-bit integer.
  uint32,

  /// Unsigned 64-bit integer.
  uint64,

  /// Value that contains any type.
  variant,
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\hint.dart =====
import 'package:flutter/foundation.dart';

import 'enums.dart';

/// Represents a custom Linux notification hint.
/// Hints are a way to provide extra data to a notification server that
/// the server may be able to make use of.
/// For more information, please see Desktop Notifications Specification https://specifications.freedesktop.org/notification-spec/latest/ar01s08.html
@optionalTypeArgs
class LinuxNotificationCustomHint<T> {
  /// Constructs an instance of [LinuxNotificationCustomHint].
  const LinuxNotificationCustomHint(this.name, this.value);

  /// Name of this hint.
  /// The vendor hint name should be in the form of `x-vendor-name`.
  final String name;

  /// Value corresponding to the hint.
  final LinuxHintValue<T> value;
}

/// Represents abstract Linux notification hint value.
@optionalTypeArgs
abstract class LinuxHintValue<T> {
  /// Specifies the notification hint value type.
  LinuxHintValueType get type;

  /// Value, corresponding to the Dart type system.
  T get value;
}

/// Ordered list of values of the same type.
class LinuxHintArrayValue<T extends LinuxHintValue>
    implements LinuxHintValue<List<T>> {
  /// Constructs an instance of [LinuxHintArrayValue].
  const LinuxHintArrayValue(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.array;

  @override
  final List<T> value;
}

/// Boolean value.
class LinuxHintBoolValue extends LinuxHintValue<bool> {
  /// Constructs an instance of [LinuxHintBoolValue].
  LinuxHintBoolValue(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.boolean;

  @override
  final bool value;
}

/// Unsigned 8 bit value.
class LinuxHintByteValue extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintByteValue].
  LinuxHintByteValue(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.byte;

  @override
  final int value;
}

/// Associative array of values.
class LinuxHintDictValue<K extends LinuxHintValue, V extends LinuxHintValue>
    extends LinuxHintValue<Map<K, V>> {
  /// Constructs an instance of [LinuxHintDictValue].
  LinuxHintDictValue(this.value);

  /// Constructs an instance of [LinuxHintDictValue].
  LinuxHintDictValue.stringVariant(Map<String, V> value)
      : value = value.map(
          (String key, V value) => MapEntry<K, V>(
            LinuxHintStringValue(key) as K,
            value,
          ),
        );

  @override
  LinuxHintValueType get type => LinuxHintValueType.dict;

  @override
  final Map<K, V> value;
}

/// 64-bit floating point value.
class LinuxHintDoubleValue extends LinuxHintValue<double> {
  /// Constructs an instance of [LinuxHintDoubleValue].
  LinuxHintDoubleValue(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.double;

  @override
  final double value;
}

/// Signed 16-bit integer.
class LinuxHintInt16Value extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintInt16Value].
  LinuxHintInt16Value(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.int16;

  @override
  final int value;
}

/// Signed 32-bit integer.
class LinuxHintInt32Value extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintInt32Value].
  LinuxHintInt32Value(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.int32;

  @override
  final int value;
}

/// Signed 64-bit integer.
class LinuxHintInt64Value extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintInt64Value].
  LinuxHintInt64Value(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.int64;

  @override
  final int value;
}

/// Unicode text string.
class LinuxHintStringValue extends LinuxHintValue<String> {
  /// Constructs an instance of [LinuxHintStringValue].
  LinuxHintStringValue(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.string;

  @override
  final String value;
}

/// Value that contains a fixed set of other values.
class LinuxHintStructValue extends LinuxHintValue<List<LinuxHintValue>> {
  /// Constructs an instance of [LinuxHintStructValue].
  LinuxHintStructValue(Iterable<LinuxHintValue> value) : value = value.toList();

  @override
  LinuxHintValueType get type => LinuxHintValueType.struct;

  @override
  final List<LinuxHintValue> value;
}

/// Unsigned 16-bit integer.
class LinuxHintUint16Value extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintUint16Value].
  LinuxHintUint16Value(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.uint16;

  @override
  final int value;
}

/// Unsigned 32-bit integer.
class LinuxHintUint32Value extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintUint32Value].
  LinuxHintUint32Value(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.uint32;

  @override
  final int value;
}

/// Unsigned 64-bit integer.
class LinuxHintUint64Value extends LinuxHintValue<int> {
  /// Constructs an instance of [LinuxHintUint64Value].
  LinuxHintUint64Value(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.uint64;

  @override
  final int value;
}

/// Value that contains any type.
class LinuxHintVariantValue extends LinuxHintValue<LinuxHintValue> {
  /// Constructs an instance of [LinuxHintVariantValue].
  LinuxHintVariantValue(this.value);

  @override
  LinuxHintValueType get type => LinuxHintValueType.variant;

  @override
  final LinuxHintValue value;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\icon.dart =====
import 'dart:typed_data';

import 'enums.dart';

/// Represents Linux notification icon.
abstract class LinuxNotificationIcon {
  /// Implementation-defined icon content.
  Object get content;

  /// Defines the type of icon.
  LinuxIconType get type;
}

/// Represents an icon from the Flutter Assets directory.
/// Currently the assets directory is `data/flutter_assets`
/// which is located on the path relative to the executable file.
class AssetsLinuxIcon extends LinuxNotificationIcon {
  /// Constructs an instance of [AssetsLinuxIcon].
  AssetsLinuxIcon(this.relativePath);

  @override
  Object get content => relativePath;

  @override
  LinuxIconType get type => LinuxIconType.assets;

  /// Icon relative path inside the Flutter Assets directory
  final String relativePath;
}

/// Represents an icon from a raw image data bytes, see [LinuxRawIconData].
class ByteDataLinuxIcon extends LinuxNotificationIcon {
  /// Constructs an instance of [ByteDataLinuxIcon].
  ByteDataLinuxIcon(this.iconData);

  @override
  Object get content => iconData;

  @override
  LinuxIconType get type => LinuxIconType.byteData;

  /// Icon data
  final LinuxRawIconData iconData;
}

/// Represents a system theme icon.
/// See https://www.freedesktop.org/wiki/Specifications/icon-naming-spec/ for more help.
class ThemeLinuxIcon extends LinuxNotificationIcon {
  /// Constructs an instance of [ThemeLinuxIcon].
  ThemeLinuxIcon(this.name);

  @override
  Object get content => name;

  @override
  LinuxIconType get type => LinuxIconType.theme;

  /// Name in a freedesktop.org-compliant icon theme (not a GTK+ stock ID).
  final String name;
}

/// Represents an icon in the raw image data.
class LinuxRawIconData {
  /// Constructs an instance of [LinuxRawIconData].
  LinuxRawIconData({
    required this.data,
    required this.width,
    required this.height,
    int? rowStride,
    this.bitsPerSample = 8,
    this.channels = 3,
    this.hasAlpha = false,
  }) : rowStride = rowStride ?? ((width * channels * bitsPerSample) / 8).ceil();

  /// Raw data (decoded from the image format) for the image in bytes.
  final Uint8List data;

  /// Width of the image in pixels
  final int width;

  /// Height of the image in pixels
  final int height;

  /// The number of bytes per row in [data]
  final int rowStride;

  /// The number of bits in each color sample
  final int bitsPerSample;

  /// The number of channels in the image (e.g. 3 for RGB, 4 for RGBA).
  /// If [hasAlpha] is `true`, must be 4.
  final int channels;

  /// Determines if the image has an alpha channel
  final bool hasAlpha;
}

/// Represents an icon located at the path in the file system.
/// It Ñan be either an absolute UNIX path or a file:// URI scheme, for example:
///  * file:///usr/share/icons/my_icon.png
///  * /usr/share/icons/my_icon.png
class FilePathLinuxIcon extends LinuxNotificationIcon {
  /// Constructs an instance of [FilePathLinuxIcon].
  FilePathLinuxIcon(this.path);

  @override
  Object get content => path;

  @override
  LinuxIconType get type => LinuxIconType.filePath;

  /// Path to the icon
  final String path;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\initialization_settings.dart =====
import 'icon.dart';
import 'sound.dart';

/// Plugin initialization settings for Linux.
class LinuxInitializationSettings {
  /// Constructs an instance of [LinuxInitializationSettings]
  const LinuxInitializationSettings({
    required this.defaultActionName,
    this.defaultIcon,
    this.defaultSound,
    this.defaultSuppressSound = false,
  });

  /// Name of the default action (usually triggered by clicking
  /// the notification).
  /// The name can be anything, though implementations are free not to
  /// display it.
  final String defaultActionName;

  /// Specifies the default icon for notifications.
  final LinuxNotificationIcon? defaultIcon;

  /// Specifies the default sound for notifications.
  /// Typical value is `ThemeLinuxSound('message')`
  final LinuxNotificationSound? defaultSound;

  /// Causes the server to suppress playing any sounds, if it has that ability.
  /// This is usually set when the client itself is going to play its own sound.
  final bool defaultSuppressSound;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\location.dart =====
import 'package:flutter/foundation.dart';

/// Represents the location on the screen that the notification should point to.
@immutable
class LinuxNotificationLocation {
  /// Constructs an instance of [LinuxNotificationLocation]
  const LinuxNotificationLocation(this.x, this.y);

  /// Represents the `X` location on the screen that the notification
  /// should point to.
  final int x;

  /// Represents the `Y` location on the screen that the notification
  /// should point to.
  final int y;

  /// Creates a copy of this object,
  /// but with the given fields replaced with the new values.
  LinuxNotificationLocation copyWith({
    int? x,
    int? y,
  }) =>
      LinuxNotificationLocation(x ?? this.x, y ?? this.y);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }

    return other is LinuxNotificationLocation && other.x == x && other.y == y;
  }

  @override
  int get hashCode => x.hashCode ^ y.hashCode;

  @override
  String toString() => 'LinuxNotificationLocation(x: $x, y: $y)';
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\notification_details.dart =====
import 'capabilities.dart';
import 'enums.dart';
import 'hint.dart';
import 'icon.dart';
import 'location.dart';
import 'sound.dart';
import 'timeout.dart';

/// Configures notification details specific to Linux.
/// The system may not support all features.
class LinuxNotificationDetails {
  /// Constructs an instance of [LinuxNotificationDetails].
  const LinuxNotificationDetails({
    this.icon,
    this.sound,
    this.category,
    this.urgency,
    this.timeout = const LinuxNotificationTimeout.systemDefault(),
    this.resident = false,
    this.suppressSound = false,
    this.transient = false,
    this.location,
    this.defaultActionName,
    this.customHints,
    this.actions = const <LinuxNotificationAction>[],
    this.actionKeyAsIconName = false,
  });

  /// Specifies the notification icon.
  final LinuxNotificationIcon? icon;

  /// Specifies the notification sound.
  /// Typical value is `ThemeLinuxSound('message')`
  final LinuxNotificationSound? sound;

  /// Specifies the category for notification.
  /// This can be used by the notification server to filter or
  /// display the data in a certain way.
  final LinuxNotificationCategory? category;

  /// Sets the urgency level for notification.
  final LinuxNotificationUrgency? urgency;

  /// Sets the timeout for notification.
  /// To set the default time, pass [LinuxNotificationTimeout.systemDefault]
  /// value. To set the notification to never expire,
  /// pass [LinuxNotificationTimeout.expiresNever].
  ///
  /// Note that the timeout may be ignored by the server.
  final LinuxNotificationTimeout timeout;

  /// When set the server will not automatically remove the notification
  /// when an action has been invoked. The notification will remain resident in
  /// the server until it is explicitly removed by the user or by the sender.
  /// This option is likely only useful when the server has
  /// the [LinuxServerCapabilities.persistence] capability.
  final bool resident;

  /// Causes the server to suppress playing any sounds, if it has that ability.
  /// This is usually set when the client itself is going to play its own sound.
  final bool suppressSound;

  /// When set the server will treat the notification as transient and
  /// by-pass the server's [LinuxServerCapabilities.persistence] capability,
  /// if it should exist.
  final bool transient;

  /// Specifies the location on the screen that the notification
  /// should point to.
  final LinuxNotificationLocation? location;

  /// Name of the default action (usually triggered by clicking
  /// the notification).
  /// The name can be anything, though implementations are free not to
  /// display it.
  final String? defaultActionName;

  /// Custom hints list to provide extra data to a notification server that
  /// the server may be able to make use of. Before using, make sure that
  /// the server supports this capability, please see [LinuxServerCapabilities].
  final List<LinuxNotificationCustomHint>? customHints;

  /// Specify a list of actions associated with this notifications.
  final List<LinuxNotificationAction> actions;

  /// If `true`, the server will attempt to interpret
  /// [LinuxNotificationAction.key] as a named icon.
  /// [LinuxNotificationAction.label] will be used to annotate the icon for
  /// accessibility purposes. The icon name should be compliant with the
  /// Freedesktop.org Icon Naming Specification https://specifications.freedesktop.org/icon-naming-spec/latest/
  ///
  /// Note: before using, make sure that the server supports this capability,
  /// please see [LinuxServerCapabilities].
  final bool actionKeyAsIconName;
}

/// Represents an action, that send a request message back to the notification
/// client when invoked. This functionality may not be implemented by the
/// notification server, conforming clients should check if it's available using
/// [LinuxServerCapabilities].
/// For more information, please see Desktop Notifications Specification https://specifications.freedesktop.org/notification-spec/latest/ar01s02.html
class LinuxNotificationAction {
  /// Constructs a [LinuxNotificationAction] object.
  const LinuxNotificationAction({
    required this.key,
    required this.label,
  });

  /// Unique ID for this action. This ID will be sent back in the action handler
  /// defined in [FlutterLocalNotificationsPlugin].
  ///
  /// If [LinuxNotificationDetails.keyAsIconName] is `true`,
  /// the server will attempt to interpret [key] as a named icon.
  /// [label] will be used to annotate the icon for accessibility purposes.
  /// The icon name should be compliant with the Freedesktop.org Icon Naming Specification https://specifications.freedesktop.org/icon-naming-spec/latest/
  final String key;

  /// Label to show to the user.
  final String label;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\sound.dart =====
import 'enums.dart';

/// Represents Linux notification sound.
abstract class LinuxNotificationSound {
  /// Implementation-defined sound content.
  Object get content;

  /// Defines the type of sound.
  LinuxSoundType get type;
}

/// Represents a sound from the Flutter Assets directory.
class AssetsLinuxSound extends LinuxNotificationSound {
  /// Constructs an instance of [AssetsLinuxSound].
  AssetsLinuxSound(this.relativePath);

  @override
  Object get content => relativePath;

  @override
  LinuxSoundType get type => LinuxSoundType.assets;

  /// Sound relative path inside the Flutter Assets directory
  final String relativePath;
}

/// Represents a system theme sound.
/// See https://www.freedesktop.org/wiki/Specifications/sound-theme-spec/ for more help.
class ThemeLinuxSound extends LinuxNotificationSound {
  /// Constructs an instance of [ThemeLinuxSound].
  ThemeLinuxSound(this.name);

  @override
  Object get content => name;

  @override
  LinuxSoundType get type => LinuxSoundType.theme;

  /// A themeable named sound from the
  /// freedesktop.org sound naming specification http://0pointer.de/public/sound-naming-spec.html
  final String name;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\model\timeout.dart =====
import 'package:flutter/foundation.dart';

/// The timeout of the Linux notification.
@immutable
class LinuxNotificationTimeout {
  /// Constructs an instance of [LinuxNotificationTimeout]
  /// with a given [value] in milliseconds.
  const LinuxNotificationTimeout(this.value);

  /// Constructs an instance of [LinuxNotificationTimeout]
  /// with a given [Duration] value.
  LinuxNotificationTimeout.fromDuration(Duration duration)
      : value = duration.inMilliseconds;

  /// Constructs an instance of [LinuxNotificationTimeout]
  /// with a [value] equal to `-1`.
  /// The system default timeout value will be used.
  const LinuxNotificationTimeout.systemDefault() : value = -1;

  /// Constructs an instance of [LinuxNotificationTimeout]
  /// with a [value] equal to `0`. The notification will be never expires.
  const LinuxNotificationTimeout.expiresNever() : value = 0;

  /// The integer representation in milliseconds.
  final int value;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }

    return other is LinuxNotificationTimeout && other.value == value;
  }

  @override
  int get hashCode => value.hashCode;

  @override
  String toString() => 'LinuxNotificationTimeout(value: $value)';
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\dbus_wrapper.dart =====
import 'dart:async';

import 'package:dbus/dbus.dart';

/// Mockable [DBusRemoteObject] wrapper
class DBusWrapper {
  late final DBusRemoteObject _object;
  late final String _destination;

  /// Build an instance of [DBusRemoteObject]
  void build({
    required String destination,
    required String path,
  }) {
    _destination = destination;
    _object = DBusRemoteObject(
      DBusClient.session(),
      name: destination,
      path: DBusObjectPath(path),
    );
  }

  /// Invokes a method on this [DBusRemoteObject].
  /// Throws [DBusMethodResponseException] if the remote side returns an error.
  ///
  /// If [replySignature] is provided this causes this method to throw a
  /// [DBusReplySignatureException] if the result is successful but the returned
  /// values do not match the provided signature.
  Future<DBusMethodSuccessResponse> callMethod(
    String? interface,
    String name,
    Iterable<DBusValue> values, {
    DBusSignature? replySignature,
    bool noReplyExpected = false,
    bool noAutoStart = false,
    bool allowInteractiveAuthorization = false,
  }) =>
      _object.callMethod(
        interface,
        name,
        values,
        replySignature: replySignature,
        noReplyExpected: noReplyExpected,
        noAutoStart: noAutoStart,
        allowInteractiveAuthorization: allowInteractiveAuthorization,
      );

  /// Creates a stream of signal with the given [name].
  DBusRemoteObjectSignalStream subscribeSignal(String name) =>
      DBusRemoteObjectSignalStream(
          object: _object, interface: _destination, name: name);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\file_system.dart =====
import 'dart:io';

/// Mockable file system representation
// ignore: one_member_abstracts
abstract class FileSystem {
  /// Returns a [File], that referred to the given [path]
  File open(String path);
}

/// A real implementation of [FileSystem]
class LocalFileSystem implements FileSystem {
  @override
  File open(String path) => File(path);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\flutter_local_notifications.dart =====
import 'package:flutter/foundation.dart';

import 'flutter_local_notifications_platform_linux.dart';
import 'model/capabilities.dart';
import 'model/initialization_settings.dart';
import 'model/notification_details.dart';
import 'notifications_manager.dart';

/// Linux implementation of the local notifications plugin.
class LinuxFlutterLocalNotificationsPlugin
    extends FlutterLocalNotificationsPlatformLinux {
  /// Constructs an instance of [LinuxNotificationDetails].
  LinuxFlutterLocalNotificationsPlugin()
      : _manager = LinuxNotificationManager();

  /// Constructs an instance of [LinuxNotificationDetails]
  /// with the give [manager].
  @visibleForTesting
  LinuxFlutterLocalNotificationsPlugin.private(
    LinuxNotificationManager manager,
  ) : _manager = manager;

  /// Registers the Linux implementation.
  static void registerWith() {
    FlutterLocalNotificationsPlatform.instance =
        LinuxFlutterLocalNotificationsPlugin();
  }

  final LinuxNotificationManager _manager;

  /// Initializes the plugin.
  ///
  /// Call this method on application before using the plugin further.
  ///
  /// This should only be done once. When a notification created by this plugin
  /// was used to launch the app, calling [initialize] is what will trigger to
  /// the [onSelectNotification] callback to be fire.
  ///
  /// [onSelectNotificationAction] specifies a callback handler which receives
  /// notification action IDs.
  @override
  Future<bool?> initialize(
    LinuxInitializationSettings initializationSettings, {
    DidReceiveNotificationResponseCallback? onDidReceiveNotificationResponse,
  }) =>
      _manager.initialize(
        initializationSettings,
        onDidReceiveNotificationResponse: onDidReceiveNotificationResponse,
      );

  /// Show a notification with an optional payload that will be passed back to
  /// the app when a notification is tapped on.
  @override
  Future<void> show(
    int id,
    String? title,
    String? body, {
    LinuxNotificationDetails? notificationDetails,
    String? payload,
  }) {
    validateId(id);
    return _manager.show(
      id,
      title,
      body,
      details: notificationDetails,
      payload: payload,
    );
  }

  @override
  Future<void> cancel(int id) {
    validateId(id);
    return _manager.cancel(id);
  }

  @override
  Future<void> cancelAll() => _manager.cancelAll();

  /// Returns the system notification server capabilities.
  /// Some functionality may not be implemented by the notification server,
  /// conforming clients should check if it is available before using it.
  @override
  Future<LinuxServerCapabilities> getCapabilities() =>
      _manager.getCapabilities();

  /// Returns a [Map] with the specified notification id as the key
  /// and the id, assigned by the system, as the value.
  ///
  /// Note: the system ID is unique only within the current user session,
  /// so it's undesirable to save it to persistable storage without any
  /// invalidation/update. For more information, please see
  /// Desktop Notifications Specification https://specifications.freedesktop.org/notification-spec/latest/ar01s02.html
  @override
  Future<Map<int, int>> getSystemIdMap() => _manager.getSystemIdMap();
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\flutter_local_notifications_platform_linux.dart =====
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';

import 'model/capabilities.dart';
import 'model/initialization_settings.dart';
import 'model/notification_details.dart';

export 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';

/// The interface that all implementations of flutter_local_notifications_linux
/// must implement.
abstract class FlutterLocalNotificationsPlatformLinux
    extends FlutterLocalNotificationsPlatform {
  /// Initializes the plugin.
  ///
  /// Call this method on application before using the plugin further.
  ///
  /// The [onDidReceiveNotificationResponse] callback is fired when the user
  /// selects a notification or notification action.
  Future<bool?> initialize(
    LinuxInitializationSettings initializationSettings, {
    DidReceiveNotificationResponseCallback? onDidReceiveNotificationResponse,
  });

  /// Show a notification with an optional payload that will be passed back to
  /// the app when a notification is tapped on.
  @override
  Future<void> show(
    int id,
    String? title,
    String? body, {
    LinuxNotificationDetails? notificationDetails,
    String? payload,
  });

  /// Returns the system notification server capabilities.
  /// Some functionality may not be implemented by the notification server,
  /// conforming clients should check if it is available before using it.
  Future<LinuxServerCapabilities> getCapabilities();

  /// Returns a [Map] with the specified notification id as the key
  /// and the id, assigned by the system, as the value.
  ///
  /// Note: the system ID is unique only within the current user session,
  /// so it's undesirable to save it to persistable storage without any
  /// invalidation/update. For more information, please see
  /// Desktop Notifications Specification https://specifications.freedesktop.org/notification-spec/latest/ar01s02.html
  Future<Map<int, int>> getSystemIdMap();
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\flutter_local_notifications_stub.dart =====
import 'flutter_local_notifications_platform_linux.dart';
import 'model/capabilities.dart';
import 'model/initialization_settings.dart';
import 'model/notification_details.dart';

/// A stub implementation to satisfy compilation of multi-platform packages that
/// depend on flutter_local_notifications_linux.
/// This should never actually be created.
///
/// Notably, because flutter_local_notifications needs to manually register
/// flutter_local_notifications_linux, anything with a transitive dependency on
/// flutter_local_notifications will also depend on
/// flutter_local_notifications_linux, not just at
/// the pubspec level but the code level.
class LinuxFlutterLocalNotificationsPlugin
    extends FlutterLocalNotificationsPlatformLinux {
  /// Errors on attempted instantiation of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be created.
  LinuxFlutterLocalNotificationsPlugin() : assert(false);

  /// Errors on attempted calling of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be called.
  @override
  Future<bool?> initialize(
    LinuxInitializationSettings initializationSettings, {
    DidReceiveNotificationResponseCallback? onDidReceiveNotificationResponse,
  }) async {
    assert(false);
    return null;
  }

  /// Errors on attempted calling of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be called.
  @override
  Future<void> show(
    int id,
    String? title,
    String? body, {
    LinuxNotificationDetails? notificationDetails,
    String? payload,
  }) async {
    assert(false);
  }

  /// Errors on attempted calling of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be called.
  @override
  Future<LinuxServerCapabilities> getCapabilities() async {
    assert(false);
    throw UnimplementedError();
  }

  /// Errors on attempted calling of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be called.
  @override
  Future<Map<int, int>> getSystemIdMap() async {
    assert(false);
    throw UnimplementedError();
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\helpers.dart =====
import 'package:dbus/dbus.dart';

import 'model/enums.dart';
import 'model/hint.dart';

/// [LinuxHintValue] utils.
extension LinuxHintValueExtension on LinuxHintValue {
  /// Convert value to [DBusValue].
  DBusValue toDBusValue() {
    switch (type) {
      case LinuxHintValueType.array:
        final List<LinuxHintValue> l = value as List<LinuxHintValue>;
        return DBusArray(
          l.first.toDBusValue().signature,
          l.map((LinuxHintValue v) => v.toDBusValue()),
        );
      case LinuxHintValueType.boolean:
        return DBusBoolean(value);
      case LinuxHintValueType.byte:
        return DBusByte(value);
      case LinuxHintValueType.dict:
        final Map<LinuxHintValue, LinuxHintValue> m =
            value as Map<LinuxHintValue, LinuxHintValue>;
        return DBusDict(
          m.keys.first.toDBusValue().signature,
          m.values.first.toDBusValue().signature,
          m.map(
            (LinuxHintValue key, LinuxHintValue value) =>
                MapEntry<DBusValue, DBusValue>(
              key.toDBusValue(),
              value.toDBusValue(),
            ),
          ),
        );
      case LinuxHintValueType.double:
        return DBusDouble(value);
      case LinuxHintValueType.int16:
        return DBusInt16(value);
      case LinuxHintValueType.int32:
        return DBusInt32(value);
      case LinuxHintValueType.int64:
        return DBusInt64(value);
      case LinuxHintValueType.string:
        return DBusString(value);
      case LinuxHintValueType.struct:
        return DBusStruct(
          (value as List<LinuxHintValue>).map(
            (LinuxHintValue v) => v.toDBusValue(),
          ),
        );
      case LinuxHintValueType.uint16:
        return DBusUint16(value);
      case LinuxHintValueType.uint32:
        return DBusUint32(value);
      case LinuxHintValueType.uint64:
        return DBusUint64(value);
      case LinuxHintValueType.variant:
        return DBusVariant((value as LinuxHintValue).toDBusValue());
    }
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\notifications_manager.dart =====
import 'dart:async';

import 'package:dbus/dbus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';
import 'package:path/path.dart' as path;

import 'dbus_wrapper.dart';
import 'helpers.dart';
import 'model/capabilities.dart';
import 'model/enums.dart';
import 'model/hint.dart';
import 'model/icon.dart';
import 'model/initialization_settings.dart';
import 'model/location.dart';
import 'model/notification_details.dart';
import 'model/sound.dart';
import 'model/timeout.dart';
import 'notification_info.dart';
import 'platform_info.dart';
import 'storage.dart';

/// Linux notification manager and client
class LinuxNotificationManager {
  /// Constructs an instance of of [LinuxNotificationManager]
  LinuxNotificationManager()
      : _dbus = DBusWrapper(),
        _platformInfo = LinuxPlatformInfo(),
        _storage = NotificationStorage();

  /// Constructs an instance of of [LinuxNotificationManager]
  /// with the given class dependencies.
  @visibleForTesting
  LinuxNotificationManager.private({
    DBusWrapper? dbus,
    LinuxPlatformInfo? platformInfo,
    NotificationStorage? storage,
  })  : _dbus = dbus ?? DBusWrapper(),
        _platformInfo = platformInfo ?? LinuxPlatformInfo(),
        _storage = storage ?? NotificationStorage();

  final DBusWrapper _dbus;
  final LinuxPlatformInfo _platformInfo;
  final NotificationStorage _storage;

  late final LinuxInitializationSettings _initializationSettings;
  late final DidReceiveNotificationResponseCallback?
      _onDidReceiveNotificationResponse;
  late final LinuxPlatformInfoData _platformData;

  bool _initialized = false;

  /// Initializes the manager.
  /// Call this method on application before using the manager further.
  Future<bool> initialize(
    LinuxInitializationSettings initializationSettings, {
    DidReceiveNotificationResponseCallback? onDidReceiveNotificationResponse,
  }) async {
    if (_initialized) {
      return _initialized;
    }
    _initialized = true;
    _initializationSettings = initializationSettings;
    _onDidReceiveNotificationResponse = onDidReceiveNotificationResponse;
    _dbus.build(
      destination: _DBusInterfaceSpec.destination,
      path: _DBusInterfaceSpec.path,
    );
    _platformData = await _platformInfo.getAll();

    await _storage.forceReloadCache();
    _subscribeSignals();
    return _initialized;
  }

  /// Show notification
  Future<void> show(
    int id,
    String? title,
    String? body, {
    LinuxNotificationDetails? details,
    String? payload,
  }) async {
    final LinuxNotificationInfo? prevNotify = await _storage.getById(id);
    final LinuxNotificationIcon? defaultIcon =
        _initializationSettings.defaultIcon;

    final DBusMethodSuccessResponse result = await _dbus.callMethod(
      _DBusInterfaceSpec.destination,
      _DBusMethodsSpec.notify,
      <DBusValue>[
        // app_name
        DBusString(_platformData.appName ?? ''),
        // replaces_id
        DBusUint32(prevNotify?.systemId ?? 0),
        // app_icon
        DBusString(_getAppIcon(details?.icon ?? defaultIcon) ?? ''),
        // summary
        DBusString(title ?? ''),
        // body
        DBusString(body ?? ''),
        // actions
        DBusArray.string(_buildActions(details, _initializationSettings)),
        // hints
        DBusDict.stringVariant(_buildHints(details, _initializationSettings)),
        // expire_timeout
        DBusInt32(
          details?.timeout.value ??
              const LinuxNotificationTimeout.systemDefault().value,
        ),
      ],
      replySignature: DBusSignature('u'),
    );
    final List<LinuxNotificationActionInfo>? actionsInfo = details?.actions
        .map(
          (LinuxNotificationAction action) => LinuxNotificationActionInfo(
            key: action.key,
          ),
        )
        .toList();

    final int systemId = (result.returnValues[0] as DBusUint32).value;
    final LinuxNotificationInfo notify = prevNotify?.copyWith(
          systemId: systemId,
          payload: payload,
          actions: actionsInfo,
        ) ??
        LinuxNotificationInfo(
          id: id,
          systemId: systemId,
          payload: payload,
          actions: actionsInfo ?? <LinuxNotificationActionInfo>[],
        );
    await _storage.insert(notify);
  }

  Map<String, DBusValue> _buildHints(
    LinuxNotificationDetails? details,
    LinuxInitializationSettings initSettings,
  ) {
    final Map<String, DBusValue> hints = <String, DBusValue>{};
    final LinuxNotificationIcon? icon =
        details?.icon ?? initSettings.defaultIcon;
    if (icon?.type == LinuxIconType.byteData) {
      final LinuxRawIconData data = icon!.content as LinuxRawIconData;
      hints['image-data'] = DBusStruct(
        <DBusValue>[
          DBusInt32(data.width),
          DBusInt32(data.height),
          DBusInt32(data.rowStride),
          DBusBoolean(data.hasAlpha),
          DBusInt32(data.bitsPerSample),
          DBusInt32(data.channels),
          DBusArray.byte(data.data),
        ],
      );
    }
    final LinuxNotificationSound? sound =
        details?.sound ?? initSettings.defaultSound;
    if (sound != null) {
      switch (sound.type) {
        case LinuxSoundType.assets:
          hints['sound-file'] = DBusString(
            path.join(
              _platformData.assetsPath!,
              sound.content as String,
            ),
          );
          break;
        case LinuxSoundType.theme:
          hints['sound-name'] = DBusString(sound.content as String);
          break;
      }
    }
    if (details?.category != null) {
      hints['category'] = DBusString(details!.category!.name);
    }
    if (details?.urgency != null) {
      hints['urgency'] = DBusByte(details!.urgency!.index);
    }
    if (details?.resident ?? false) {
      hints['resident'] = const DBusBoolean(true);
    }
    final bool? suppressSound =
        details?.suppressSound ?? initSettings.defaultSuppressSound;
    if (suppressSound ?? false) {
      hints['suppress-sound'] = const DBusBoolean(true);
    }
    if (details?.transient ?? false) {
      hints['transient'] = const DBusBoolean(true);
    }
    if (details?.location != null) {
      final LinuxNotificationLocation location = details!.location!;
      hints['x'] = DBusByte(location.x);
      hints['y'] = DBusByte(location.y);
    }
    if (details?.actionKeyAsIconName ?? false) {
      hints['action-icons'] = const DBusBoolean(true);
    }
    if (details?.customHints != null) {
      hints.addAll(_buildCustomHints(details!.customHints!));
    }

    return hints;
  }

  Map<String, DBusValue> _buildCustomHints(
    List<LinuxNotificationCustomHint> hints,
  ) =>
      Map<String, DBusValue>.fromEntries(
        hints.map(
          (LinuxNotificationCustomHint hint) => MapEntry<String, DBusValue>(
            hint.name,
            hint.value.toDBusValue(),
          ),
        ),
      );

  List<String> _buildActions(
    LinuxNotificationDetails? details,
    LinuxInitializationSettings initSettings,
  ) {
    // Add default action, which is triggered when the notification is clicked
    final List<String> actions = <String>[
      _kDefaultActionName,
      details?.defaultActionName ?? initSettings.defaultActionName,
    ];
    if (details != null) {
      for (final LinuxNotificationAction action in details.actions) {
        actions
          ..add(action.key)
          ..add(action.label);
      }
    }
    return actions;
  }

  /// Cancel notification with the given [id].
  Future<void> cancel(int id) async {
    final LinuxNotificationInfo? notify = await _storage.getById(id);
    await _storage.removeById(id);
    if (notify != null) {
      await _dbusCancel(notify.systemId);
    }
  }

  /// Cancel all notifications.
  Future<void> cancelAll() async {
    final List<LinuxNotificationInfo> notifyList = await _storage.getAll();
    final List<int> idList = <int>[];
    for (final LinuxNotificationInfo notify in notifyList) {
      idList.add(notify.id);
      await _dbusCancel(notify.systemId);
    }
    await _storage.removeByIdList(idList);
  }

  /// Returns the system notification server capabilities.
  Future<LinuxServerCapabilities> getCapabilities() async {
    final DBusMethodSuccessResponse result = await _dbus.callMethod(
      _DBusInterfaceSpec.destination,
      _DBusMethodsSpec.getCapabilities,
      <DBusValue>[],
      replySignature: DBusSignature('as'),
    );
    final Set<String> capsSet = (result.returnValues[0] as DBusArray)
        .children
        .map((DBusValue c) => (c as DBusString).value)
        .toSet();

    final LinuxServerCapabilities capabilities = LinuxServerCapabilities(
      otherCapabilities: const <String>{},
      body: capsSet.remove('body'),
      bodyHyperlinks: capsSet.remove('body-hyperlinks'),
      bodyImages: capsSet.remove('body-images'),
      bodyMarkup: capsSet.remove('body-markup'),
      iconMulti: capsSet.remove('icon-multi'),
      iconStatic: capsSet.remove('icon-static'),
      persistence: capsSet.remove('persistence'),
      sound: capsSet.remove('sound'),
      actions: capsSet.remove('actions'),
      actionIcons: capsSet.remove('action-icons'),
    );
    return capabilities.copyWith(otherCapabilities: capsSet);
  }

  /// Returns a [Map] with the specified notification id as the key
  /// and the id, assigned by the system, as the value.
  Future<Map<int, int>> getSystemIdMap() async =>
      Map<int, int>.fromEntries(await _storage.getAll().then(
            (List<LinuxNotificationInfo> list) => list.map(
              (LinuxNotificationInfo notify) => MapEntry<int, int>(
                notify.id,
                notify.systemId,
              ),
            ),
          ));

  Future<void> _dbusCancel(int systemId) => _dbus.callMethod(
        _DBusInterfaceSpec.destination,
        _DBusMethodsSpec.closeNotification,
        <DBusValue>[DBusUint32(systemId)],
        replySignature: DBusSignature(''),
      );

  String? _getAppIcon(LinuxNotificationIcon? icon) {
    if (icon == null) {
      return null;
    }
    switch (icon.type) {
      case LinuxIconType.assets:
        if (_platformData.assetsPath == null) {
          return null;
        } else {
          final String relativePath = icon.content as String;
          return path.join(_platformData.assetsPath!, relativePath);
        }
      case LinuxIconType.byteData:
        return null;
      case LinuxIconType.theme:
        return icon.content as String;
      case LinuxIconType.filePath:
        return icon.content as String;
    }
  }

  /// Subscribe to the signals for actions and closing notifications.
  void _subscribeSignals() {
    _dbus.subscribeSignal(_DBusMethodsSpec.actionInvoked).listen(
      (DBusSignal s) async {
        if (s.signature != DBusSignature('us')) {
          return;
        }

        final int systemId = (s.values[0] as DBusUint32).value;
        final String actionKey = (s.values[1] as DBusString).value;
        final LinuxNotificationInfo? notify =
            await _storage.getBySystemId(systemId);
        if (notify == null) {
          return;
        }
        if (actionKey == _kDefaultActionName) {
          _onDidReceiveNotificationResponse?.call(
            NotificationResponse(
              id: notify.id,
              payload: notify.payload,
              notificationResponseType:
                  NotificationResponseType.selectedNotification,
            ),
          );
        } else {
          final LinuxNotificationActionInfo? actionInfo =
              notify.actions.firstWhere(
            (LinuxNotificationActionInfo a) => a.key == actionKey,
          );
          if (actionInfo == null) {
            return;
          }
          _onDidReceiveNotificationResponse?.call(
            NotificationResponse(
              id: notify.id,
              actionId: actionInfo.key,
              payload: notify.payload,
              notificationResponseType:
                  NotificationResponseType.selectedNotificationAction,
            ),
          );
        }
      },
    );

    _dbus.subscribeSignal(_DBusMethodsSpec.notificationClosed).listen(
      (DBusSignal s) async {
        if (s.signature != DBusSignature('uu')) {
          return;
        }

        final int systemId = (s.values[0] as DBusUint32).value;
        await _storage.removeBySystemId(systemId);
      },
    );
  }
}

const String _kDefaultActionName = 'default';

class _DBusInterfaceSpec {
  static const String destination = 'org.freedesktop.Notifications';
  static const String path = '/org/freedesktop/Notifications';
}

class _DBusMethodsSpec {
  static const String notify = 'Notify';
  static const String closeNotification = 'CloseNotification';
  static const String actionInvoked = 'ActionInvoked';
  static const String notificationClosed = 'NotificationClosed';
  static const String getCapabilities = 'GetCapabilities';
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\notification_info.dart =====
import 'package:flutter/foundation.dart';

/// Represents a Linux notification information
@immutable
class LinuxNotificationInfo {
  /// Constructs an instance of [LinuxPlatformInfoData].
  const LinuxNotificationInfo({
    required this.id,
    required this.systemId,
    this.payload,
    this.actions = const <LinuxNotificationActionInfo>[],
  });

  /// Constructs an instance of [LinuxPlatformInfoData] from [json].
  factory LinuxNotificationInfo.fromJson(Map<String, dynamic> json) {
    final List<dynamic>? actionsJson = json['actions'] as List<dynamic>?;
    final List<LinuxNotificationActionInfo>? actions = actionsJson
        // ignore: avoid_annotating_with_dynamic
        ?.map((dynamic json) =>
            LinuxNotificationActionInfo.fromJson(json as Map<String, dynamic>))
        .toList();
    return LinuxNotificationInfo(
      id: json['id'] as int,
      systemId: json['systemId'] as int,
      payload: json['payload'] as String?,
      actions: actions ?? <LinuxNotificationActionInfo>[],
    );
  }

  /// Notification id
  final int id;

  /// Notification id, which is returned by the system,
  /// see Desktop Notifications Specification https://specifications.freedesktop.org/notification-spec/latest/
  final int systemId;

  /// Notification payload, that will be passed back to the app
  /// when a notification is tapped on.
  final String? payload;

  /// List of actions info
  final List<LinuxNotificationActionInfo> actions;

  /// Returns the object as a key-value map
  Map<String, dynamic> toJson() => <String, dynamic>{
        'id': id,
        'systemId': systemId,
        'payload': payload,
        'actions':
            actions.map((LinuxNotificationActionInfo a) => a.toJson()).toList(),
      };

  /// Creates a copy of this object,
  /// but with the given fields replaced with the new values.
  LinuxNotificationInfo copyWith({
    int? id,
    int? systemId,
    String? payload,
    List<LinuxNotificationActionInfo>? actions,
  }) =>
      LinuxNotificationInfo(
        id: id ?? this.id,
        systemId: systemId ?? this.systemId,
        payload: payload ?? this.payload,
        actions: actions ?? this.actions,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }

    return other is LinuxNotificationInfo &&
        other.id == id &&
        other.systemId == systemId &&
        other.payload == payload &&
        listEquals(other.actions, actions);
  }

  @override
  int get hashCode =>
      id.hashCode ^ systemId.hashCode ^ payload.hashCode ^ actions.hashCode;
}

/// Represents a Linux notification action information
@immutable
class LinuxNotificationActionInfo {
  /// Constructs an instance of [LinuxNotificationActionInfo].
  const LinuxNotificationActionInfo({
    required this.key,
  });

  /// Constructs an instance of [LinuxNotificationActionInfo] from [json].
  factory LinuxNotificationActionInfo.fromJson(Map<String, dynamic> json) =>
      LinuxNotificationActionInfo(key: json['key'] as String);

  /// Unique action key.
  final String key;

  /// Returns the object as a key-value map
  Map<String, dynamic> toJson() => <String, dynamic>{'key': key};

  /// Creates a copy of this object,
  /// but with the given fields replaced with the new values.
  LinuxNotificationActionInfo copyWith({
    String? key,
    String? payload,
  }) =>
      LinuxNotificationActionInfo(key: key ?? this.key);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }

    return other is LinuxNotificationActionInfo && other.key == key;
  }

  @override
  int get hashCode => key.hashCode;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\platform_info.dart =====
import 'dart:convert';
import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:xdg_directories/xdg_directories.dart' as xdg;

import 'posix.dart';

/// Provides Linux platform-specific info
class LinuxPlatformInfo {
  final Posix _posix = Posix();

  /// Returns all platform-specific info
  Future<LinuxPlatformInfoData> getAll() async {
    try {
      final String exePath =
          await File('/proc/self/exe').resolveSymbolicLinks();
      final String processName = path.basenameWithoutExtension(exePath);
      final String appPath = path.dirname(exePath);
      final String assetPath = path.join(appPath, 'data', 'flutter_assets');
      final String versionPath = path.join(assetPath, 'version.json');
      final Map<String, dynamic> json = jsonDecode(
        await File(versionPath).readAsString(),
      );
      late final Directory runtimeDir;
      if (xdg.runtimeDir == null) {
        final int pid = _posix.getpid();
        final int userId = _posix.getuid();
        final int sessionId = _posix.getsid(pid);
        final Map<String, String> env = Platform.environment;
        final String? tmpdir = env['TMPDIR'];
        runtimeDir = Directory(
          path.join(
            tmpdir == null || tmpdir.isEmpty ? '/tmp' : tmpdir,
            processName,
            '$userId',
            '$sessionId',
          ),
        );
      } else {
        runtimeDir = Directory(path.join(xdg.runtimeDir!.path, processName));
      }
      if (!runtimeDir.existsSync()) {
        await runtimeDir.create(recursive: true);
      }

      return LinuxPlatformInfoData(
        appName: json['app_name'] ?? '',
        assetsPath: assetPath,
        runtimePath: runtimeDir.path,
      );
      // ignore: avoid_catches_without_on_clauses
    } catch (e) {
      return const LinuxPlatformInfoData();
    }
  }
}

/// Represents Linux platform-specific info
class LinuxPlatformInfoData {
  /// Constructs an instance of [LinuxPlatformInfoData].
  const LinuxPlatformInfoData({
    this.appName,
    this.assetsPath,
    this.runtimePath,
  });

  /// Application name
  final String? appName;

  /// Path to the Flutter Assets directory
  final String? assetsPath;

  /// The base directory relative to which user-specific runtime files and
  /// other file objects should be placed
  /// (Corresponds to `$XDG_RUNTIME_DIR` environment variable).
  /// Please see XDG Base Directory Specification https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
  /// If `$XDG_RUNTIME_DIR` is not set, the following directory structure is used: `/[$TMPDIR|tmp]/APP_NAME/USER_ID/SESSION_ID`
  final String? runtimePath;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\posix.dart =====
import 'dart:ffi' as ffi;

/// Represents Linux POSIX calls.
class Posix {
  /// Constructs an instance of [Posix].
  Posix() {
    final ffi.DynamicLibrary _dylib = ffi.DynamicLibrary.open('libc.so.6');
    getpid = _dylib
        .lookup<ffi.NativeFunction<ffi.Int32 Function()>>('getpid')
        .asFunction();
    getsid = _dylib
        .lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32 pid)>>('getsid')
        .asFunction();
    getuid = _dylib
        .lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('getuid')
        .asFunction();
  }

  /// Get the process ID of the calling process.
  late final int Function() getpid;

  /// Return the session ID of the given process.
  late final int Function(int pid) getsid;

  /// Get the real user ID of the calling process.
  late final int Function() getuid;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\src\storage.dart =====
import 'dart:collection';
import 'dart:convert';
import 'dart:io';

import 'package:path/path.dart' as path;

import 'file_system.dart';
import 'notification_info.dart';
import 'platform_info.dart';

const String _kFileName = 'notification_plugin_cache.json';

/// Represents a persisten storage for the notifications info,
/// see [LinuxNotificationInfo].
/// The storage data exists within the user session.
class NotificationStorage {
  /// Constructs an instance of of [NotificationStorageImpl].
  NotificationStorage({
    LinuxPlatformInfo? platformInfo,
    FileSystem? fs,
  })  : _platformInfo = platformInfo ?? LinuxPlatformInfo(),
        _fs = fs ?? LocalFileSystem();

  final LinuxPlatformInfo _platformInfo;
  final FileSystem _fs;

  _Cache? _cachedInfo;

  /// Get all notifications.
  Future<List<LinuxNotificationInfo>> getAll() async {
    final _Cache cache = await _readInfoMap();
    return cache.toImmutableMap().values.toList();
  }

  /// Get notification by [LinuxNotificationInfo.id].
  Future<LinuxNotificationInfo?> getBySystemId(int systemId) async {
    final _Cache cache = await _readInfoMap();
    return cache.getBySystemId(systemId);
  }

  /// Get notification by [LinuxNotificationInfo.systemId].
  Future<LinuxNotificationInfo?> getById(int id) async {
    final _Cache cache = await _readInfoMap();
    return cache.getById(id);
  }

  /// Insert notification to the storage.
  /// Returns `true` if the operation succeeded.
  Future<bool> insert(LinuxNotificationInfo notification) async {
    final _Cache cache = await _readInfoMap();
    cache.insert(notification);
    return _writeInfoList(cache.values.toList());
  }

  /// Remove notification from the storage by [LinuxNotificationInfo.id].
  /// Returns `true` if the operation succeeded.
  Future<bool> removeById(int id) async {
    final _Cache cache = await _readInfoMap();
    cache.removeById(id);
    return _writeInfoList(cache.values.toList());
  }

  /// Remove notification from the storage by [LinuxNotificationInfo.systemId].
  /// Returns `true` if the operation succeeded.
  Future<bool> removeBySystemId(int systemId) async {
    final _Cache cache = await _readInfoMap();
    final LinuxNotificationInfo? info = cache.getBySystemId(systemId);
    if (info != null) {
      cache.removeById(info.id);
    }
    return _writeInfoList(cache.values.toList());
  }

  /// Remove notification from the storage by [idList].
  /// Returns `true` if the operation succeeded.
  Future<bool> removeByIdList(List<int> idList) async {
    final _Cache cache = await _readInfoMap();
    // ignore: prefer_foreach
    for (final int id in idList) {
      cache.removeById(id);
    }
    return _writeInfoList(cache.values.toList());
  }

  /// Force read info from the disk to the cache.
  Future<void> forceReloadCache() async {
    _cachedInfo = await _readFromCache();
  }

  Future<File?> _getStorageFile() async {
    final LinuxPlatformInfoData data = await _platformInfo.getAll();
    final String? dir = data.runtimePath;
    if (dir == null) {
      return null;
    }
    return _fs.open(path.join(dir, _kFileName));
  }

  /// Gets a [LinuxNotificationInfo] from the stored file.
  /// Once read, the data are maintained in memory.
  Future<_Cache> _readInfoMap() async {
    if (_cachedInfo != null) {
      return _cachedInfo!;
    }
    return _cachedInfo = await _readFromCache();
  }

  Future<_Cache> _readFromCache() async {
    final _Cache cache = _Cache();
    final File? storageFile = await _getStorageFile();
    if (storageFile != null && storageFile.existsSync()) {
      final String jsonStr = storageFile.readAsStringSync();
      if (jsonStr.isNotEmpty) {
        final dynamic json = jsonDecode(jsonStr);
        if (json is List) {
          for (final dynamic j in json) {
            final LinuxNotificationInfo info =
                LinuxNotificationInfo.fromJson(j);
            cache.insert(info);
          }
        } else {
          cache.insert(LinuxNotificationInfo.fromJson(json));
        }
      }
    }
    return cache;
  }

  /// Writes info list to disk. Returns [true] if the operation succeeded.
  Future<bool> _writeInfoList(List<LinuxNotificationInfo> infoList) async {
    try {
      final File? storageFile = await _getStorageFile();
      if (storageFile == null) {
        return false;
      }
      if (!storageFile.existsSync()) {
        storageFile.createSync(recursive: true);
      }
      final String jsonStr = jsonEncode(infoList);
      storageFile.writeAsStringSync(jsonStr);
    } on IOException catch (e) {
      // ignore: avoid_print
      print('Error saving preferences to disk: $e');
      return false;
    }
    return true;
  }
}

class _Cache {
  _Cache()
      : _infoMap = <int, LinuxNotificationInfo>{},
        _systemIdMap = <int, int>{};

  final Map<int, LinuxNotificationInfo> _infoMap;

  /// System ID to ID map.
  final Map<int, int> _systemIdMap;

  LinuxNotificationInfo? getById(int? id) => _infoMap[id];

  LinuxNotificationInfo? getBySystemId(int? id) => _infoMap[_systemIdMap[id]];

  void insert(LinuxNotificationInfo info) {
    _infoMap[info.id] = info;
    _systemIdMap[info.systemId] = info.id;
  }

  void removeById(int id) {
    final LinuxNotificationInfo? info = _infoMap.remove(id);
    _systemIdMap.remove(info?.systemId);
  }

  Iterable<LinuxNotificationInfo> get values => _infoMap.values;

  Map<int, LinuxNotificationInfo> toImmutableMap() =>
      UnmodifiableMapView<int, LinuxNotificationInfo>(_infoMap);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\lib\flutter_local_notifications_linux.dart =====
/// The Linux implementation of `flutter_local_notifications`.
library flutter_local_notifications_linux;

// flutter_local_notifications_linux depends on dbus and posix
// which uses FFI internally; export a stub for platforms that don't
// support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'src/flutter_local_notifications_stub.dart'
    if (dart.library.ffi) 'src/flutter_local_notifications.dart';
export 'src/model/capabilities.dart';
export 'src/model/enums.dart';
export 'src/model/icon.dart';
export 'src/model/initialization_settings.dart';
export 'src/model/location.dart';
export 'src/model/notification_details.dart';
export 'src/model/sound.dart';
export 'src/model/timeout.dart';
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\test\notifications_manager_test.dart =====
import 'dart:async';
import 'dart:typed_data';

import 'package:dbus/dbus.dart';
import 'package:flutter_local_notifications_linux/flutter_local_notifications_linux.dart';
import 'package:flutter_local_notifications_linux/src/dbus_wrapper.dart';
import 'package:flutter_local_notifications_linux/src/model/hint.dart';
import 'package:flutter_local_notifications_linux/src/notification_info.dart';
import 'package:flutter_local_notifications_linux/src/notifications_manager.dart';
import 'package:flutter_local_notifications_linux/src/platform_info.dart';
import 'package:flutter_local_notifications_linux/src/storage.dart';
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:path/path.dart' as path;

@GenerateNiceMocks(<MockSpec<Object>>[
  MockSpec<DBusWrapper>(),
  MockSpec<DBusRemoteObjectSignalStream>(),
  MockSpec<LinuxPlatformInfo>(),
  MockSpec<NotificationStorage>(),
  MockSpec<DidReceiveNotificationResponseCallback>(),
])
import 'notifications_manager_test.mocks.dart';

class FakeStreamSubscription<T> extends Fake implements StreamSubscription<T> {}

// ignore: one_member_abstracts
abstract class DidReceiveNotificationResponseCallback {
  Future<dynamic> call(NotificationResponse notificationResponse);
}

/*class MockDidReceiveNotificationResponseCallback extends Mock
    implements _DidReceiveNotificationResponseCallback {}*/

void main() {
  group('Notifications manager |', () {
    late LinuxNotificationManager manager;
    late final MockDBusWrapper mockDbus;
    late final MockDBusRemoteObjectSignalStream mockActionInvokedSignal;
    late final MockDBusRemoteObjectSignalStream mockNotifyClosedSignal;
    late final MockLinuxPlatformInfo mockPlatformInfo;
    late final MockNotificationStorage mockStorage;
    late final MockDidReceiveNotificationResponseCallback
        mockDidReceiveNotificationResponseCallback;

    const LinuxPlatformInfoData platformInfo = LinuxPlatformInfoData(
      appName: 'Test',
      assetsPath: 'assets',
      runtimePath: 'run',
    );

    setUpAll(() {
      mockDbus = MockDBusWrapper();
      mockActionInvokedSignal = MockDBusRemoteObjectSignalStream();
      mockNotifyClosedSignal = MockDBusRemoteObjectSignalStream();
      mockPlatformInfo = MockLinuxPlatformInfo();
      mockStorage = MockNotificationStorage();
      mockDidReceiveNotificationResponseCallback =
          MockDidReceiveNotificationResponseCallback();

      when(
        mockPlatformInfo.getAll(),
      ).thenAnswer((_) async => platformInfo);
      when(
        mockStorage.forceReloadCache(),
      ).thenAnswer((_) async {});
      when(
        mockDbus.build(
          destination: 'org.freedesktop.Notifications',
          path: '/org/freedesktop/Notifications',
        ),
      ).thenAnswer((_) {});
      when(
        mockDbus.subscribeSignal('ActionInvoked'),
      ).thenAnswer((_) => mockActionInvokedSignal);
      when(
        mockDbus.subscribeSignal('NotificationClosed'),
      ).thenAnswer((_) => mockNotifyClosedSignal);
      when(
        mockDidReceiveNotificationResponseCallback.call(any),
      ).thenAnswer((_) async => <void>{});
    });

    setUp(() {
      manager = LinuxNotificationManager.private(
        dbus: mockDbus,
        platformInfo: mockPlatformInfo,
        storage: mockStorage,
      );

      when(
        mockActionInvokedSignal.listen(any),
      ).thenReturn(FakeStreamSubscription<DBusSignal>());
      when(
        mockNotifyClosedSignal.listen(any),
      ).thenReturn(FakeStreamSubscription<DBusSignal>());
    });

    void mockCloseMethod() => when(
          mockDbus.callMethod(
            'org.freedesktop.Notifications',
            'CloseNotification',
            any,
            replySignature: DBusSignature(''),
          ),
        ).thenAnswer(
          (_) async => DBusMethodSuccessResponse(),
        );

    VerificationResult verifyCloseMethod(int systemId) => verify(
          mockDbus.callMethod(
            'org.freedesktop.Notifications',
            'CloseNotification',
            <DBusValue>[DBusUint32(systemId)],
            replySignature: DBusSignature(''),
          ),
        );

    test('Initialize', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: 'test',
      );

      await manager.initialize(initSettings);

      verify(mockPlatformInfo.getAll()).called(1);
      verify(mockStorage.forceReloadCache()).called(1);
      verify(
        mockDbus.build(
          destination: 'org.freedesktop.Notifications',
          path: '/org/freedesktop/Notifications',
        ),
      ).called(1);
      verify(mockActionInvokedSignal.listen(any)).called(1);
      verify(mockNotifyClosedSignal.listen(any)).called(1);
    });

    const String kDefaultActionName = 'Open notification';

    group('Show |', () {
      List<DBusValue> buildNotifyMethodValues({
        int? replacesId,
        String? appIcon,
        String? title,
        String? body,
        List<String>? actions,
        Map<String, DBusValue>? hints,
        int? expireTimeout,
      }) =>
          <DBusValue>[
            // app_name
            DBusString(platformInfo.appName!),
            // replaces_id
            DBusUint32(replacesId ?? 0),
            // app_icon
            DBusString(appIcon ?? ''),
            // summary
            DBusString(title ?? ''),
            // body
            DBusString(body ?? ''),
            // actions
            DBusArray.string(
                <String>['default', kDefaultActionName, ...?actions]),
            // hints
            DBusDict.stringVariant(hints ?? <String, DBusValue>{}),
            // expire_timeout
            DBusInt32(
              expireTimeout ??
                  const LinuxNotificationTimeout.systemDefault().value,
            ),
          ];

      void mockNotifyMethod(int systemId) => when(
            mockDbus.callMethod(
              'org.freedesktop.Notifications',
              'Notify',
              any,
              replySignature: DBusSignature('u'),
            ),
          ).thenAnswer(
            (_) async => DBusMethodSuccessResponse(
              <DBusValue>[DBusUint32(systemId)],
            ),
          );

      VerificationResult verifyNotifyMethod(List<DBusValue> values) =>
          verify(mockDbus.callMethod(
            'org.freedesktop.Notifications',
            'Notify',
            values,
            replySignature: DBusSignature('u'),
          ));

      test('Simple notification', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          title: 'Title',
          body: 'Body',
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, 'Title', 'Body');

        verifyNotifyMethod(values).called(1);
        verify(
          mockStorage.insert(notify),
        ).called(1);
      });

      test('Simple notification without title and body', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues();

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null);

        verifyNotifyMethod(values).called(1);
        verify(
          mockStorage.insert(notify),
        ).called(1);
      });

      test('Replace previous notification', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo prevNotify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
          payload: 'payload',
        );
        const LinuxNotificationInfo newNotify = LinuxNotificationInfo(
          id: 0,
          systemId: 2,
          payload: 'payload',
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          replacesId: prevNotify.systemId,
          title: 'Title',
          body: 'Body',
        );

        mockNotifyMethod(newNotify.systemId);
        when(
          mockStorage.getById(newNotify.id),
        ).thenAnswer((_) async => prevNotify);
        when(
          mockStorage.insert(newNotify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(newNotify.id, 'Title', 'Body');

        verifyNotifyMethod(values).called(1);
        verify(
          mockStorage.insert(newNotify),
        ).called(1);
      });

      test('Assets details icon', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultIcon: AssetsLinuxIcon('icon.png'),
        );

        final LinuxNotificationDetails details = LinuxNotificationDetails(
          icon: AssetsLinuxIcon('details_icon.png'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          appIcon: path.join(platformInfo.assetsPath!, 'details_icon.png'),
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Byte details icon', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultIcon: AssetsLinuxIcon('icon.png'),
        );

        final ByteDataLinuxIcon icon = ByteDataLinuxIcon(
          LinuxRawIconData(
            data: Uint8List(64),
            width: 8,
            height: 8,
          ),
        );
        final LinuxNotificationDetails details = LinuxNotificationDetails(
          icon: icon,
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'image-data': DBusStruct(
              <DBusValue>[
                DBusInt32(icon.iconData.width),
                DBusInt32(icon.iconData.height),
                DBusInt32(icon.iconData.rowStride),
                DBusBoolean(icon.iconData.hasAlpha),
                DBusInt32(icon.iconData.bitsPerSample),
                DBusInt32(icon.iconData.channels),
                DBusArray.byte(icon.iconData.data),
              ],
            ),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Theme details icon', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultIcon: AssetsLinuxIcon('icon.png'),
        );

        final LinuxNotificationDetails details = LinuxNotificationDetails(
          icon: ThemeLinuxIcon('test'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          appIcon: details.icon!.content as String,
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Default icon', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultIcon: AssetsLinuxIcon('icon.png'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          appIcon: path.join(platformInfo.assetsPath!, 'icon.png'),
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null);

        verifyNotifyMethod(values).called(1);
      });

      test('Timeout', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          timeout: LinuxNotificationTimeout(100),
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          expireTimeout: details.timeout.value,
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Assets sound in details', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultSound: AssetsLinuxSound('default_sound.mp3'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final LinuxNotificationDetails details = LinuxNotificationDetails(
          sound: AssetsLinuxSound('sound.mp3'),
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'sound-file': DBusString(
              path.join(
                platformInfo.assetsPath!,
                details.sound!.content as String,
              ),
            ),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Theme sound in details', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultSound: AssetsLinuxSound('default_sound.mp3'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final LinuxNotificationDetails details = LinuxNotificationDetails(
          sound: ThemeLinuxSound('test'),
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'sound-name': DBusString(details.sound!.content as String),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Default sound', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultSound: AssetsLinuxSound('sound.mp3'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'sound-file': DBusString(
              path.join(
                platformInfo.assetsPath!,
                initSettings.defaultSound!.content as String,
              ),
            ),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null);

        verifyNotifyMethod(values).called(1);
      });

      test('Category', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          category: LinuxNotificationCategory.email,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'category': DBusString(details.category!.name),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Urgency', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          urgency: LinuxNotificationUrgency.normal,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'urgency': DBusByte(details.urgency!.index),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Resident notification', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          resident: true,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'resident': DBusBoolean(details.resident),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Suppress sound in details', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          suppressSound: true,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'suppress-sound': DBusBoolean(details.suppressSound),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Default suppress sound', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultSuppressSound: true,
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'suppress-sound': DBusBoolean(initSettings.defaultSuppressSound),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null);

        verifyNotifyMethod(values).called(1);
      });

      test('Transient notification', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          transient: true,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'transient': DBusBoolean(details.transient),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Notification location', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          location: LinuxNotificationLocation(50, 100),
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'x': DBusByte(details.location!.x),
            'y': DBusByte(details.location!.y),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Custom hints', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final LinuxNotificationDetails details = LinuxNotificationDetails(
          customHints: <LinuxNotificationCustomHint>[
            LinuxNotificationCustomHint(
              'array-hint',
              LinuxHintArrayValue<LinuxHintStringValue>(
                <LinuxHintStringValue>[
                  LinuxHintStringValue('1'),
                  LinuxHintStringValue('2'),
                ],
              ),
            ),
            LinuxNotificationCustomHint(
              'bool-hint',
              LinuxHintBoolValue(true),
            ),
            LinuxNotificationCustomHint(
              'byte-hint',
              LinuxHintByteValue(1),
            ),
            LinuxNotificationCustomHint(
              'dict-hint',
              LinuxHintDictValue<LinuxHintByteValue, LinuxHintStringValue>(
                <LinuxHintByteValue, LinuxHintStringValue>{
                  LinuxHintByteValue(1): LinuxHintStringValue('1'),
                  LinuxHintByteValue(2): LinuxHintStringValue('2'),
                },
              ),
            ),
            LinuxNotificationCustomHint(
              'double-hint',
              LinuxHintDoubleValue(1.1),
            ),
            LinuxNotificationCustomHint(
              'int16-hint',
              LinuxHintInt16Value(1),
            ),
            LinuxNotificationCustomHint(
              'int32-hint',
              LinuxHintInt32Value(1),
            ),
            LinuxNotificationCustomHint(
              'int64-hint',
              LinuxHintInt64Value(1),
            ),
            LinuxNotificationCustomHint(
              'string-hint',
              LinuxHintStringValue('test'),
            ),
            LinuxNotificationCustomHint(
              'struct-hint',
              LinuxHintStructValue(
                <LinuxHintValue>[
                  LinuxHintStringValue('test'),
                  LinuxHintBoolValue(true),
                ],
              ),
            ),
            LinuxNotificationCustomHint(
              'uint16-hint',
              LinuxHintUint16Value(1),
            ),
            LinuxNotificationCustomHint(
              'uint32-hint',
              LinuxHintUint32Value(1),
            ),
            LinuxNotificationCustomHint(
              'uint64-hint',
              LinuxHintUint64Value(1),
            ),
            LinuxNotificationCustomHint(
              'variant-hint',
              LinuxHintVariantValue(LinuxHintByteValue(1)),
            ),
          ],
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          hints: <String, DBusValue>{
            'array-hint': DBusArray(
              DBusSignature('s'),
              <DBusValue>[
                const DBusString('1'),
                const DBusString('2'),
              ],
            ),
            'bool-hint': const DBusBoolean(true),
            'byte-hint': const DBusByte(1),
            'dict-hint': DBusDict(
              DBusSignature('y'),
              DBusSignature('s'),
              <DBusValue, DBusValue>{
                const DBusByte(1): const DBusString('1'),
                const DBusByte(2): const DBusString('2'),
              },
            ),
            'double-hint': const DBusDouble(1.1),
            'int16-hint': const DBusInt16(1),
            'int32-hint': const DBusInt32(1),
            'int64-hint': const DBusInt64(1),
            'string-hint': const DBusString('test'),
            'struct-hint': DBusStruct(
              <DBusValue>[
                const DBusString('test'),
                const DBusBoolean(true),
              ],
            ),
            'uint16-hint': const DBusUint16(1),
            'uint32-hint': const DBusUint32(1),
            'uint64-hint': const DBusUint64(1),
            'variant-hint': const DBusVariant(DBusByte(1)),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('File path details icon', () async {
        final LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(
          defaultActionName: kDefaultActionName,
          defaultIcon: FilePathLinuxIcon('/foo/bar/icon.png'),
        );

        final LinuxNotificationDetails details = LinuxNotificationDetails(
          icon: FilePathLinuxIcon('/foo/bar/icon.png'),
        );

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        );

        final List<DBusValue> values =
            buildNotifyMethodValues(appIcon: '/foo/bar/icon.png');

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Notification actions', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
          actions: <LinuxNotificationActionInfo>[
            LinuxNotificationActionInfo(key: '1'),
            LinuxNotificationActionInfo(key: '2'),
          ],
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          actions: <LinuxNotificationAction>[
            LinuxNotificationAction(
              key: '1',
              label: 'action1',
            ),
            LinuxNotificationAction(
              key: '2',
              label: 'action2',
            ),
          ],
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          actions: <String>[
            '1',
            'action1',
            '2',
            'action2',
          ],
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });

      test('Notification action key as icon', () async {
        const LinuxInitializationSettings initSettings =
            LinuxInitializationSettings(defaultActionName: kDefaultActionName);

        const LinuxNotificationInfo notify = LinuxNotificationInfo(
          id: 0,
          systemId: 1,
          actions: <LinuxNotificationActionInfo>[
            LinuxNotificationActionInfo(key: 'media-eject'),
          ],
        );

        const LinuxNotificationDetails details = LinuxNotificationDetails(
          actions: <LinuxNotificationAction>[
            LinuxNotificationAction(
              key: 'media-eject',
              label: 'eject',
            ),
          ],
          actionKeyAsIconName: true,
        );

        final List<DBusValue> values = buildNotifyMethodValues(
          actions: <String>[
            'media-eject',
            'eject',
          ],
          hints: <String, DBusValue>{
            'action-icons': const DBusBoolean(true),
          },
        );

        mockNotifyMethod(notify.systemId);
        when(
          mockStorage.getById(notify.id),
        ).thenAnswer((_) async => null);
        when(
          mockStorage.insert(notify),
        ).thenAnswer((_) async => true);

        await manager.initialize(initSettings);
        await manager.show(notify.id, null, null, details: details);

        verifyNotifyMethod(values).called(1);
      });
    });

    test('Cancel', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: kDefaultActionName,
        defaultSuppressSound: true,
      );

      const LinuxNotificationInfo notify = LinuxNotificationInfo(
        id: 0,
        systemId: 1,
      );

      mockCloseMethod();

      when(
        mockStorage.getById(notify.id),
      ).thenAnswer((_) async => notify);
      when(
        mockStorage.removeById(notify.id),
      ).thenAnswer((_) async => true);

      await manager.initialize(initSettings);
      await manager.cancel(notify.id);

      verifyCloseMethod(notify.systemId).called(1);
      verify(
        mockStorage.removeById(notify.id),
      ).called(1);
    });

    test('Cancel all', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: kDefaultActionName,
      );

      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        ),
        LinuxNotificationInfo(
          id: 1,
          systemId: 2,
        ),
      ];

      mockCloseMethod();

      when(
        mockStorage.getAll(),
      ).thenAnswer((_) async => notifications);
      when(
        mockStorage.removeByIdList(
          notifications.map((LinuxNotificationInfo n) => n.id).toList(),
        ),
      ).thenAnswer((_) async => true);

      await manager.initialize(initSettings);
      await manager.cancelAll();

      for (final LinuxNotificationInfo notify in notifications) {
        verifyCloseMethod(notify.systemId).called(1);
      }
      verify(
        mockStorage.removeByIdList(
          notifications.map((LinuxNotificationInfo n) => n.id).toList(),
        ),
      ).called(1);
    });

    test('Notification closed by system', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: kDefaultActionName,
      );

      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        ),
        LinuxNotificationInfo(
          id: 1,
          systemId: 2,
        ),
      ];

      final List<Completer<void>> completers = <Completer<void>>[];
      for (final LinuxNotificationInfo notify in notifications) {
        when(
          mockStorage.removeBySystemId(notify.systemId),
        ).thenAnswer((_) async => true);
      }

      when(
        mockNotifyClosedSignal.listen(any),
      ).thenAnswer((Invocation invocation) {
        final Future<void> Function(DBusSignal) callback =
            invocation.positionalArguments.single;
        for (final LinuxNotificationInfo notify in notifications) {
          callback(
            DBusSignal(
              sender: '',
              path: DBusObjectPath('/org/freedesktop/Notifications'),
              interface: 'org.freedesktop.Notifications',
              name: 'NotificationClosed',
              values: <DBusValue>[
                DBusUint32(notify.systemId),
                const DBusUint32(1),
              ],
            ),
          ).then((_) {
            for (final Completer<void> completer in completers) {
              if (!completer.isCompleted) {
                completer.complete();
              }
            }
          });
        }
        return FakeStreamSubscription<DBusSignal>();
      });

      await manager.initialize(initSettings);
      await Future.forEach(
        completers,
        (Completer<void> completer) => completer.future,
      );

      for (final LinuxNotificationInfo notify in notifications) {
        verify(
          mockStorage.removeBySystemId(notify.systemId),
        ).called(1);
      }
    });

    test('Open notification', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: kDefaultActionName,
      );

      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(
          id: 0,
          systemId: 1,
          payload: 'payload1',
        ),
        LinuxNotificationInfo(
          id: 1,
          systemId: 2,
          payload: 'payload2',
        ),
      ];

      final List<Completer<void>> completers = <Completer<void>>[];
      for (final LinuxNotificationInfo notify in notifications) {
        when(
          mockStorage.getBySystemId(notify.systemId),
        ).thenAnswer((_) async => notify);
        completers.add(Completer<void>());
      }
      when(
        mockActionInvokedSignal.listen(any),
      ).thenAnswer((Invocation invocation) {
        final Future<void> Function(DBusSignal) callback =
            invocation.positionalArguments.single;
        for (final LinuxNotificationInfo notify in notifications) {
          callback(
            DBusSignal(
              sender: '',
              path: DBusObjectPath('/org/freedesktop/Notifications'),
              interface: 'org.freedesktop.Notifications',
              name: 'ActionInvoked',
              values: <DBusValue>[
                DBusUint32(notify.systemId),
                const DBusString('default'),
              ],
            ),
          ).then((_) {
            for (final Completer<void> completer in completers) {
              if (!completer.isCompleted) {
                completer.complete();
              }
            }
          });
        }
        return FakeStreamSubscription<DBusSignal>();
      });

      await manager.initialize(
        initSettings,
        onDidReceiveNotificationResponse:
            mockDidReceiveNotificationResponseCallback,
      );
      await Future.forEach(
        completers,
        (Completer<void> completer) => completer.future,
      );

      for (final LinuxNotificationInfo notify in notifications) {
        verify(
          mockStorage.getBySystemId(notify.systemId),
        ).called(1);
      }
    });

    test('Notification server capabilities', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(defaultActionName: kDefaultActionName);

      when(
        mockDbus.callMethod(
          'org.freedesktop.Notifications',
          'GetCapabilities',
          <DBusValue>[],
          replySignature: DBusSignature('as'),
        ),
      ).thenAnswer(
        (_) async => DBusMethodSuccessResponse(
          <DBusValue>[
            DBusArray(
              DBusSignature('s'),
              <DBusValue>[
                const DBusString('body'),
                const DBusString('body-hyperlinks'),
                const DBusString('body-images'),
                const DBusString('body-markup'),
                const DBusString('icon-multi'),
                const DBusString('icon-static'),
                const DBusString('persistence'),
                const DBusString('sound'),
                const DBusString('test-cap'),
                const DBusString('actions'),
                const DBusString('action-icons'),
              ],
            ),
          ],
        ),
      );

      await manager.initialize(initSettings);
      expect(
        await manager.getCapabilities(),
        const LinuxServerCapabilities(
          otherCapabilities: <String>{'test-cap'},
          body: true,
          bodyHyperlinks: true,
          bodyImages: true,
          bodyMarkup: true,
          iconMulti: true,
          iconStatic: true,
          persistence: true,
          sound: true,
          actions: true,
          actionIcons: true,
        ),
      );
    });

    test('Get system ID map', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: kDefaultActionName,
      );

      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(
          id: 0,
          systemId: 1,
        ),
        LinuxNotificationInfo(
          id: 1,
          systemId: 2,
        ),
      ];

      when(
        mockStorage.getAll(),
      ).thenAnswer((_) async => notifications);

      await manager.initialize(initSettings);
      expect(
        await manager.getSystemIdMap(),
        Map<int, int>.fromEntries(
          notifications.map(
            (LinuxNotificationInfo notify) => MapEntry<int, int>(
              notify.id,
              notify.systemId,
            ),
          ),
        ),
      );
    });

    test('Open notification action', () async {
      const LinuxInitializationSettings initSettings =
          LinuxInitializationSettings(
        defaultActionName: kDefaultActionName,
      );

      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(
          id: 0,
          systemId: 1,
          actions: <LinuxNotificationActionInfo>[
            LinuxNotificationActionInfo(key: '1'),
          ],
        ),
        LinuxNotificationInfo(
          id: 1,
          systemId: 2,
          actions: <LinuxNotificationActionInfo>[
            LinuxNotificationActionInfo(key: '2'),
          ],
        ),
      ];

      final List<Completer<void>> completers = <Completer<void>>[];
      for (final LinuxNotificationInfo notify in notifications) {
        when(
          mockStorage.getBySystemId(notify.systemId),
        ).thenAnswer((_) async => notify);
        completers.add(Completer<void>());
      }
      when(
        mockActionInvokedSignal.listen(any),
      ).thenAnswer((Invocation invocation) {
        final Future<void> Function(DBusSignal) callback =
            invocation.positionalArguments.single;
        for (final LinuxNotificationInfo notify in notifications) {
          callback(
            DBusSignal(
              sender: '',
              path: DBusObjectPath('/org/freedesktop/Notifications'),
              interface: 'org.freedesktop.Notifications',
              name: 'ActionInvoked',
              values: <DBusValue>[
                DBusUint32(notify.systemId),
                DBusString(notify.actions[0].key),
              ],
            ),
          ).then((_) {
            for (final Completer<void> completer in completers) {
              if (!completer.isCompleted) {
                completer.complete();
              }
            }
          });
        }
        return FakeStreamSubscription<DBusSignal>();
      });

      await manager.initialize(
        initSettings,
        onDidReceiveNotificationResponse:
            mockDidReceiveNotificationResponseCallback,
      );
      await Future.forEach(
        completers,
        (Completer<void> completer) => completer.future,
      );

      for (final LinuxNotificationInfo notify in notifications) {
        verify(
          mockStorage.getBySystemId(notify.systemId),
        ).called(1);
      }
    });
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\test\notifications_manager_test.mocks.dart =====
// Mocks generated by Mockito 5.4.0 from annotations
// in flutter_local_notifications_linux/test/notifications_manager_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:dbus/dbus.dart' as _i2;
import 'package:flutter_local_notifications_linux/src/dbus_wrapper.dart' as _i5;
import 'package:flutter_local_notifications_linux/src/notification_info.dart'
    as _i7;
import 'package:flutter_local_notifications_linux/src/platform_info.dart'
    as _i4;
import 'package:flutter_local_notifications_linux/src/storage.dart' as _i6;
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart'
    as _i9;
import 'package:mockito/mockito.dart' as _i1;

import 'notifications_manager_test.dart' as _i8;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeDBusMethodSuccessResponse_0 extends _i1.SmartFake
    implements _i2.DBusMethodSuccessResponse {
  _FakeDBusMethodSuccessResponse_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeDBusRemoteObjectSignalStream_1 extends _i1.SmartFake
    implements _i2.DBusRemoteObjectSignalStream {
  _FakeDBusRemoteObjectSignalStream_1(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeDBusSignal_2 extends _i1.SmartFake implements _i2.DBusSignal {
  _FakeDBusSignal_2(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeStreamSubscription_3<T> extends _i1.SmartFake
    implements _i3.StreamSubscription<T> {
  _FakeStreamSubscription_3(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeFuture_4<T> extends _i1.SmartFake implements _i3.Future<T> {
  _FakeFuture_4(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeLinuxPlatformInfoData_5 extends _i1.SmartFake
    implements _i4.LinuxPlatformInfoData {
  _FakeLinuxPlatformInfoData_5(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [DBusWrapper].
///
/// See the documentation for Mockito's code generation for more information.
class MockDBusWrapper extends _i1.Mock implements _i5.DBusWrapper {
  @override
  void build({
    required String? destination,
    required String? path,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #build,
          [],
          {
            #destination: destination,
            #path: path,
          },
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i3.Future<_i2.DBusMethodSuccessResponse> callMethod(
    String? interface,
    String? name,
    Iterable<_i2.DBusValue>? values, {
    _i2.DBusSignature? replySignature,
    bool? noReplyExpected = false,
    bool? noAutoStart = false,
    bool? allowInteractiveAuthorization = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #callMethod,
          [
            interface,
            name,
            values,
          ],
          {
            #replySignature: replySignature,
            #noReplyExpected: noReplyExpected,
            #noAutoStart: noAutoStart,
            #allowInteractiveAuthorization: allowInteractiveAuthorization,
          },
        ),
        returnValue: _i3.Future<_i2.DBusMethodSuccessResponse>.value(
            _FakeDBusMethodSuccessResponse_0(
          this,
          Invocation.method(
            #callMethod,
            [
              interface,
              name,
              values,
            ],
            {
              #replySignature: replySignature,
              #noReplyExpected: noReplyExpected,
              #noAutoStart: noAutoStart,
              #allowInteractiveAuthorization: allowInteractiveAuthorization,
            },
          ),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusMethodSuccessResponse>.value(
                _FakeDBusMethodSuccessResponse_0(
          this,
          Invocation.method(
            #callMethod,
            [
              interface,
              name,
              values,
            ],
            {
              #replySignature: replySignature,
              #noReplyExpected: noReplyExpected,
              #noAutoStart: noAutoStart,
              #allowInteractiveAuthorization: allowInteractiveAuthorization,
            },
          ),
        )),
      ) as _i3.Future<_i2.DBusMethodSuccessResponse>);
  @override
  _i2.DBusRemoteObjectSignalStream subscribeSignal(String? name) =>
      (super.noSuchMethod(
        Invocation.method(
          #subscribeSignal,
          [name],
        ),
        returnValue: _FakeDBusRemoteObjectSignalStream_1(
          this,
          Invocation.method(
            #subscribeSignal,
            [name],
          ),
        ),
        returnValueForMissingStub: _FakeDBusRemoteObjectSignalStream_1(
          this,
          Invocation.method(
            #subscribeSignal,
            [name],
          ),
        ),
      ) as _i2.DBusRemoteObjectSignalStream);
}

/// A class which mocks [DBusRemoteObjectSignalStream].
///
/// See the documentation for Mockito's code generation for more information.
class MockDBusRemoteObjectSignalStream extends _i1.Mock
    implements _i2.DBusRemoteObjectSignalStream {
  @override
  bool get isBroadcast => (super.noSuchMethod(
        Invocation.getter(#isBroadcast),
        returnValue: false,
        returnValueForMissingStub: false,
      ) as bool);
  @override
  _i3.Future<int> get length => (super.noSuchMethod(
        Invocation.getter(#length),
        returnValue: _i3.Future<int>.value(0),
        returnValueForMissingStub: _i3.Future<int>.value(0),
      ) as _i3.Future<int>);
  @override
  _i3.Future<bool> get isEmpty => (super.noSuchMethod(
        Invocation.getter(#isEmpty),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<_i2.DBusSignal> get first => (super.noSuchMethod(
        Invocation.getter(#first),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.getter(#first),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.getter(#first),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Future<_i2.DBusSignal> get last => (super.noSuchMethod(
        Invocation.getter(#last),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.getter(#last),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.getter(#last),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Future<_i2.DBusSignal> get single => (super.noSuchMethod(
        Invocation.getter(#single),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.getter(#single),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.getter(#single),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.StreamSubscription<_i2.DBusSignal> listen(
    void Function(_i2.DBusSignal)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #listen,
          [onData],
          {
            #onError: onError,
            #onDone: onDone,
            #cancelOnError: cancelOnError,
          },
        ),
        returnValue: _FakeStreamSubscription_3<_i2.DBusSignal>(
          this,
          Invocation.method(
            #listen,
            [onData],
            {
              #onError: onError,
              #onDone: onDone,
              #cancelOnError: cancelOnError,
            },
          ),
        ),
        returnValueForMissingStub: _FakeStreamSubscription_3<_i2.DBusSignal>(
          this,
          Invocation.method(
            #listen,
            [onData],
            {
              #onError: onError,
              #onDone: onDone,
              #cancelOnError: cancelOnError,
            },
          ),
        ),
      ) as _i3.StreamSubscription<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> asBroadcastStream({
    void Function(_i3.StreamSubscription<_i2.DBusSignal>)? onListen,
    void Function(_i3.StreamSubscription<_i2.DBusSignal>)? onCancel,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #asBroadcastStream,
          [],
          {
            #onListen: onListen,
            #onCancel: onCancel,
          },
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> where(bool Function(_i2.DBusSignal)? test) =>
      (super.noSuchMethod(
        Invocation.method(
          #where,
          [test],
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<S> map<S>(S Function(_i2.DBusSignal)? convert) =>
      (super.noSuchMethod(
        Invocation.method(
          #map,
          [convert],
        ),
        returnValue: _i3.Stream<S>.empty(),
        returnValueForMissingStub: _i3.Stream<S>.empty(),
      ) as _i3.Stream<S>);
  @override
  _i3.Stream<E> asyncMap<E>(
          _i3.FutureOr<E> Function(_i2.DBusSignal)? convert) =>
      (super.noSuchMethod(
        Invocation.method(
          #asyncMap,
          [convert],
        ),
        returnValue: _i3.Stream<E>.empty(),
        returnValueForMissingStub: _i3.Stream<E>.empty(),
      ) as _i3.Stream<E>);
  @override
  _i3.Stream<E> asyncExpand<E>(
          _i3.Stream<E>? Function(_i2.DBusSignal)? convert) =>
      (super.noSuchMethod(
        Invocation.method(
          #asyncExpand,
          [convert],
        ),
        returnValue: _i3.Stream<E>.empty(),
        returnValueForMissingStub: _i3.Stream<E>.empty(),
      ) as _i3.Stream<E>);
  @override
  _i3.Stream<_i2.DBusSignal> handleError(
    Function? onError, {
    bool Function(dynamic)? test,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #handleError,
          [onError],
          {#test: test},
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<S> expand<S>(Iterable<S> Function(_i2.DBusSignal)? convert) =>
      (super.noSuchMethod(
        Invocation.method(
          #expand,
          [convert],
        ),
        returnValue: _i3.Stream<S>.empty(),
        returnValueForMissingStub: _i3.Stream<S>.empty(),
      ) as _i3.Stream<S>);
  @override
  _i3.Future<dynamic> pipe(
          _i3.StreamConsumer<_i2.DBusSignal>? streamConsumer) =>
      (super.noSuchMethod(
        Invocation.method(
          #pipe,
          [streamConsumer],
        ),
        returnValue: _i3.Future<dynamic>.value(),
        returnValueForMissingStub: _i3.Future<dynamic>.value(),
      ) as _i3.Future<dynamic>);
  @override
  _i3.Stream<S> transform<S>(
          _i3.StreamTransformer<_i2.DBusSignal, S>? streamTransformer) =>
      (super.noSuchMethod(
        Invocation.method(
          #transform,
          [streamTransformer],
        ),
        returnValue: _i3.Stream<S>.empty(),
        returnValueForMissingStub: _i3.Stream<S>.empty(),
      ) as _i3.Stream<S>);
  @override
  _i3.Future<_i2.DBusSignal> reduce(
          _i2.DBusSignal Function(
            _i2.DBusSignal,
            _i2.DBusSignal,
          )? combine) =>
      (super.noSuchMethod(
        Invocation.method(
          #reduce,
          [combine],
        ),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #reduce,
            [combine],
          ),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #reduce,
            [combine],
          ),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Future<S> fold<S>(
    S? initialValue,
    S Function(
      S,
      _i2.DBusSignal,
    )? combine,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #fold,
          [
            initialValue,
            combine,
          ],
        ),
        returnValue: _FakeFuture_4<S>(
          this,
          Invocation.method(
            #fold,
            [
              initialValue,
              combine,
            ],
          ),
        ),
        returnValueForMissingStub: _FakeFuture_4<S>(
          this,
          Invocation.method(
            #fold,
            [
              initialValue,
              combine,
            ],
          ),
        ),
      ) as _i3.Future<S>);
  @override
  _i3.Future<String> join([String? separator = r'']) => (super.noSuchMethod(
        Invocation.method(
          #join,
          [separator],
        ),
        returnValue: _i3.Future<String>.value(''),
        returnValueForMissingStub: _i3.Future<String>.value(''),
      ) as _i3.Future<String>);
  @override
  _i3.Future<bool> contains(Object? needle) => (super.noSuchMethod(
        Invocation.method(
          #contains,
          [needle],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<dynamic> forEach(void Function(_i2.DBusSignal)? action) =>
      (super.noSuchMethod(
        Invocation.method(
          #forEach,
          [action],
        ),
        returnValue: _i3.Future<dynamic>.value(),
        returnValueForMissingStub: _i3.Future<dynamic>.value(),
      ) as _i3.Future<dynamic>);
  @override
  _i3.Future<bool> every(bool Function(_i2.DBusSignal)? test) =>
      (super.noSuchMethod(
        Invocation.method(
          #every,
          [test],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<bool> any(bool Function(_i2.DBusSignal)? test) =>
      (super.noSuchMethod(
        Invocation.method(
          #any,
          [test],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Stream<R> cast<R>() => (super.noSuchMethod(
        Invocation.method(
          #cast,
          [],
        ),
        returnValue: _i3.Stream<R>.empty(),
        returnValueForMissingStub: _i3.Stream<R>.empty(),
      ) as _i3.Stream<R>);
  @override
  _i3.Future<List<_i2.DBusSignal>> toList() => (super.noSuchMethod(
        Invocation.method(
          #toList,
          [],
        ),
        returnValue: _i3.Future<List<_i2.DBusSignal>>.value(<_i2.DBusSignal>[]),
        returnValueForMissingStub:
            _i3.Future<List<_i2.DBusSignal>>.value(<_i2.DBusSignal>[]),
      ) as _i3.Future<List<_i2.DBusSignal>>);
  @override
  _i3.Future<Set<_i2.DBusSignal>> toSet() => (super.noSuchMethod(
        Invocation.method(
          #toSet,
          [],
        ),
        returnValue: _i3.Future<Set<_i2.DBusSignal>>.value(<_i2.DBusSignal>{}),
        returnValueForMissingStub:
            _i3.Future<Set<_i2.DBusSignal>>.value(<_i2.DBusSignal>{}),
      ) as _i3.Future<Set<_i2.DBusSignal>>);
  @override
  _i3.Future<E> drain<E>([E? futureValue]) => (super.noSuchMethod(
        Invocation.method(
          #drain,
          [futureValue],
        ),
        returnValue: _FakeFuture_4<E>(
          this,
          Invocation.method(
            #drain,
            [futureValue],
          ),
        ),
        returnValueForMissingStub: _FakeFuture_4<E>(
          this,
          Invocation.method(
            #drain,
            [futureValue],
          ),
        ),
      ) as _i3.Future<E>);
  @override
  _i3.Stream<_i2.DBusSignal> take(int? count) => (super.noSuchMethod(
        Invocation.method(
          #take,
          [count],
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> takeWhile(bool Function(_i2.DBusSignal)? test) =>
      (super.noSuchMethod(
        Invocation.method(
          #takeWhile,
          [test],
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> skip(int? count) => (super.noSuchMethod(
        Invocation.method(
          #skip,
          [count],
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> skipWhile(bool Function(_i2.DBusSignal)? test) =>
      (super.noSuchMethod(
        Invocation.method(
          #skipWhile,
          [test],
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> distinct(
          [bool Function(
            _i2.DBusSignal,
            _i2.DBusSignal,
          )? equals]) =>
      (super.noSuchMethod(
        Invocation.method(
          #distinct,
          [equals],
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
  @override
  _i3.Future<_i2.DBusSignal> firstWhere(
    bool Function(_i2.DBusSignal)? test, {
    _i2.DBusSignal Function()? orElse,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #firstWhere,
          [test],
          {#orElse: orElse},
        ),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #firstWhere,
            [test],
            {#orElse: orElse},
          ),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #firstWhere,
            [test],
            {#orElse: orElse},
          ),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Future<_i2.DBusSignal> lastWhere(
    bool Function(_i2.DBusSignal)? test, {
    _i2.DBusSignal Function()? orElse,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #lastWhere,
          [test],
          {#orElse: orElse},
        ),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #lastWhere,
            [test],
            {#orElse: orElse},
          ),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #lastWhere,
            [test],
            {#orElse: orElse},
          ),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Future<_i2.DBusSignal> singleWhere(
    bool Function(_i2.DBusSignal)? test, {
    _i2.DBusSignal Function()? orElse,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #singleWhere,
          [test],
          {#orElse: orElse},
        ),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #singleWhere,
            [test],
            {#orElse: orElse},
          ),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #singleWhere,
            [test],
            {#orElse: orElse},
          ),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Future<_i2.DBusSignal> elementAt(int? index) => (super.noSuchMethod(
        Invocation.method(
          #elementAt,
          [index],
        ),
        returnValue: _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #elementAt,
            [index],
          ),
        )),
        returnValueForMissingStub:
            _i3.Future<_i2.DBusSignal>.value(_FakeDBusSignal_2(
          this,
          Invocation.method(
            #elementAt,
            [index],
          ),
        )),
      ) as _i3.Future<_i2.DBusSignal>);
  @override
  _i3.Stream<_i2.DBusSignal> timeout(
    Duration? timeLimit, {
    void Function(_i3.EventSink<_i2.DBusSignal>)? onTimeout,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #timeout,
          [timeLimit],
          {#onTimeout: onTimeout},
        ),
        returnValue: _i3.Stream<_i2.DBusSignal>.empty(),
        returnValueForMissingStub: _i3.Stream<_i2.DBusSignal>.empty(),
      ) as _i3.Stream<_i2.DBusSignal>);
}

/// A class which mocks [LinuxPlatformInfo].
///
/// See the documentation for Mockito's code generation for more information.
class MockLinuxPlatformInfo extends _i1.Mock implements _i4.LinuxPlatformInfo {
  @override
  _i3.Future<_i4.LinuxPlatformInfoData> getAll() => (super.noSuchMethod(
        Invocation.method(
          #getAll,
          [],
        ),
        returnValue: _i3.Future<_i4.LinuxPlatformInfoData>.value(
            _FakeLinuxPlatformInfoData_5(
          this,
          Invocation.method(
            #getAll,
            [],
          ),
        )),
        returnValueForMissingStub: _i3.Future<_i4.LinuxPlatformInfoData>.value(
            _FakeLinuxPlatformInfoData_5(
          this,
          Invocation.method(
            #getAll,
            [],
          ),
        )),
      ) as _i3.Future<_i4.LinuxPlatformInfoData>);
}

/// A class which mocks [NotificationStorage].
///
/// See the documentation for Mockito's code generation for more information.
class MockNotificationStorage extends _i1.Mock
    implements _i6.NotificationStorage {
  @override
  _i3.Future<List<_i7.LinuxNotificationInfo>> getAll() => (super.noSuchMethod(
        Invocation.method(
          #getAll,
          [],
        ),
        returnValue: _i3.Future<List<_i7.LinuxNotificationInfo>>.value(
            <_i7.LinuxNotificationInfo>[]),
        returnValueForMissingStub:
            _i3.Future<List<_i7.LinuxNotificationInfo>>.value(
                <_i7.LinuxNotificationInfo>[]),
      ) as _i3.Future<List<_i7.LinuxNotificationInfo>>);
  @override
  _i3.Future<_i7.LinuxNotificationInfo?> getBySystemId(int? systemId) =>
      (super.noSuchMethod(
        Invocation.method(
          #getBySystemId,
          [systemId],
        ),
        returnValue: _i3.Future<_i7.LinuxNotificationInfo?>.value(),
        returnValueForMissingStub:
            _i3.Future<_i7.LinuxNotificationInfo?>.value(),
      ) as _i3.Future<_i7.LinuxNotificationInfo?>);
  @override
  _i3.Future<_i7.LinuxNotificationInfo?> getById(int? id) =>
      (super.noSuchMethod(
        Invocation.method(
          #getById,
          [id],
        ),
        returnValue: _i3.Future<_i7.LinuxNotificationInfo?>.value(),
        returnValueForMissingStub:
            _i3.Future<_i7.LinuxNotificationInfo?>.value(),
      ) as _i3.Future<_i7.LinuxNotificationInfo?>);
  @override
  _i3.Future<bool> insert(_i7.LinuxNotificationInfo? notification) =>
      (super.noSuchMethod(
        Invocation.method(
          #insert,
          [notification],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<bool> removeById(int? id) => (super.noSuchMethod(
        Invocation.method(
          #removeById,
          [id],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<bool> removeBySystemId(int? systemId) => (super.noSuchMethod(
        Invocation.method(
          #removeBySystemId,
          [systemId],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<bool> removeByIdList(List<int>? idList) => (super.noSuchMethod(
        Invocation.method(
          #removeByIdList,
          [idList],
        ),
        returnValue: _i3.Future<bool>.value(false),
        returnValueForMissingStub: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);
  @override
  _i3.Future<void> forceReloadCache() => (super.noSuchMethod(
        Invocation.method(
          #forceReloadCache,
          [],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);
}

/// A class which mocks [DidReceiveNotificationResponseCallback].
///
/// See the documentation for Mockito's code generation for more information.
class MockDidReceiveNotificationResponseCallback extends _i1.Mock
    implements _i8.DidReceiveNotificationResponseCallback {
  @override
  _i3.Future<dynamic> call(_i9.NotificationResponse? notificationResponse) =>
      (super.noSuchMethod(
        Invocation.method(
          #call,
          [notificationResponse],
        ),
        returnValue: _i3.Future<dynamic>.value(),
        returnValueForMissingStub: _i3.Future<dynamic>.value(),
      ) as _i3.Future<dynamic>);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\test\posix_test.dart =====
import 'dart:io';

import 'package:flutter_local_notifications_linux/src/posix.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('POSIX |', () {
    late Posix posix;

    setUpAll(() {
      posix = Posix();
    });

    test('getpid', () {
      expect(posix.getpid(), equals(pid));
    });
  }, skip: !Platform.isLinux);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\test\storage_test.dart =====
import 'dart:convert';
import 'dart:io';

import 'package:flutter_local_notifications_linux/src/file_system.dart';
import 'package:flutter_local_notifications_linux/src/notification_info.dart';
import 'package:flutter_local_notifications_linux/src/platform_info.dart';
import 'package:flutter_local_notifications_linux/src/storage.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:path/path.dart' as path;

@GenerateNiceMocks(<MockSpec<Object>>[
  MockSpec<LinuxPlatformInfo>(),
  MockSpec<FileSystem>(),
  MockSpec<File>(),
])
import 'storage_test.mocks.dart';

void main() {
  group('Notification storage |', () {
    late NotificationStorage storage;
    late final MockLinuxPlatformInfo mockPlatformInfo;
    late final MockFileSystem mockFs;
    late final MockFile mockStorageFile;

    const LinuxPlatformInfoData platformInfo = LinuxPlatformInfoData(
      appName: 'Test',
      assetsPath: 'assets',
      runtimePath: 'run',
    );

    final String fileStoragePath = path.join(
      platformInfo.runtimePath!,
      'notification_plugin_cache.json',
    );

    setUpAll(() {
      mockPlatformInfo = MockLinuxPlatformInfo();
      mockFs = MockFileSystem();
      mockStorageFile = MockFile();

      when(
        mockPlatformInfo.getAll(),
      ).thenAnswer((_) async => platformInfo);
      when(mockFs.open(fileStoragePath)).thenReturn(mockStorageFile);
    });

    setUp(() {
      storage = NotificationStorage(
        platformInfo: mockPlatformInfo,
        fs: mockFs,
      );
    });

    test('Insert', () async {
      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(id: 1, systemId: 1),
        LinuxNotificationInfo(
          id: 2,
          systemId: 2,
          payload: 'test',
        ),
        LinuxNotificationInfo(
          id: 3,
          systemId: 3,
          payload: 'test',
          actions: <LinuxNotificationActionInfo>[
            LinuxNotificationActionInfo(key: '1'),
            LinuxNotificationActionInfo(key: '2'),
          ],
        ),
      ];

      when(mockStorageFile.existsSync()).thenReturn(false);
      when(
        mockStorageFile.createSync(recursive: true),
      ).thenAnswer((_) {});
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});
      when(mockStorageFile.readAsStringSync()).thenReturn('');

      expect(await storage.insert(notifications[0]), isTrue);
      expect(await storage.insert(notifications[1]), isTrue);
      expect(await storage.insert(notifications[2]), isTrue);

      verify(
        mockStorageFile.createSync(recursive: true),
      ).called(3);
      verify(
        mockStorageFile.writeAsStringSync(
          jsonEncode(<LinuxNotificationInfo>[notifications[0]]),
        ),
      ).called(1);
      verify(
        mockStorageFile.writeAsStringSync(jsonEncode(notifications)),
      ).called(1);
    });

    test('Remove', () async {
      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(id: 1, systemId: 1),
        LinuxNotificationInfo(
          id: 2,
          systemId: 2,
          payload: 'test',
        ),
      ];

      when(mockStorageFile.existsSync()).thenReturn(true);
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});
      when(mockStorageFile.readAsStringSync()).thenReturn('');

      await storage.insert(notifications[0]);
      await storage.insert(notifications[1]);

      expect(await storage.removeById(notifications[0].id), isTrue);
      expect(await storage.removeById(notifications[1].id), isTrue);

      verify(
        mockStorageFile.writeAsStringSync(
          jsonEncode(<LinuxNotificationInfo>[notifications[1]]),
        ),
      ).called(1);
      verify(
        mockStorageFile.writeAsStringSync(
          jsonEncode(<LinuxNotificationInfo>[]),
        ),
      ).called(1);
    });

    test('Get all', () async {
      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(id: 1, systemId: 1),
        LinuxNotificationInfo(
          id: 2,
          systemId: 2,
          payload: 'test',
        ),
        LinuxNotificationInfo(
            id: 3,
            systemId: 3,
            payload: 'test',
            actions: <LinuxNotificationActionInfo>[
              LinuxNotificationActionInfo(key: '1'),
              LinuxNotificationActionInfo(key: '2'),
            ]),
      ];

      when(mockStorageFile.existsSync()).thenReturn(true);
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});

      when(mockStorageFile.readAsStringSync()).thenReturn('');
      expect(await storage.getAll(), <LinuxNotificationInfo>[]);

      when(
        mockStorageFile.readAsStringSync(),
      ).thenReturn(jsonEncode(<LinuxNotificationInfo>[]));
      expect(await storage.getAll(), <LinuxNotificationInfo>[]);

      when(
        mockStorageFile.readAsStringSync(),
      ).thenReturn(jsonEncode(notifications));
      await storage.insert(notifications[0]);
      await storage.insert(notifications[1]);
      await storage.insert(notifications[2]);

      expect(
        await storage.getAll(),
        notifications,
      );
    });

    test('Get by ID', () async {
      const LinuxNotificationInfo notification = LinuxNotificationInfo(
        id: 1,
        systemId: 1,
      );

      when(mockStorageFile.existsSync()).thenReturn(true);
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});

      when(mockStorageFile.readAsStringSync()).thenReturn('');
      expect(await storage.getAll(), <LinuxNotificationInfo>[]);

      when(
        mockStorageFile.readAsStringSync(),
      ).thenReturn(jsonEncode(<LinuxNotificationInfo>[]));
      expect(await storage.getAll(), <LinuxNotificationInfo>[]);

      when(
        mockStorageFile.readAsStringSync(),
      ).thenReturn(jsonEncode(notification));
      await storage.insert(notification);

      expect(await storage.getById(2), isNull);
      expect(await storage.getById(notification.id), notification);
    });

    test('Get by system ID', () async {
      const LinuxNotificationInfo notification = LinuxNotificationInfo(
        id: 1,
        systemId: 2,
      );

      when(mockStorageFile.existsSync()).thenReturn(true);
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});

      when(
        mockStorageFile.readAsStringSync(),
      ).thenReturn(jsonEncode(notification));
      await storage.insert(notification);

      expect(await storage.getBySystemId(notification.systemId), notification);
    });

    test('Get all, file does not exist', () async {
      when(mockStorageFile.existsSync()).thenReturn(false);
      expect(await storage.getAll(), <LinuxNotificationInfo>[]);
    });

    test('Remove by ID list', () async {
      const List<LinuxNotificationInfo> notifications = <LinuxNotificationInfo>[
        LinuxNotificationInfo(id: 1, systemId: 1),
        LinuxNotificationInfo(
          id: 2,
          systemId: 2,
          payload: 'test',
        ),
      ];

      when(mockStorageFile.existsSync()).thenReturn(true);
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});
      when(mockStorageFile.readAsStringSync()).thenReturn('');

      await storage.insert(notifications[0]);
      await storage.insert(notifications[1]);

      expect(
        await storage.removeByIdList(
          notifications.map((LinuxNotificationInfo n) => n.id).toList(),
        ),
        isTrue,
      );
      expect(await storage.getAll(), <LinuxNotificationInfo>[]);

      verify(
        mockStorageFile.writeAsStringSync(
          jsonEncode(<LinuxNotificationInfo>[]),
        ),
      ).called(1);
    });

    test('Remove by system ID', () async {
      const LinuxNotificationInfo notification = LinuxNotificationInfo(
        id: 1,
        systemId: 2,
      );

      when(mockStorageFile.existsSync()).thenReturn(true);
      when(
        mockStorageFile.writeAsStringSync(any),
      ).thenAnswer((_) {});
      when(mockStorageFile.readAsStringSync()).thenReturn('');

      await storage.insert(notification);

      expect(await storage.removeBySystemId(notification.systemId), isTrue);

      verify(
        mockStorageFile.writeAsStringSync(
          jsonEncode(<LinuxNotificationInfo>[]),
        ),
      ).called(1);
    });
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_linux\test\storage_test.mocks.dart =====
// Mocks generated by Mockito 5.4.0 from annotations
// in flutter_local_notifications_linux/test/storage_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i4;
import 'dart:convert' as _i6;
import 'dart:io' as _i3;
import 'dart:typed_data' as _i7;

import 'package:flutter_local_notifications_linux/src/file_system.dart' as _i5;
import 'package:flutter_local_notifications_linux/src/platform_info.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeLinuxPlatformInfoData_0 extends _i1.SmartFake
    implements _i2.LinuxPlatformInfoData {
  _FakeLinuxPlatformInfoData_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeFile_1 extends _i1.SmartFake implements _i3.File {
  _FakeFile_1(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeUri_2 extends _i1.SmartFake implements Uri {
  _FakeUri_2(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeDirectory_3 extends _i1.SmartFake implements _i3.Directory {
  _FakeDirectory_3(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeDateTime_4 extends _i1.SmartFake implements DateTime {
  _FakeDateTime_4(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeRandomAccessFile_5 extends _i1.SmartFake
    implements _i3.RandomAccessFile {
  _FakeRandomAccessFile_5(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeIOSink_6 extends _i1.SmartFake implements _i3.IOSink {
  _FakeIOSink_6(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeFileStat_7 extends _i1.SmartFake implements _i3.FileStat {
  _FakeFileStat_7(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeFileSystemEntity_8 extends _i1.SmartFake
    implements _i3.FileSystemEntity {
  _FakeFileSystemEntity_8(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [LinuxPlatformInfo].
///
/// See the documentation for Mockito's code generation for more information.
class MockLinuxPlatformInfo extends _i1.Mock implements _i2.LinuxPlatformInfo {
  @override
  _i4.Future<_i2.LinuxPlatformInfoData> getAll() => (super.noSuchMethod(
        Invocation.method(
          #getAll,
          [],
        ),
        returnValue: _i4.Future<_i2.LinuxPlatformInfoData>.value(
            _FakeLinuxPlatformInfoData_0(
          this,
          Invocation.method(
            #getAll,
            [],
          ),
        )),
        returnValueForMissingStub: _i4.Future<_i2.LinuxPlatformInfoData>.value(
            _FakeLinuxPlatformInfoData_0(
          this,
          Invocation.method(
            #getAll,
            [],
          ),
        )),
      ) as _i4.Future<_i2.LinuxPlatformInfoData>);
}

/// A class which mocks [FileSystem].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSystem extends _i1.Mock implements _i5.FileSystem {
  @override
  _i3.File open(String? path) => (super.noSuchMethod(
        Invocation.method(
          #open,
          [path],
        ),
        returnValue: _FakeFile_1(
          this,
          Invocation.method(
            #open,
            [path],
          ),
        ),
        returnValueForMissingStub: _FakeFile_1(
          this,
          Invocation.method(
            #open,
            [path],
          ),
        ),
      ) as _i3.File);
}

/// A class which mocks [File].
///
/// See the documentation for Mockito's code generation for more information.
class MockFile extends _i1.Mock implements _i3.File {
  @override
  _i3.File get absolute => (super.noSuchMethod(
        Invocation.getter(#absolute),
        returnValue: _FakeFile_1(
          this,
          Invocation.getter(#absolute),
        ),
        returnValueForMissingStub: _FakeFile_1(
          this,
          Invocation.getter(#absolute),
        ),
      ) as _i3.File);
  @override
  String get path => (super.noSuchMethod(
        Invocation.getter(#path),
        returnValue: '',
        returnValueForMissingStub: '',
      ) as String);
  @override
  Uri get uri => (super.noSuchMethod(
        Invocation.getter(#uri),
        returnValue: _FakeUri_2(
          this,
          Invocation.getter(#uri),
        ),
        returnValueForMissingStub: _FakeUri_2(
          this,
          Invocation.getter(#uri),
        ),
      ) as Uri);
  @override
  bool get isAbsolute => (super.noSuchMethod(
        Invocation.getter(#isAbsolute),
        returnValue: false,
        returnValueForMissingStub: false,
      ) as bool);
  @override
  _i3.Directory get parent => (super.noSuchMethod(
        Invocation.getter(#parent),
        returnValue: _FakeDirectory_3(
          this,
          Invocation.getter(#parent),
        ),
        returnValueForMissingStub: _FakeDirectory_3(
          this,
          Invocation.getter(#parent),
        ),
      ) as _i3.Directory);
  @override
  _i4.Future<_i3.File> create({
    bool? recursive = false,
    bool? exclusive = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #create,
          [],
          {
            #recursive: recursive,
            #exclusive: exclusive,
          },
        ),
        returnValue: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #create,
            [],
            {
              #recursive: recursive,
              #exclusive: exclusive,
            },
          ),
        )),
        returnValueForMissingStub: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #create,
            [],
            {
              #recursive: recursive,
              #exclusive: exclusive,
            },
          ),
        )),
      ) as _i4.Future<_i3.File>);
  @override
  void createSync({
    bool? recursive = false,
    bool? exclusive = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #createSync,
          [],
          {
            #recursive: recursive,
            #exclusive: exclusive,
          },
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i4.Future<_i3.File> rename(String? newPath) => (super.noSuchMethod(
        Invocation.method(
          #rename,
          [newPath],
        ),
        returnValue: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #rename,
            [newPath],
          ),
        )),
        returnValueForMissingStub: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #rename,
            [newPath],
          ),
        )),
      ) as _i4.Future<_i3.File>);
  @override
  _i3.File renameSync(String? newPath) => (super.noSuchMethod(
        Invocation.method(
          #renameSync,
          [newPath],
        ),
        returnValue: _FakeFile_1(
          this,
          Invocation.method(
            #renameSync,
            [newPath],
          ),
        ),
        returnValueForMissingStub: _FakeFile_1(
          this,
          Invocation.method(
            #renameSync,
            [newPath],
          ),
        ),
      ) as _i3.File);
  @override
  _i4.Future<_i3.File> copy(String? newPath) => (super.noSuchMethod(
        Invocation.method(
          #copy,
          [newPath],
        ),
        returnValue: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #copy,
            [newPath],
          ),
        )),
        returnValueForMissingStub: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #copy,
            [newPath],
          ),
        )),
      ) as _i4.Future<_i3.File>);
  @override
  _i3.File copySync(String? newPath) => (super.noSuchMethod(
        Invocation.method(
          #copySync,
          [newPath],
        ),
        returnValue: _FakeFile_1(
          this,
          Invocation.method(
            #copySync,
            [newPath],
          ),
        ),
        returnValueForMissingStub: _FakeFile_1(
          this,
          Invocation.method(
            #copySync,
            [newPath],
          ),
        ),
      ) as _i3.File);
  @override
  _i4.Future<int> length() => (super.noSuchMethod(
        Invocation.method(
          #length,
          [],
        ),
        returnValue: _i4.Future<int>.value(0),
        returnValueForMissingStub: _i4.Future<int>.value(0),
      ) as _i4.Future<int>);
  @override
  int lengthSync() => (super.noSuchMethod(
        Invocation.method(
          #lengthSync,
          [],
        ),
        returnValue: 0,
        returnValueForMissingStub: 0,
      ) as int);
  @override
  _i4.Future<DateTime> lastAccessed() => (super.noSuchMethod(
        Invocation.method(
          #lastAccessed,
          [],
        ),
        returnValue: _i4.Future<DateTime>.value(_FakeDateTime_4(
          this,
          Invocation.method(
            #lastAccessed,
            [],
          ),
        )),
        returnValueForMissingStub: _i4.Future<DateTime>.value(_FakeDateTime_4(
          this,
          Invocation.method(
            #lastAccessed,
            [],
          ),
        )),
      ) as _i4.Future<DateTime>);
  @override
  DateTime lastAccessedSync() => (super.noSuchMethod(
        Invocation.method(
          #lastAccessedSync,
          [],
        ),
        returnValue: _FakeDateTime_4(
          this,
          Invocation.method(
            #lastAccessedSync,
            [],
          ),
        ),
        returnValueForMissingStub: _FakeDateTime_4(
          this,
          Invocation.method(
            #lastAccessedSync,
            [],
          ),
        ),
      ) as DateTime);
  @override
  _i4.Future<dynamic> setLastAccessed(DateTime? time) => (super.noSuchMethod(
        Invocation.method(
          #setLastAccessed,
          [time],
        ),
        returnValue: _i4.Future<dynamic>.value(),
        returnValueForMissingStub: _i4.Future<dynamic>.value(),
      ) as _i4.Future<dynamic>);
  @override
  void setLastAccessedSync(DateTime? time) => super.noSuchMethod(
        Invocation.method(
          #setLastAccessedSync,
          [time],
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i4.Future<DateTime> lastModified() => (super.noSuchMethod(
        Invocation.method(
          #lastModified,
          [],
        ),
        returnValue: _i4.Future<DateTime>.value(_FakeDateTime_4(
          this,
          Invocation.method(
            #lastModified,
            [],
          ),
        )),
        returnValueForMissingStub: _i4.Future<DateTime>.value(_FakeDateTime_4(
          this,
          Invocation.method(
            #lastModified,
            [],
          ),
        )),
      ) as _i4.Future<DateTime>);
  @override
  DateTime lastModifiedSync() => (super.noSuchMethod(
        Invocation.method(
          #lastModifiedSync,
          [],
        ),
        returnValue: _FakeDateTime_4(
          this,
          Invocation.method(
            #lastModifiedSync,
            [],
          ),
        ),
        returnValueForMissingStub: _FakeDateTime_4(
          this,
          Invocation.method(
            #lastModifiedSync,
            [],
          ),
        ),
      ) as DateTime);
  @override
  _i4.Future<dynamic> setLastModified(DateTime? time) => (super.noSuchMethod(
        Invocation.method(
          #setLastModified,
          [time],
        ),
        returnValue: _i4.Future<dynamic>.value(),
        returnValueForMissingStub: _i4.Future<dynamic>.value(),
      ) as _i4.Future<dynamic>);
  @override
  void setLastModifiedSync(DateTime? time) => super.noSuchMethod(
        Invocation.method(
          #setLastModifiedSync,
          [time],
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i4.Future<_i3.RandomAccessFile> open(
          {_i3.FileMode? mode = _i3.FileMode.read}) =>
      (super.noSuchMethod(
        Invocation.method(
          #open,
          [],
          {#mode: mode},
        ),
        returnValue:
            _i4.Future<_i3.RandomAccessFile>.value(_FakeRandomAccessFile_5(
          this,
          Invocation.method(
            #open,
            [],
            {#mode: mode},
          ),
        )),
        returnValueForMissingStub:
            _i4.Future<_i3.RandomAccessFile>.value(_FakeRandomAccessFile_5(
          this,
          Invocation.method(
            #open,
            [],
            {#mode: mode},
          ),
        )),
      ) as _i4.Future<_i3.RandomAccessFile>);
  @override
  _i3.RandomAccessFile openSync({_i3.FileMode? mode = _i3.FileMode.read}) =>
      (super.noSuchMethod(
        Invocation.method(
          #openSync,
          [],
          {#mode: mode},
        ),
        returnValue: _FakeRandomAccessFile_5(
          this,
          Invocation.method(
            #openSync,
            [],
            {#mode: mode},
          ),
        ),
        returnValueForMissingStub: _FakeRandomAccessFile_5(
          this,
          Invocation.method(
            #openSync,
            [],
            {#mode: mode},
          ),
        ),
      ) as _i3.RandomAccessFile);
  @override
  _i4.Stream<List<int>> openRead([
    int? start,
    int? end,
  ]) =>
      (super.noSuchMethod(
        Invocation.method(
          #openRead,
          [
            start,
            end,
          ],
        ),
        returnValue: _i4.Stream<List<int>>.empty(),
        returnValueForMissingStub: _i4.Stream<List<int>>.empty(),
      ) as _i4.Stream<List<int>>);
  @override
  _i3.IOSink openWrite({
    _i3.FileMode? mode = _i3.FileMode.write,
    _i6.Encoding? encoding = const _i6.Utf8Codec(),
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openWrite,
          [],
          {
            #mode: mode,
            #encoding: encoding,
          },
        ),
        returnValue: _FakeIOSink_6(
          this,
          Invocation.method(
            #openWrite,
            [],
            {
              #mode: mode,
              #encoding: encoding,
            },
          ),
        ),
        returnValueForMissingStub: _FakeIOSink_6(
          this,
          Invocation.method(
            #openWrite,
            [],
            {
              #mode: mode,
              #encoding: encoding,
            },
          ),
        ),
      ) as _i3.IOSink);
  @override
  _i4.Future<_i7.Uint8List> readAsBytes() => (super.noSuchMethod(
        Invocation.method(
          #readAsBytes,
          [],
        ),
        returnValue: _i4.Future<_i7.Uint8List>.value(_i7.Uint8List(0)),
        returnValueForMissingStub:
            _i4.Future<_i7.Uint8List>.value(_i7.Uint8List(0)),
      ) as _i4.Future<_i7.Uint8List>);
  @override
  _i7.Uint8List readAsBytesSync() => (super.noSuchMethod(
        Invocation.method(
          #readAsBytesSync,
          [],
        ),
        returnValue: _i7.Uint8List(0),
        returnValueForMissingStub: _i7.Uint8List(0),
      ) as _i7.Uint8List);
  @override
  _i4.Future<String> readAsString(
          {_i6.Encoding? encoding = const _i6.Utf8Codec()}) =>
      (super.noSuchMethod(
        Invocation.method(
          #readAsString,
          [],
          {#encoding: encoding},
        ),
        returnValue: _i4.Future<String>.value(''),
        returnValueForMissingStub: _i4.Future<String>.value(''),
      ) as _i4.Future<String>);
  @override
  String readAsStringSync({_i6.Encoding? encoding = const _i6.Utf8Codec()}) =>
      (super.noSuchMethod(
        Invocation.method(
          #readAsStringSync,
          [],
          {#encoding: encoding},
        ),
        returnValue: '',
        returnValueForMissingStub: '',
      ) as String);
  @override
  _i4.Future<List<String>> readAsLines(
          {_i6.Encoding? encoding = const _i6.Utf8Codec()}) =>
      (super.noSuchMethod(
        Invocation.method(
          #readAsLines,
          [],
          {#encoding: encoding},
        ),
        returnValue: _i4.Future<List<String>>.value(<String>[]),
        returnValueForMissingStub: _i4.Future<List<String>>.value(<String>[]),
      ) as _i4.Future<List<String>>);
  @override
  List<String> readAsLinesSync(
          {_i6.Encoding? encoding = const _i6.Utf8Codec()}) =>
      (super.noSuchMethod(
        Invocation.method(
          #readAsLinesSync,
          [],
          {#encoding: encoding},
        ),
        returnValue: <String>[],
        returnValueForMissingStub: <String>[],
      ) as List<String>);
  @override
  _i4.Future<_i3.File> writeAsBytes(
    List<int>? bytes, {
    _i3.FileMode? mode = _i3.FileMode.write,
    bool? flush = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #writeAsBytes,
          [bytes],
          {
            #mode: mode,
            #flush: flush,
          },
        ),
        returnValue: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #writeAsBytes,
            [bytes],
            {
              #mode: mode,
              #flush: flush,
            },
          ),
        )),
        returnValueForMissingStub: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #writeAsBytes,
            [bytes],
            {
              #mode: mode,
              #flush: flush,
            },
          ),
        )),
      ) as _i4.Future<_i3.File>);
  @override
  void writeAsBytesSync(
    List<int>? bytes, {
    _i3.FileMode? mode = _i3.FileMode.write,
    bool? flush = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #writeAsBytesSync,
          [bytes],
          {
            #mode: mode,
            #flush: flush,
          },
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i4.Future<_i3.File> writeAsString(
    String? contents, {
    _i3.FileMode? mode = _i3.FileMode.write,
    _i6.Encoding? encoding = const _i6.Utf8Codec(),
    bool? flush = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #writeAsString,
          [contents],
          {
            #mode: mode,
            #encoding: encoding,
            #flush: flush,
          },
        ),
        returnValue: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #writeAsString,
            [contents],
            {
              #mode: mode,
              #encoding: encoding,
              #flush: flush,
            },
          ),
        )),
        returnValueForMissingStub: _i4.Future<_i3.File>.value(_FakeFile_1(
          this,
          Invocation.method(
            #writeAsString,
            [contents],
            {
              #mode: mode,
              #encoding: encoding,
              #flush: flush,
            },
          ),
        )),
      ) as _i4.Future<_i3.File>);
  @override
  void writeAsStringSync(
    String? contents, {
    _i3.FileMode? mode = _i3.FileMode.write,
    _i6.Encoding? encoding = const _i6.Utf8Codec(),
    bool? flush = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #writeAsStringSync,
          [contents],
          {
            #mode: mode,
            #encoding: encoding,
            #flush: flush,
          },
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i4.Future<bool> exists() => (super.noSuchMethod(
        Invocation.method(
          #exists,
          [],
        ),
        returnValue: _i4.Future<bool>.value(false),
        returnValueForMissingStub: _i4.Future<bool>.value(false),
      ) as _i4.Future<bool>);
  @override
  bool existsSync() => (super.noSuchMethod(
        Invocation.method(
          #existsSync,
          [],
        ),
        returnValue: false,
        returnValueForMissingStub: false,
      ) as bool);
  @override
  _i4.Future<String> resolveSymbolicLinks() => (super.noSuchMethod(
        Invocation.method(
          #resolveSymbolicLinks,
          [],
        ),
        returnValue: _i4.Future<String>.value(''),
        returnValueForMissingStub: _i4.Future<String>.value(''),
      ) as _i4.Future<String>);
  @override
  String resolveSymbolicLinksSync() => (super.noSuchMethod(
        Invocation.method(
          #resolveSymbolicLinksSync,
          [],
        ),
        returnValue: '',
        returnValueForMissingStub: '',
      ) as String);
  @override
  _i4.Future<_i3.FileStat> stat() => (super.noSuchMethod(
        Invocation.method(
          #stat,
          [],
        ),
        returnValue: _i4.Future<_i3.FileStat>.value(_FakeFileStat_7(
          this,
          Invocation.method(
            #stat,
            [],
          ),
        )),
        returnValueForMissingStub:
            _i4.Future<_i3.FileStat>.value(_FakeFileStat_7(
          this,
          Invocation.method(
            #stat,
            [],
          ),
        )),
      ) as _i4.Future<_i3.FileStat>);
  @override
  _i3.FileStat statSync() => (super.noSuchMethod(
        Invocation.method(
          #statSync,
          [],
        ),
        returnValue: _FakeFileStat_7(
          this,
          Invocation.method(
            #statSync,
            [],
          ),
        ),
        returnValueForMissingStub: _FakeFileStat_7(
          this,
          Invocation.method(
            #statSync,
            [],
          ),
        ),
      ) as _i3.FileStat);
  @override
  _i4.Future<_i3.FileSystemEntity> delete({bool? recursive = false}) =>
      (super.noSuchMethod(
        Invocation.method(
          #delete,
          [],
          {#recursive: recursive},
        ),
        returnValue:
            _i4.Future<_i3.FileSystemEntity>.value(_FakeFileSystemEntity_8(
          this,
          Invocation.method(
            #delete,
            [],
            {#recursive: recursive},
          ),
        )),
        returnValueForMissingStub:
            _i4.Future<_i3.FileSystemEntity>.value(_FakeFileSystemEntity_8(
          this,
          Invocation.method(
            #delete,
            [],
            {#recursive: recursive},
          ),
        )),
      ) as _i4.Future<_i3.FileSystemEntity>);
  @override
  void deleteSync({bool? recursive = false}) => super.noSuchMethod(
        Invocation.method(
          #deleteSync,
          [],
          {#recursive: recursive},
        ),
        returnValueForMissingStub: null,
      );
  @override
  _i4.Stream<_i3.FileSystemEvent> watch({
    int? events = 15,
    bool? recursive = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #watch,
          [],
          {
            #events: events,
            #recursive: recursive,
          },
        ),
        returnValue: _i4.Stream<_i3.FileSystemEvent>.empty(),
        returnValueForMissingStub: _i4.Stream<_i3.FileSystemEvent>.empty(),
      ) as _i4.Stream<_i3.FileSystemEvent>);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\example\lib\main.dart =====
import 'package:flutter/material.dart';
import 'package:gtk/gtk.dart';
import 'package:provider/provider.dart';
import 'package:yaru/yaru.dart';

const properties = [
  kGtkAlternativeButtonOrder,
  kGtkAlternativeSortArrows,
  kGtkApplicationPreferDarkTheme,
  kGtkCursorAspectRatio,
  kGtkCursorBlink,
  kGtkCursorBlinkTime,
  kGtkCursorBlinkTimeout,
  kGtkCursorThemeName,
  kGtkCursorThemeSize,
  kGtkDecorationLayout,
  kGtkDialogsUseHeader,
  kGtkDndDragThreshold,
  kGtkDoubleClickDistance,
  kGtkDoubleClickTime,
  kGtkEnableAccels,
  kGtkEnableAnimations,
  kGtkEnableEventSounds,
  kGtkEnableInputFeedbackSounds,
  kGtkEnablePrimaryPaste,
  kGtkEntryPasswordHintTimeout,
  kGtkEntrySelectOnFocus,
  kGtkErrorBell,
  kGtkFontName,
  kGtkFontconfigTimestamp,
  kGtkIconThemeName,
  kGtkImModule,
  kGtkKeyThemeName,
  kGtkKeynavUseCaret,
  kGtkLabelSelectOnFocus,
  kGtkLongPressTime,
  kGtkModules,
  kGtkOverlayScrolling,
  kGtkPrimaryButtonWarpsSlider,
  kGtkPrintBackends,
  kGtkPrintPreviewCommand,
  kGtkRecentFilesEnabled,
  kGtkRecentFilesMaxAge,
  kGtkShellShowsAppMenu,
  kGtkShellShowsDesktop,
  kGtkShellShowsMenubar,
  kGtkSoundThemeName,
  kGtkSplitCursor,
  kGtkThemeName,
  kGtkTitlebarDoubleClick,
  kGtkTitlebarMiddleClick,
  kGtkTitlebarRightClick,
  kGtkXftAntialias,
  kGtkXftDpi,
  kGtkXftHinting,
  kGtkXftHintstyle,
  kGtkXftRgba,
];

void main() {
  runApp(
    ChangeNotifierProvider(
      create: (_) => GtkSettings(),
      child: const ExampleApp(),
    ),
  );
}

class ExampleApp extends StatelessWidget {
  const ExampleApp({super.key});

  @override
  Widget build(BuildContext context) {
    return YaruTheme(
      builder: (context, yaru, builder) => MaterialApp(
        theme: yaru.theme,
        darkTheme: yaru.darkTheme,
        home: Scaffold(
          appBar: AppBar(
            title: const Text('gtk.dart'),
          ),
          body: const ExamplePage(),
        ),
      ),
    );
  }
}

class ExamplePage extends StatelessWidget {
  const ExamplePage({super.key});

  @override
  Widget build(BuildContext context) {
    return GtkApplication(
      onCommandLine: (args) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('command-line'),
            content: Text(args.toString()),
            actions: [
              OutlinedButton(
                onPressed: Navigator.of(context).pop,
                child: const Text('Close'),
              ),
            ],
          ),
        );
      },
      onOpen: (files, hint) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('open $hint'),
            content: Column(
              children: files.map((f) => Text(f)).toList(),
            ),
            actions: [
              OutlinedButton(
                onPressed: Navigator.of(context).pop,
                child: const Text('Close'),
              ),
            ],
          ),
        );
      },
      child: ListView.builder(
        itemCount: properties.length,
        itemBuilder: (context, index) => SettingsTile(properties[index]),
      ),
    );
  }
}

class SettingsTile extends StatelessWidget {
  const SettingsTile(this.property, {super.key});

  final String property;

  @override
  Widget build(BuildContext context) {
    final value = context.select((GtkSettings s) => s.getProperty(property));
    return ListTile(
      title: Text(value.toString()),
      subtitle: Text(property),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\constants.dart =====
/// [gtk-alternative-button-order](https://docs.gtk.org/gtk3/property.Settings.gtk-alternative-button-order.html)
const kGtkAlternativeButtonOrder = 'gtk-alternative-button-order';

/// [gtk-alternative-sort-arrows](https://docs.gtk.org/gtk3/property.Settings.gtk-alternative-sort-arrows.html)
const kGtkAlternativeSortArrows = 'gtk-alternative-sort-arrows';

/// [gtk-application-prefer-dark-theme](https://docs.gtk.org/gtk3/property.Settings.gtk-application-prefer-dark-theme.html)
const kGtkApplicationPreferDarkTheme = 'gtk-application-prefer-dark-theme';

/// [gtk-cursor-aspect-ratio](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-aspect-ratio.html)
const kGtkCursorAspectRatio = 'gtk-cursor-aspect-ratio';

/// [gtk-cursor-blink](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink.html)
const kGtkCursorBlink = 'gtk-cursor-blink';

/// [gtk-cursor-blink-time](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink-time.html)
const kGtkCursorBlinkTime = 'gtk-cursor-blink-time';

/// [gtk-cursor-blink-timeout](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink-timeout.html)
const kGtkCursorBlinkTimeout = 'gtk-cursor-blink-timeout';

/// [gtk-cursor-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-theme-name.html)
const kGtkCursorThemeName = 'gtk-cursor-theme-name';

/// [gtk-cursor-theme-size](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-theme-size.html)
const kGtkCursorThemeSize = 'gtk-cursor-theme-size';

/// [gtk-decoration-layout](https://docs.gtk.org/gtk3/property.Settings.gtk-decoration-layout.html)
const kGtkDecorationLayout = 'gtk-decoration-layout';

/// [gtk-dialogs-use-header](https://docs.gtk.org/gtk3/property.Settings.gtk-dialogs-use-header.html)
const kGtkDialogsUseHeader = 'gtk-dialogs-use-header';

/// [gtk-dnd-drag-threshold](https://docs.gtk.org/gtk3/property.Settings.gtk-dnd-drag-threshold.html)
const kGtkDndDragThreshold = 'gtk-dnd-drag-threshold';

/// [gtk-double-click-distance](https://docs.gtk.org/gtk3/property.Settings.gtk-double-click-distance.html)
const kGtkDoubleClickDistance = 'gtk-double-click-distance';

/// [gtk-double-click-time](https://docs.gtk.org/gtk3/property.Settings.gtk-double-click-time.html)
const kGtkDoubleClickTime = 'gtk-double-click-time';

/// [gtk-enable-accels](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-accels.html)
const kGtkEnableAccels = 'gtk-enable-accels';

/// [gtk-enable-animations](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-animations.html)
const kGtkEnableAnimations = 'gtk-enable-animations';

/// [gtk-enable-event-sounds](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-event-sounds.html)
const kGtkEnableEventSounds = 'gtk-enable-event-sounds';

/// [gtk-enable-input-feedback-sounds](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-input-feedback-sounds.html)
const kGtkEnableInputFeedbackSounds = 'gtk-enable-input-feedback-sounds';

/// [gtk-enable-primary-paste](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-primary-paste.html)
const kGtkEnablePrimaryPaste = 'gtk-enable-primary-paste';

/// [gtk-entry-password-hint-timeout](https://docs.gtk.org/gtk3/property.Settings.gtk-entry-password-hint-timeout.html)
const kGtkEntryPasswordHintTimeout = 'gtk-entry-password-hint-timeout';

/// [gtk-entry-select-on-focus](https://docs.gtk.org/gtk3/property.Settings.gtk-entry-select-on-focus.html)
const kGtkEntrySelectOnFocus = 'gtk-entry-select-on-focus';

/// [gtk-error-bell](https://docs.gtk.org/gtk3/property.Settings.gtk-error-bell.html)
const kGtkErrorBell = 'gtk-error-bell';

/// [gtk-font-name](https://docs.gtk.org/gtk3/property.Settings.gtk-font-name.html)
const kGtkFontName = 'gtk-font-name';

/// [gtk-fontconfig-timestamp](https://docs.gtk.org/gtk3/property.Settings.gtk-fontconfig-timestamp.html)
const kGtkFontconfigTimestamp = 'gtk-fontconfig-timestamp';

/// [gtk-icon-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-icon-theme-name.html)
const kGtkIconThemeName = 'gtk-icon-theme-name';

/// [gtk-im-module](https://docs.gtk.org/gtk3/property.Settings.gtk-im-module.html)
const kGtkImModule = 'gtk-im-module';

/// [gtk-key-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-key-theme-name.html)
const kGtkKeyThemeName = 'gtk-key-theme-name';

/// [gtk-keynav-use-caret](https://docs.gtk.org/gtk3/property.Settings.gtk-keynav-use-caret.html)
const kGtkKeynavUseCaret = 'gtk-keynav-use-caret';

/// [gtk-label-select-on-focus](https://docs.gtk.org/gtk3/property.Settings.gtk-label-select-on-focus.html)
const kGtkLabelSelectOnFocus = 'gtk-label-select-on-focus';

/// [gtk-long-press-time](https://docs.gtk.org/gtk3/property.Settings.gtk-long-press-time.html)
const kGtkLongPressTime = 'gtk-long-press-time';

/// [gtk-modules](https://docs.gtk.org/gtk3/property.Settings.gtk-modules.html)
const kGtkModules = 'gtk-modules';

/// [gtk-overlay-scrolling](https://docs.gtk.org/gtk3/property.Settings.gtk-overlay-scrolling.html)
const kGtkOverlayScrolling = 'gtk-overlay-scrolling';

/// [gtk-primary-button-warps-slider](https://docs.gtk.org/gtk3/property.Settings.gtk-primary-button-warps-slider.html)
const kGtkPrimaryButtonWarpsSlider = 'gtk-primary-button-warps-slider';

/// [gtk-print-backends](https://docs.gtk.org/gtk3/property.Settings.gtk-print-backends.html)
const kGtkPrintBackends = 'gtk-print-backends';

/// [gtk-print-preview-command](https://docs.gtk.org/gtk3/property.Settings.gtk-print-preview-command.html)
const kGtkPrintPreviewCommand = 'gtk-print-preview-command';

/// [gtk-recent-files-enabled](https://docs.gtk.org/gtk3/property.Settings.gtk-recent-files-enabled.html)
const kGtkRecentFilesEnabled = 'gtk-recent-files-enabled';

/// [gtk-recent-files-max-age](https://docs.gtk.org/gtk3/property.Settings.gtk-recent-files-max-age.html)
const kGtkRecentFilesMaxAge = 'gtk-recent-files-max-age';

/// [gtk-shell-shows-app-menu](https://docs.gtk.org/gtk3/property.Settings.gtk-shell-shows-app-menu.html)
const kGtkShellShowsAppMenu = 'gtk-shell-shows-app-menu';

/// [gtk-shell-shows-desktop](https://docs.gtk.org/gtk3/property.Settings.gtk-shell-shows-desktop.html)
const kGtkShellShowsDesktop = 'gtk-shell-shows-desktop';

/// [gtk-shell-shows-menubar](https://docs.gtk.org/gtk3/property.Settings.gtk-shell-shows-menubar.html)
const kGtkShellShowsMenubar = 'gtk-shell-shows-menubar';

/// [gtk-sound-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-sound-theme-name.html)
const kGtkSoundThemeName = 'gtk-sound-theme-name';

/// [gtk-split-cursor](https://docs.gtk.org/gtk3/property.Settings.gtk-split-cursor.html)
const kGtkSplitCursor = 'gtk-split-cursor';

/// [gtk-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-theme-name.html)
const kGtkThemeName = 'gtk-theme-name';

/// [gtk-titlebar-double-click](https://docs.gtk.org/gtk3/property.Settings.gtk-titlebar-double-click.html)
const kGtkTitlebarDoubleClick = 'gtk-titlebar-double-click';

/// [gtk-titlebar-middle-click](https://docs.gtk.org/gtk3/property.Settings.gtk-titlebar-middle-click.html)
const kGtkTitlebarMiddleClick = 'gtk-titlebar-middle-click';

/// [gtk-titlebar-right-click](https://docs.gtk.org/gtk3/property.Settings.gtk-titlebar-right-click.html)
const kGtkTitlebarRightClick = 'gtk-titlebar-right-click';

/// [gtk-xft-antialias](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-antialias.html)
const kGtkXftAntialias = 'gtk-xft-antialias';

/// [gtk-xft-dpi](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-dpi.html)
const kGtkXftDpi = 'gtk-xft-dpi';

/// [gtk-xft-hinting](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-hinting.html)
const kGtkXftHinting = 'gtk-xft-hinting';

/// [gtk-xft-hintstyle](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-hintstyle.html)
const kGtkXftHintstyle = 'gtk-xft-hintstyle';

/// [gtk-xft-rgba](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-rgba.html)
const kGtkXftRgba = 'gtk-xft-rgba';
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\gtk_application.dart =====
import 'package:flutter/widgets.dart';

import 'gtk_application_notifier.dart';

/// A widget that can be used to listen to remote GTK application command-line
/// arguments and file open requests from within the widget tree.
///
/// ```dart
/// import 'package:flutter/material.dart';
/// import 'package:gtk_application/gtk_application.dart';
///
/// void main() {
///   runApp(
///     MaterialApp(
///       home: GtkApplication(
///         onCommandLine: (args) => print('command-line: $args'),
///         onOpen: (files, hint) => print('open ($hint): $files'),
///         child: // ...
///       ),
///     ),
///   );
/// }
/// ```
///
/// See also:
///  * [GtkApplicationNotifier]
///  * [GApplication::command-line](https://docs.gtk.org/gio/signal.Application.command-line.html)
///  * [GApplication::open](https://docs.gtk.org/gio/signal.Application.open.html)
class GtkApplication extends StatefulWidget {
  /// Creates a new [GtkApplication] with and optional [onCommandLine] and/or
  /// [onOpen] callback.
  const GtkApplication({
    super.key,
    this.child,
    this.onCommandLine,
    this.onOpen,
    this.notifier,
  });

  /// An optional child widget below this widget in the tree.
  final Widget? child;

  /// An optional listener that will be notified when the application receives
  /// remote command-line arguments.
  final GtkCommandLineListener? onCommandLine;

  /// An optional listener that will be notified when the application receives
  /// remote file open requests.
  final GtkOpenListener? onOpen;

  /// An optional notifier that will be used to listen to remote command-line
  /// arguments and file open requests. If not specified, a new notifier will be
  /// created.
  final GtkApplicationNotifier? notifier;

  @override
  State<GtkApplication> createState() => _GtkApplicationState();
}

class _GtkApplicationState extends State<GtkApplication> {
  late GtkApplicationNotifier _notifier;

  @override
  void initState() {
    super.initState();
    _initNotifier();
  }

  @override
  void didUpdateWidget(covariant GtkApplication oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.notifier != widget.notifier) {
      _cleanupNotifier();
      _initNotifier();
    }
  }

  @override
  void dispose() {
    _cleanupNotifier();
    super.dispose();
  }

  void _initNotifier() {
    _notifier = widget.notifier ?? GtkApplicationNotifier();
    _notifier.addCommandLineListener(_onCommandLine);
    _notifier.addOpenListener(_onOpen);
  }

  void _cleanupNotifier() {
    _notifier.removeCommandLineListener(_onCommandLine);
    _notifier.removeOpenListener(_onOpen);
    if (widget.notifier == null) {
      _notifier.dispose();
    }
  }

  void _onCommandLine(List<String> args) {
    widget.onCommandLine?.call(args);
  }

  void _onOpen(List<String> files, String hint) {
    widget.onOpen?.call(files, hint);
  }

  @override
  Widget build(BuildContext context) {
    return widget.child ?? const SizedBox.shrink();
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\gtk_application_notifier.dart =====
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

/// The signature of a callback that receives remote command-line arguments.
///
/// See also:
///  * [GApplication::command-line](https://docs.gtk.org/gio/signal.Application.command-line.html)
typedef GtkCommandLineListener = void Function(List<String> args);

/// The signature of a callback that receives remote file open requests.
///
/// See also:
///  * [GApplication::open](https://docs.gtk.org/gio/signal.Application.open.html)
typedef GtkOpenListener = void Function(List<String> files, String hint);

/// An object that can be used to listen to remote GTK application command-line
/// arguments and file open requests outside the widget tree.
///
/// ```dart
/// import 'package:flutter/widgets.dart';
/// import 'package:gtk_application/gtk_application.dart';
///
/// void main(List<String> args) {
///   WidgetsFlutterBinding.ensureInitialized();
///
///   final notifier = GtkApplicationNotifier(args);
///   notifier.addCommandLineListener((args) {
///     print('command-line: $args');
///   });
///   notifier.addOpenListener((files, hint) {
///     print('open ($hint): $files');
///   });
///
///   // ...
///   // notifier.dispose();
/// }
/// ```
///
/// See also:
///  * [GtkApplication]
///  * [GApplication::command-line](https://docs.gtk.org/gio/signal.Application.command-line.html)
///  * [GApplication::open](https://docs.gtk.org/gio/signal.Application.open.html)
class GtkApplicationNotifier {
  /// Creates a new [GtkApplicationNotifier]. Optionally, the initial value of
  /// [commandLine] can be provided.
  GtkApplicationNotifier([this._commandLine]) {
    _channel.setMethodCallHandler(_handleMethodCall);
  }

  List<String>? _commandLine;
  final _channel = const MethodChannel('gtk/application');
  final _commandLineListeners = <GtkCommandLineListener>[];
  final _openListeners = <GtkOpenListener>[];

  /// Returns the most recent command-line arguments.
  ///
  /// This is either the most recently received remote command-line arguments,
  /// the initial value provided via the constructor, or `null` if none of those
  /// are available.
  List<String>? get commandLine => _commandLine;

  /// Adds a [listener] that will be notified when the application receives
  /// remote command-line arguments.
  void addCommandLineListener(GtkCommandLineListener listener) {
    _commandLineListeners.add(listener);
  }

  /// Removes a previously registered remote command-line argument [listener].
  void removeCommandLineListener(GtkCommandLineListener listener) {
    _commandLineListeners.remove(listener);
  }

  /// Adds a [listener] that will be notified when the application receives
  /// remote file open requests.
  void addOpenListener(GtkOpenListener listener) {
    _openListeners.add(listener);
  }

  /// Removes a previously registered remote file open request [listener].
  void removeOpenListener(GtkOpenListener listener) {
    _openListeners.remove(listener);
  }

  /// Discards any resources used by the object. After this is called, the
  /// listeners will no longer be notified.
  void dispose() {
    _channel.setMethodCallHandler(null);
    _commandLineListeners.clear();
    _openListeners.clear();
  }

  /// Notify all the remote command-line argument listeners.
  @protected
  @visibleForTesting
  void notifyCommandLine(List<String> args) {
    _commandLine = args;
    final listeners = List.of(_commandLineListeners);
    for (final listener in listeners) {
      listener(args);
    }
  }

  /// Notify all the remote file open request listeners.
  @protected
  @visibleForTesting
  void notifyOpen({required List<String> files, required String hint}) {
    final listeners = List.of(_openListeners);
    for (final listener in listeners) {
      listener(files, hint);
    }
  }

  Future<void> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'command-line':
        final args = call.arguments as List;
        notifyCommandLine(args.cast<String>());
        break;
      case 'open':
        final args = call.arguments as Map;
        notifyOpen(
          files: (args['files'] as List).cast<String>(),
          hint: args['hint'].toString(),
        );
        break;
      default:
        throw UnsupportedError(call.method);
    }
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\gtk_settings.dart =====
import 'package:flutter/foundation.dart';

import 'gtk_settings_stub.dart' if (dart.library.ffi) 'gtk_settings_real.dart';

abstract class GtkSettings implements ChangeNotifier {
  factory GtkSettings() = GtkSettingsImpl;
  Object? getProperty(String name);
  Stream<Object?> notifyProperty(String name);
  void setProperty(String name, Object value);
  void resetProperty(String name);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\gtk_settings_real.dart =====
import 'dart:async';
import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as ffi;
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import 'gtk_settings.dart';
import 'libgtk.dart';
import 'libgtk.g.dart' as ffi;

class GtkSettingsImpl with ChangeNotifier implements GtkSettings {
  GtkSettingsImpl() {
    methodChannel.setMethodCallHandler(_handleMethodCall);
    _finalizer.attach(this, _controller, detach: this);
  }

  @visibleForTesting
  static const methodChannel = MethodChannel('gtk/settings');

  final _controller = StreamController<String>.broadcast();
  static final Finalizer<StreamController<String>> _finalizer =
      Finalizer((controller) => controller.close());

  @override
  Object? getProperty(String name) {
    return ffi.using((arena) {
      final value = arena<ffi.GValue>();
      lib.g_object_get_property(
        lib.gtk_settings_get_default().cast(),
        name.toNativeUtf8(allocator: arena).cast(),
        value,
      );
      return value.toDartObject();
    });
  }

  @override
  Stream<Object?> notifyProperty(String name) {
    return _controller.stream
        .where((event) => event == name)
        .map((event) => getProperty(name));
  }

  Future<dynamic> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'notify':
        _controller.add(call.arguments);
        break;
      default:
        throw MissingPluginException('$call');
    }
    notifyListeners();
  }

  @override
  void setProperty(String name, Object value) {
    ffi.using((arena) {
      lib.g_object_set_property(
        lib.gtk_settings_get_default().cast(),
        name.toNativeUtf8(allocator: arena).cast(),
        value.toNativeGValue(allocator: arena),
      );
    });
  }

  @override
  void resetProperty(String name) {
    ffi.using((arena) {
      lib.gtk_settings_reset_property(
        lib.gtk_settings_get_default().cast(),
        name.toNativeUtf8(allocator: arena).cast(),
      );
    });
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\gtk_settings_stub.dart =====
import 'package:flutter/foundation.dart';

import 'gtk_settings.dart';

class GtkSettingsImpl with ChangeNotifier implements GtkSettings {
  @override
  Object? getProperty(String name) => null;

  @override
  Stream<Object?> notifyProperty(String name) => Stream.empty();

  @override
  void setProperty(String name, Object value) {}

  @override
  void resetProperty(String name) {}
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\libgtk.dart =====
import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as ffi;
import 'package:meta/meta.dart';

import 'libgtk.g.dart';

LibGtk? _lib;
LibGtk get lib => _lib ??= LibGtk(ffi.DynamicLibrary.open('libgtk-3.so.0'));

@visibleForTesting
void overrideLibGtkForTesting(LibGtk lib) => _lib = lib;

extension GValueX on ffi.Pointer<GValue> {
  Object? toDartObject() {
    switch (ref.g_type) {
      case G_TYPE_BOOLEAN:
        return lib.g_value_get_boolean(this) != 0;
      case G_TYPE_CHAR:
        return lib.g_value_get_schar(this);
      case G_TYPE_UCHAR:
        return lib.g_value_get_uchar(this);
      case G_TYPE_INT:
        return lib.g_value_get_int(this);
      case G_TYPE_UINT:
        return lib.g_value_get_uint(this);
      case G_TYPE_LONG:
        return lib.g_value_get_long(this);
      case G_TYPE_ULONG:
        return lib.g_value_get_ulong(this);
      case G_TYPE_INT64:
        return lib.g_value_get_int64(this);
      case G_TYPE_UINT64:
        return lib.g_value_get_uint64(this);
      case G_TYPE_FLOAT:
        return lib.g_value_get_float(this);
      case G_TYPE_DOUBLE:
        return lib.g_value_get_double(this);
      case G_TYPE_STRING:
        return lib.g_value_get_string(this).cast<ffi.Utf8>().toDartString();
    }
    return null;
  }
}

extension ObjectX on Object {
  ffi.Pointer<GValue> toNativeGValue({required ffi.Allocator allocator}) {
    switch (runtimeType) {
      case bool:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_BOOLEAN);
        lib.g_value_set_boolean(gvalue, this as bool ? 1 : 0);
        return gvalue;
      case int:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_INT64);
        lib.g_value_set_int64(gvalue, this as int);
        return gvalue;
      case double:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_DOUBLE);
        lib.g_value_set_double(gvalue, this as double);
        return gvalue;
      case String:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_STRING);
        lib.g_value_set_string(
            gvalue, (this as String).toNativeUtf8(allocator: allocator).cast());
        return gvalue;
      default:
        throw UnsupportedError('Unsupported type: $runtimeType');
    }
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\src\libgtk.g.dart =====
// coverage:ignore-file
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// GTK+ 3.0
class LibGtk {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibGtk(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibGtk.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<GValue> g_value_init(
    ffi.Pointer<GValue> value,
    int g_type,
  ) {
    return _g_value_init(
      value,
      g_type,
    );
  }

  late final _g_value_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GValue> Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_init');
  late final _g_value_init = _g_value_initPtr
      .asFunction<ffi.Pointer<GValue> Function(ffi.Pointer<GValue>, int)>();

  void g_value_set_instance(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> instance,
  ) {
    return _g_value_set_instance(
      value,
      instance,
    );
  }

  late final _g_value_set_instancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_instance');
  late final _g_value_set_instance = _g_value_set_instancePtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_param(
    ffi.Pointer<GValue> value,
    ffi.Pointer<_GParamSpec> param,
  ) {
    return _g_value_set_param(
      value,
      param,
    );
  }

  late final _g_value_set_paramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<_GParamSpec>)>>('g_value_set_param');
  late final _g_value_set_param = _g_value_set_paramPtr.asFunction<
      void Function(ffi.Pointer<GValue>, ffi.Pointer<_GParamSpec>)>();

  ffi.Pointer<_GParamSpec> g_value_get_param(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_param(
      value,
    );
  }

  late final _g_value_get_paramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_GParamSpec> Function(
              ffi.Pointer<GValue>)>>('g_value_get_param');
  late final _g_value_get_param = _g_value_get_paramPtr
      .asFunction<ffi.Pointer<_GParamSpec> Function(ffi.Pointer<GValue>)>();

  void g_value_set_param_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<_GParamSpec> param,
  ) {
    return _g_value_set_param_take_ownership(
      value,
      param,
    );
  }

  late final _g_value_set_param_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<_GParamSpec>)>>('g_value_set_param_take_ownership');
  late final _g_value_set_param_take_ownership =
      _g_value_set_param_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<_GParamSpec>)>();

  void g_value_set_boxed(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_boxed,
  ) {
    return _g_value_set_boxed(
      value,
      v_boxed,
    );
  }

  late final _g_value_set_boxedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_boxed');
  late final _g_value_set_boxed = _g_value_set_boxedPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_static_boxed(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_boxed,
  ) {
    return _g_value_set_static_boxed(
      value,
      v_boxed,
    );
  }

  late final _g_value_set_static_boxedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_static_boxed');
  late final _g_value_set_static_boxed = _g_value_set_static_boxedPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_boxed_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_boxed,
  ) {
    return _g_value_set_boxed_take_ownership(
      value,
      v_boxed,
    );
  }

  late final _g_value_set_boxed_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_boxed_take_ownership');
  late final _g_value_set_boxed_take_ownership =
      _g_value_set_boxed_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> g_value_get_boxed(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_boxed(
      value,
    );
  }

  late final _g_value_get_boxedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GValue>)>>('g_value_get_boxed');
  late final _g_value_get_boxed = _g_value_get_boxedPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GValue>)>();

  int g_value_get_type() {
    return _g_value_get_type();
  }

  late final _g_value_get_typePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>(
          'g_value_get_type');
  late final _g_value_get_type =
      _g_value_get_typePtr.asFunction<int Function()>();

  void g_object_set_property(
    ffi.Pointer<GObject> object,
    ffi.Pointer<ffi.Char> property_name,
    ffi.Pointer<GValue> value,
  ) {
    return _g_object_set_property(
      object,
      property_name,
      value,
    );
  }

  late final _g_object_set_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GValue>)>>('g_object_set_property');
  late final _g_object_set_property = _g_object_set_propertyPtr.asFunction<
      void Function(
          ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>, ffi.Pointer<GValue>)>();

  void g_object_get_property(
    ffi.Pointer<GObject> object,
    ffi.Pointer<ffi.Char> property_name,
    ffi.Pointer<GValue> value,
  ) {
    return _g_object_get_property(
      object,
      property_name,
      value,
    );
  }

  late final _g_object_get_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GValue>)>>('g_object_get_property');
  late final _g_object_get_property = _g_object_get_propertyPtr.asFunction<
      void Function(
          ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>, ffi.Pointer<GValue>)>();

  void g_value_set_object(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_object,
  ) {
    return _g_value_set_object(
      value,
      v_object,
    );
  }

  late final _g_value_set_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_object');
  late final _g_value_set_object = _g_value_set_objectPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> g_value_get_object(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_object(
      value,
    );
  }

  late final _g_value_get_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GValue>)>>('g_value_get_object');
  late final _g_value_get_object = _g_value_get_objectPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GValue>)>();

  void g_value_set_object_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_object,
  ) {
    return _g_value_set_object_take_ownership(
      value,
      v_object,
    );
  }

  late final _g_value_set_object_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_object_take_ownership');
  late final _g_value_set_object_take_ownership =
      _g_value_set_object_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_enum(
    ffi.Pointer<GValue> value,
    int v_enum,
  ) {
    return _g_value_set_enum(
      value,
      v_enum,
    );
  }

  late final _g_value_set_enumPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Int)>>(
      'g_value_set_enum');
  late final _g_value_set_enum = _g_value_set_enumPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_enum(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_enum(
      value,
    );
  }

  late final _g_value_get_enumPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GValue>)>>(
          'g_value_get_enum');
  late final _g_value_get_enum =
      _g_value_get_enumPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_flags(
    ffi.Pointer<GValue> value,
    int v_flags,
  ) {
    return _g_value_set_flags(
      value,
      v_flags,
    );
  }

  late final _g_value_set_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedInt)>>('g_value_set_flags');
  late final _g_value_set_flags = _g_value_set_flagsPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_flags(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_flags(
      value,
    );
  }

  late final _g_value_get_flagsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GValue>)>>(
      'g_value_get_flags');
  late final _g_value_get_flags =
      _g_value_get_flagsPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_schar(
    ffi.Pointer<GValue> value,
    int v_char,
  ) {
    return _g_value_set_schar(
      value,
      v_char,
    );
  }

  late final _g_value_set_scharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.SignedChar)>>('g_value_set_schar');
  late final _g_value_set_schar = _g_value_set_scharPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_schar(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_schar(
      value,
    );
  }

  late final _g_value_get_scharPtr =
      _lookup<ffi.NativeFunction<ffi.SignedChar Function(ffi.Pointer<GValue>)>>(
          'g_value_get_schar');
  late final _g_value_get_schar =
      _g_value_get_scharPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_uchar(
    ffi.Pointer<GValue> value,
    int v_uchar,
  ) {
    return _g_value_set_uchar(
      value,
      v_uchar,
    );
  }

  late final _g_value_set_ucharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedChar)>>('g_value_set_uchar');
  late final _g_value_set_uchar = _g_value_set_ucharPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_uchar(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_uchar(
      value,
    );
  }

  late final _g_value_get_ucharPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedChar Function(ffi.Pointer<GValue>)>>(
      'g_value_get_uchar');
  late final _g_value_get_uchar =
      _g_value_get_ucharPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_boolean(
    ffi.Pointer<GValue> value,
    int v_boolean,
  ) {
    return _g_value_set_boolean(
      value,
      v_boolean,
    );
  }

  late final _g_value_set_booleanPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Int)>>(
      'g_value_set_boolean');
  late final _g_value_set_boolean = _g_value_set_booleanPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_boolean(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_boolean(
      value,
    );
  }

  late final _g_value_get_booleanPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GValue>)>>(
          'g_value_get_boolean');
  late final _g_value_get_boolean =
      _g_value_get_booleanPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_int(
    ffi.Pointer<GValue> value,
    int v_int,
  ) {
    return _g_value_set_int(
      value,
      v_int,
    );
  }

  late final _g_value_set_intPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Int)>>(
      'g_value_set_int');
  late final _g_value_set_int =
      _g_value_set_intPtr.asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_int(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_int(
      value,
    );
  }

  late final _g_value_get_intPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GValue>)>>(
          'g_value_get_int');
  late final _g_value_get_int =
      _g_value_get_intPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_uint(
    ffi.Pointer<GValue> value,
    int v_uint,
  ) {
    return _g_value_set_uint(
      value,
      v_uint,
    );
  }

  late final _g_value_set_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedInt)>>('g_value_set_uint');
  late final _g_value_set_uint = _g_value_set_uintPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_uint(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_uint(
      value,
    );
  }

  late final _g_value_get_uintPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GValue>)>>(
      'g_value_get_uint');
  late final _g_value_get_uint =
      _g_value_get_uintPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_long(
    ffi.Pointer<GValue> value,
    int v_long,
  ) {
    return _g_value_set_long(
      value,
      v_long,
    );
  }

  late final _g_value_set_longPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Long)>>(
      'g_value_set_long');
  late final _g_value_set_long = _g_value_set_longPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_long(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_long(
      value,
    );
  }

  late final _g_value_get_longPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<GValue>)>>(
          'g_value_get_long');
  late final _g_value_get_long =
      _g_value_get_longPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_ulong(
    ffi.Pointer<GValue> value,
    int v_ulong,
  ) {
    return _g_value_set_ulong(
      value,
      v_ulong,
    );
  }

  late final _g_value_set_ulongPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_set_ulong');
  late final _g_value_set_ulong = _g_value_set_ulongPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_ulong(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_ulong(
      value,
    );
  }

  late final _g_value_get_ulongPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<GValue>)>>(
      'g_value_get_ulong');
  late final _g_value_get_ulong =
      _g_value_get_ulongPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_int64(
    ffi.Pointer<GValue> value,
    int v_int64,
  ) {
    return _g_value_set_int64(
      value,
      v_int64,
    );
  }

  late final _g_value_set_int64Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Long)>>(
      'g_value_set_int64');
  late final _g_value_set_int64 = _g_value_set_int64Ptr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_int64(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_int64(
      value,
    );
  }

  late final _g_value_get_int64Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<GValue>)>>(
          'g_value_get_int64');
  late final _g_value_get_int64 =
      _g_value_get_int64Ptr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_uint64(
    ffi.Pointer<GValue> value,
    int v_uint64,
  ) {
    return _g_value_set_uint64(
      value,
      v_uint64,
    );
  }

  late final _g_value_set_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_set_uint64');
  late final _g_value_set_uint64 = _g_value_set_uint64Ptr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_uint64(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_uint64(
      value,
    );
  }

  late final _g_value_get_uint64Ptr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<GValue>)>>(
      'g_value_get_uint64');
  late final _g_value_get_uint64 =
      _g_value_get_uint64Ptr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_float(
    ffi.Pointer<GValue> value,
    double v_float,
  ) {
    return _g_value_set_float(
      value,
      v_float,
    );
  }

  late final _g_value_set_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.Float)>>('g_value_set_float');
  late final _g_value_set_float = _g_value_set_floatPtr
      .asFunction<void Function(ffi.Pointer<GValue>, double)>();

  double g_value_get_float(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_float(
      value,
    );
  }

  late final _g_value_get_floatPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<GValue>)>>(
          'g_value_get_float');
  late final _g_value_get_float =
      _g_value_get_floatPtr.asFunction<double Function(ffi.Pointer<GValue>)>();

  void g_value_set_double(
    ffi.Pointer<GValue> value,
    double v_double,
  ) {
    return _g_value_set_double(
      value,
      v_double,
    );
  }

  late final _g_value_set_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.Double)>>('g_value_set_double');
  late final _g_value_set_double = _g_value_set_doublePtr
      .asFunction<void Function(ffi.Pointer<GValue>, double)>();

  double g_value_get_double(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_double(
      value,
    );
  }

  late final _g_value_get_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<GValue>)>>(
          'g_value_get_double');
  late final _g_value_get_double =
      _g_value_get_doublePtr.asFunction<double Function(ffi.Pointer<GValue>)>();

  void g_value_set_string(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_string(
      value,
      v_string,
    );
  }

  late final _g_value_set_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_string');
  late final _g_value_set_string = _g_value_set_stringPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  void g_value_set_static_string(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_static_string(
      value,
      v_string,
    );
  }

  late final _g_value_set_static_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_static_string');
  late final _g_value_set_static_string = _g_value_set_static_stringPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  void g_value_set_interned_string(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_interned_string(
      value,
      v_string,
    );
  }

  late final _g_value_set_interned_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_interned_string');
  late final _g_value_set_interned_string = _g_value_set_interned_stringPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> g_value_get_string(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_string(
      value,
    );
  }

  late final _g_value_get_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GValue>)>>('g_value_get_string');
  late final _g_value_get_string = _g_value_get_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<GValue>)>();

  void g_value_set_pointer(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_pointer,
  ) {
    return _g_value_set_pointer(
      value,
      v_pointer,
    );
  }

  late final _g_value_set_pointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_pointer');
  late final _g_value_set_pointer = _g_value_set_pointerPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> g_value_get_pointer(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_pointer(
      value,
    );
  }

  late final _g_value_get_pointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GValue>)>>('g_value_get_pointer');
  late final _g_value_get_pointer = _g_value_get_pointerPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GValue>)>();

  void g_value_set_gtype(
    ffi.Pointer<GValue> value,
    int v_gtype,
  ) {
    return _g_value_set_gtype(
      value,
      v_gtype,
    );
  }

  late final _g_value_set_gtypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_set_gtype');
  late final _g_value_set_gtype = _g_value_set_gtypePtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_gtype(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_gtype(
      value,
    );
  }

  late final _g_value_get_gtypePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<GValue>)>>(
      'g_value_get_gtype');
  late final _g_value_get_gtype =
      _g_value_get_gtypePtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_variant(
    ffi.Pointer<GValue> value,
    ffi.Pointer<_GVariant> variant,
  ) {
    return _g_value_set_variant(
      value,
      variant,
    );
  }

  late final _g_value_set_variantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<_GVariant>)>>('g_value_set_variant');
  late final _g_value_set_variant = _g_value_set_variantPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<_GVariant>)>();

  ffi.Pointer<_GVariant> g_value_get_variant(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_variant(
      value,
    );
  }

  late final _g_value_get_variantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_GVariant> Function(
              ffi.Pointer<GValue>)>>('g_value_get_variant');
  late final _g_value_get_variant = _g_value_get_variantPtr
      .asFunction<ffi.Pointer<_GVariant> Function(ffi.Pointer<GValue>)>();

  void g_value_set_string_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_string_take_ownership(
      value,
      v_string,
    );
  }

  late final _g_value_set_string_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_string_take_ownership');
  late final _g_value_set_string_take_ownership =
      _g_value_set_string_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<GtkSettings> gtk_settings_get_default() {
    return _gtk_settings_get_default();
  }

  late final _gtk_settings_get_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GtkSettings> Function()>>(
          'gtk_settings_get_default');
  late final _gtk_settings_get_default = _gtk_settings_get_defaultPtr
      .asFunction<ffi.Pointer<GtkSettings> Function()>();

  void gtk_settings_reset_property(
    ffi.Pointer<GtkSettings> settings,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _gtk_settings_reset_property(
      settings,
      name,
    );
  }

  late final _gtk_settings_reset_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GtkSettings>,
              ffi.Pointer<ffi.Char>)>>('gtk_settings_reset_property');
  late final _gtk_settings_reset_property =
      _gtk_settings_reset_propertyPtr.asFunction<
          void Function(ffi.Pointer<GtkSettings>, ffi.Pointer<ffi.Char>)>();
}

/// GValue:
///
/// An opaque structure used to hold different types of values.
///
/// The data within the structure has protected scope: it is accessible only
/// to functions within a #GTypeValueTable structure, or implementations of
/// the g_value_*() API. That is, code portions which implement new fundamental
/// types.
///
/// #GValue users cannot make any assumptions about how data is stored
/// within the 2 element @data union, and the @g_type member should
/// only be accessed through the G_VALUE_TYPE() macro.
final class _GValue extends ffi.Struct {
  @ffi.UnsignedLong()
  external int g_type;

  @ffi.Array.multi([2])
  external ffi.Array<UnnamedUnion1> data;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int()
  external int v_int;

  @ffi.UnsignedInt()
  external int v_uint;

  @ffi.Long()
  external int v_long;

  @ffi.UnsignedLong()
  external int v_ulong;

  @ffi.Long()
  external int v_int64;

  @ffi.UnsignedLong()
  external int v_uint64;

  @ffi.Float()
  external double v_float;

  @ffi.Double()
  external double v_double;

  external ffi.Pointer<ffi.Void> v_pointer;
}

typedef GValue = _GValue;

/// GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
/// @g_type_instance: private #GTypeInstance portion
/// @name: name of this parameter: always an interned string
/// @flags: #GParamFlags flags for this parameter
/// @value_type: the #GValue type for this parameter
/// @owner_type: #GType type that uses (introduces) this parameter
///
/// All other fields of the GParamSpec struct are private and
/// should not be used directly.
final class _GParamSpec extends ffi.Struct {
  external _GTypeInstance g_type_instance;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Int32()
  external int flags;

  @ffi.UnsignedLong()
  external int value_type;

  @ffi.UnsignedLong()
  external int owner_type;

  external ffi.Pointer<ffi.Char> _nick;

  external ffi.Pointer<ffi.Char> _blurb;

  external ffi.Pointer<_GData> qdata;

  @ffi.UnsignedInt()
  external int ref_count;

  @ffi.UnsignedInt()
  external int param_id;
}

/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
final class _GTypeInstance extends ffi.Struct {
  external ffi.Pointer<_GTypeClass> g_class;
}

/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
final class _GTypeClass extends ffi.Struct {
  @ffi.UnsignedLong()
  external int g_type;
}

/// GParamFlags:
/// @G_PARAM_READABLE: the parameter is readable
/// @G_PARAM_WRITABLE: the parameter is writable
/// @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
/// @G_PARAM_CONSTRUCT: the parameter will be set upon object construction
/// @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction
/// @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
/// strict validation is not required
/// @G_PARAM_STATIC_NAME: the string used as name when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_NICK: the string used as nick when constructing the
/// parameter is guaranteed to remain valid and
/// unmmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
/// property will not automatically result in a "notify" signal being
/// emitted: the implementation must call g_object_notify() themselves
/// in case the property actually changes.  Since: 2.42.
/// @G_PARAM_PRIVATE: internal
/// @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed
/// in a future version. A warning will be generated if it is used
/// while running with G_ENABLE_DIAGNOSTIC=1.
/// Since 2.26
///
/// Through the #GParamFlags flag values, certain aspects of parameters
/// can be configured.
///
/// See also: %G_PARAM_STATIC_STRINGS
abstract class GParamFlags {
  static const int G_PARAM_READABLE = 1;
  static const int G_PARAM_WRITABLE = 2;
  static const int G_PARAM_READWRITE = 3;
  static const int G_PARAM_CONSTRUCT = 4;
  static const int G_PARAM_CONSTRUCT_ONLY = 8;
  static const int G_PARAM_LAX_VALIDATION = 16;
  static const int G_PARAM_STATIC_NAME = 32;
  static const int G_PARAM_PRIVATE = 32;
  static const int G_PARAM_STATIC_NICK = 64;
  static const int G_PARAM_STATIC_BLURB = 128;
  static const int G_PARAM_EXPLICIT_NOTIFY = 1073741824;
  static const int G_PARAM_DEPRECATED = -2147483648;
}

final class _GData extends ffi.Opaque {}

/// GObject:
///
/// The base object type.
///
/// All the fields in the `GObject` structure are private to the implementation
/// and should never be accessed directly.
///
/// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
/// alignment of the largest basic GLib type (typically this is #guint64 or
/// #gdouble). If you need larger alignment for an element in a #GObject, you
/// should allocate it on the heap (aligned), or arrange for your #GObject to be
/// appropriately padded. This guarantee applies to the #GObject (or derived)
/// struct, the #GObjectClass (or derived) struct, and any private data allocated
/// by G_ADD_PRIVATE().
final class _GObject extends ffi.Struct {
  external _GTypeInstance g_type_instance;

  @ffi.UnsignedInt()
  external int ref_count;

  external ffi.Pointer<_GData> qdata;
}

typedef GObject = _GObject;

final class _GVariant extends ffi.Opaque {}

final class _GtkSettings extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<_GtkSettingsPrivate> priv;
}

final class _GtkSettingsPrivate extends ffi.Opaque {}

typedef GtkSettings = _GtkSettings;

const int G_TYPE_FUNDAMENTAL_MAX = 1020;

const int G_TYPE_INVALID = 0;

const int G_TYPE_NONE = 4;

const int G_TYPE_INTERFACE = 8;

const int G_TYPE_CHAR = 12;

const int G_TYPE_UCHAR = 16;

const int G_TYPE_BOOLEAN = 20;

const int G_TYPE_INT = 24;

const int G_TYPE_UINT = 28;

const int G_TYPE_LONG = 32;

const int G_TYPE_ULONG = 36;

const int G_TYPE_INT64 = 40;

const int G_TYPE_UINT64 = 44;

const int G_TYPE_ENUM = 48;

const int G_TYPE_FLAGS = 52;

const int G_TYPE_FLOAT = 56;

const int G_TYPE_DOUBLE = 60;

const int G_TYPE_STRING = 64;

const int G_TYPE_POINTER = 68;

const int G_TYPE_BOXED = 72;

const int G_TYPE_PARAM = 76;

const int G_TYPE_OBJECT = 80;

const int G_TYPE_VARIANT = 84;

const int G_TYPE_FUNDAMENTAL_SHIFT = 2;

const int G_TYPE_RESERVED_GLIB_FIRST = 22;

const int G_TYPE_RESERVED_GLIB_LAST = 31;

const int G_TYPE_RESERVED_BSE_FIRST = 32;

const int G_TYPE_RESERVED_BSE_LAST = 48;

const int G_TYPE_RESERVED_USER_FIRST = 49;

const int G_TYPE_FLAG_RESERVED_ID_BIT = 1;
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\lib\gtk.dart =====
library gtk;

export 'src/constants.dart';
export 'src/gtk_application.dart';
export 'src/gtk_application_notifier.dart';
export 'src/gtk_settings.dart';
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\test\gtk_application_notifier_test.dart =====
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/gtk.dart';

import 'test_utils.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  test('command-line', () async {
    final notifier = GtkApplicationNotifier(['foo']);
    expect(notifier.commandLine, ['foo']);

    final receivedArgs = <List<String>>[];
    notifier.addCommandLineListener(receivedArgs.add);

    await receiveMethodCall('gtk/application', 'command-line', ['foo', 'bar']);
    expect(receivedArgs, [
      ['foo', 'bar']
    ]);
    expect(notifier.commandLine, ['foo', 'bar']);

    await receiveMethodCall('gtk/application', 'command-line', ['baz qux']);
    expect(receivedArgs, [
      ['foo', 'bar'],
      ['baz qux'],
    ]);
    expect(notifier.commandLine, ['baz qux']);

    receivedArgs.clear();
    notifier.removeCommandLineListener(receivedArgs.add);

    await receiveMethodCall('gtk/application', 'command-line', ['none']);
    expect(receivedArgs, isEmpty);
    expect(notifier.commandLine, ['none']);
  });

  test('open', () async {
    final notifier = GtkApplicationNotifier();

    final receivedFiles = <List<String>>[];
    final receivedHints = <String>[];

    void receiveOpen(List<String> files, String hint) {
      receivedFiles.add(files);
      receivedHints.add(hint);
    }

    notifier.addOpenListener(receiveOpen);

    await receiveMethodCall('gtk/application', 'open', {
      'files': ['foo', 'bar'],
      'hint': 'baz'
    });
    expect(receivedFiles, [
      ['foo', 'bar']
    ]);
    expect(receivedHints, ['baz']);

    await receiveMethodCall('gtk/application', 'open', {
      'files': ['baz qux'],
      'hint': 'quux'
    });
    expect(receivedFiles, [
      ['foo', 'bar'],
      ['baz qux'],
    ]);
    expect(receivedHints, ['baz', 'quux']);

    receivedFiles.clear();
    receivedHints.clear();
    notifier.removeOpenListener(receiveOpen);

    await receiveMethodCall('gtk/application', 'open', {
      'files': <String>[],
      'hint': '',
    });
    expect(receivedFiles, isEmpty);
    expect(receivedHints, isEmpty);
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\test\gtk_application_test.dart =====
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/gtk.dart';

import 'test_utils.dart';

void main() {
  testWidgets('command-line', (tester) async {
    final receivedArgs = <List<String>>[];
    final notifier = GtkApplicationNotifier();

    await tester.pumpWidget(GtkApplication(
      notifier: notifier,
      onCommandLine: receivedArgs.add,
    ));

    notifier.notifyCommandLine(['foo', 'bar']);
    expect(receivedArgs, [
      ['foo', 'bar']
    ]);

    await tester.pumpWidget(const GtkApplication());

    receivedArgs.clear();

    await receiveMethodCall('gtk/application', 'command-line', ['none']);
    expect(receivedArgs, isEmpty);
  });

  testWidgets('open', (tester) async {
    final receivedFiles = <List<String>>[];
    final receivedHints = <String>[];
    final notifier = GtkApplicationNotifier();

    void receiveOpen(List<String> files, String hint) {
      receivedFiles.add(files);
      receivedHints.add(hint);
    }

    await tester.pumpWidget(GtkApplication(
      notifier: notifier,
      onOpen: receiveOpen,
    ));

    notifier.notifyOpen(files: ['foo', 'bar'], hint: 'baz');
    expect(receivedFiles, [
      ['foo', 'bar']
    ]);
    expect(receivedHints, ['baz']);

    await tester.pumpWidget(const GtkApplication());

    receivedFiles.clear();
    receivedHints.clear();

    await receiveMethodCall('gtk/application', 'open', {
      'files': <String>[],
      'hint': '',
    });
    expect(receivedFiles, isEmpty);
    expect(receivedHints, isEmpty);
  });

  testWidgets('rebuild', (tester) async {
    var onCommandLine1 = 0;
    var onOpen1 = 0;
    final notifier1 = GtkApplicationNotifier();
    await tester.pumpWidget(
      GtkApplication(
        notifier: notifier1,
        onCommandLine: (_) => onCommandLine1++,
        onOpen: (_, __) => onOpen1++,
      ),
    );
    notifier1.notifyCommandLine(['foo']);
    expect(onCommandLine1, 1);
    notifier1.notifyOpen(files: ['foo'], hint: 'bar');
    expect(onOpen1, 1);

    var onCommandLine2 = 0;
    var onOpen2 = 0;
    final notifier2 = GtkApplicationNotifier();
    await tester.pumpWidget(
      GtkApplication(
        notifier: notifier2,
        onCommandLine: (_) => onCommandLine2++,
        onOpen: (_, __) => onOpen2++,
      ),
    );
    notifier2.notifyCommandLine(['foo']);
    expect(onCommandLine2, 1);
    notifier2.notifyOpen(files: ['foo'], hint: 'bar');
    expect(onOpen2, 1);

    notifier1.notifyCommandLine(['foo']);
    expect(onCommandLine1, 1);
    notifier1.notifyOpen(files: ['foo'], hint: 'bar');
    expect(onOpen1, 1);
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\test\gtk_settings_test.dart =====
import 'package:ffi/ffi.dart' as ffi;
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/gtk.dart';
import 'package:gtk/src/libgtk.g.dart' hide GtkSettings;

import 'test_utils.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  test('boolean', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'boolean': MockGValue(G_TYPE_BOOLEAN, true),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('boolean'), true);
      settings.setProperty('boolean', false);
      expect(settings.getProperty('boolean'), false);

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('boolean')
          .listen(expectAsync1((value) => expect(value, false), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'boolean');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('boolean');
      expect(settings.getProperty('boolean'), isNull);
    });
  });

  test('int', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'int': MockGValue(G_TYPE_INT64, -123456789),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('int'), -123456789);
      settings.setProperty('int', -987654321);
      expect(settings.getProperty('int'), -987654321);

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('int')
          .listen(expectAsync1((value) => expect(value, -987654321), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'int');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('int');
      expect(settings.getProperty('int'), isNull);
    });
  });

  test('double', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'double': MockGValue(G_TYPE_DOUBLE, 123456.789),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('double'), 123456.789);
      settings.setProperty('double', 789012.345);
      expect(settings.getProperty('double'), 789012.345);

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('double')
          .listen(expectAsync1((value) => expect(value, 789012.345), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'double');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('double');
      expect(settings.getProperty('double'), isNull);
    });
  });

  test('string', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'string': MockGValue(G_TYPE_STRING, 'foo'),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('string'), 'foo');
      settings.setProperty('string', 'bar');
      expect(settings.getProperty('string'), 'bar');

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('string')
          .listen(expectAsync1((value) => expect(value, 'bar'), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'string');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('string');
      expect(settings.getProperty('string'), isNull);

      await receiveMethodCall('gtk/settings', 'notify', 'other');
      expect(wasNotified, ++expectedNotified);
    });
  });

  test('other', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {});

      final settings = GtkSettings();

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      await receiveMethodCall('gtk/settings', 'notify', 'other');
      expect(wasNotified, ++expectedNotified);
    });
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\test\test_utils.dart =====
// ignore_for_file: non_constant_identifier_names

import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as ffi;
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/src/libgtk.dart';
import 'package:gtk/src/libgtk.g.dart' as ffi;
import 'package:mockito/mockito.dart';

import 'test_utils.mocks.dart';

Future<void> receiveMethodCall(
  String channel,
  String method, [
  dynamic arguments,
]) async {
  const codec = StandardMethodCodec();
  final messenger =
      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger;

  await messenger.handlePlatformMessage(
    channel,
    codec.encodeMethodCall(MethodCall(method, arguments)),
    (_) {},
  );
}

class MockGValue {
  const MockGValue(this.t, this.v);
  final int t;
  final dynamic v;
}

MockLibGtk mockLibGtk({
  required ffi.Allocator allocator,
  required Map<String, MockGValue> properties,
}) {
  final gtk = ffi.LibGtk(ffi.DynamicLibrary.open('libgtk-3.so.0'));

  final settings = ffi.Pointer<ffi.GtkSettings>.fromAddress(0x1234);

  final mock = MockLibGtk();
  overrideLibGtkForTesting(mock);
  when(mock.gtk_settings_get_default()).thenReturn(settings);

  when(mock.g_object_get_property(settings, any, any)).thenAnswer((i) {
    final key = i.positionalArguments[1] as ffi.Pointer<ffi.Char>;
    final value = properties[key.cast<ffi.Utf8>().toDartString()];
    if (value != null) {
      final ret = i.positionalArguments[2] as ffi.Pointer<ffi.GValue>;
      gtk.g_value_init(ret, value.t);
      switch (value.t) {
        case ffi.G_TYPE_BOOLEAN:
          gtk.g_value_set_boolean(ret, value.v as bool ? 1 : 0);
          when(mock.g_value_get_boolean(ret)).thenReturn(value.v ? 1 : 0);
          break;
        case ffi.G_TYPE_CHAR:
          gtk.g_value_set_schar(ret, value.v as int);
          when(mock.g_value_get_schar(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_UCHAR:
          gtk.g_value_set_uchar(ret, value.v as int);
          when(mock.g_value_get_uchar(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_INT:
          gtk.g_value_set_int(ret, value.v as int);
          when(mock.g_value_get_int(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_UINT:
          gtk.g_value_set_uint(ret, value.v as int);
          when(mock.g_value_get_uint(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_LONG:
          gtk.g_value_set_long(ret, value.v as int);
          when(mock.g_value_get_long(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_ULONG:
          gtk.g_value_set_ulong(ret, value.v as int);
          when(mock.g_value_get_ulong(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_INT64:
          gtk.g_value_set_int64(ret, value.v as int);
          when(mock.g_value_get_int64(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_UINT64:
          gtk.g_value_set_uint64(ret, value.v as int);
          when(mock.g_value_get_uint64(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_FLOAT:
          gtk.g_value_set_float(ret, value.v as double);
          when(mock.g_value_get_float(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_DOUBLE:
          gtk.g_value_set_double(ret, value.v as double);
          when(mock.g_value_get_double(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_STRING:
          final str = (value.v as String).toNativeUtf8(allocator: allocator);
          gtk.g_value_set_string(ret, str.cast());
          when(mock.g_value_get_string(ret)).thenReturn(str.cast());
          break;
        default:
          throw ArgumentError('${value.v} (${value.t})');
      }
    }
  });

  when(mock.g_object_set_property(settings, any, any)).thenAnswer((i) {
    final key = (i.positionalArguments[1] as ffi.Pointer<ffi.Char>)
        .cast<ffi.Utf8>()
        .toDartString();
    final value = i.positionalArguments[2] as ffi.Pointer<ffi.GValue>;
    final t = value.ref.g_type;
    dynamic v;
    switch (t) {
      case ffi.G_TYPE_BOOLEAN:
        v = gtk.g_value_get_boolean(value) != 0;
        break;
      case ffi.G_TYPE_CHAR:
        v = gtk.g_value_get_schar(value);
        break;
      case ffi.G_TYPE_UCHAR:
        v = gtk.g_value_get_uchar(value);
        break;
      case ffi.G_TYPE_INT:
        v = gtk.g_value_get_int(value);
        break;
      case ffi.G_TYPE_UINT:
        v = gtk.g_value_get_uint(value);
        break;
      case ffi.G_TYPE_LONG:
        v = gtk.g_value_get_long(value);
        break;
      case ffi.G_TYPE_ULONG:
        v = gtk.g_value_get_ulong(value);
        break;
      case ffi.G_TYPE_INT64:
        v = gtk.g_value_get_int64(value);
        break;
      case ffi.G_TYPE_UINT64:
        v = gtk.g_value_get_uint64(value);
        break;
      case ffi.G_TYPE_FLOAT:
        v = gtk.g_value_get_float(value);
        break;
      case ffi.G_TYPE_DOUBLE:
        v = gtk.g_value_get_double(value);
        break;
      case ffi.G_TYPE_STRING:
        v = gtk.g_value_get_string(value).cast<ffi.Utf8>().toDartString();
        break;
      default:
        throw ArgumentError.value(value.ref.g_type);
    }
    properties[key] = MockGValue(t, v);
  });

  when(mock.gtk_settings_reset_property(settings, any)).thenAnswer((i) {
    final key = (i.positionalArguments[1] as ffi.Pointer<ffi.Char>)
        .cast<ffi.Utf8>()
        .toDartString();
    properties.remove(key);
  });

  when(mock.g_value_init(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_init(value, i.positionalArguments[1] as int);
    return value;
  });
  when(mock.g_value_set_boolean(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_boolean(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_schar(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_schar(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_uchar(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_uchar(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_int(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_int(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_uint(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_uint(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_long(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_long(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_ulong(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_ulong(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_int64(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_int64(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_uint64(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_uint64(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_float(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_float(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_double(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_double(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_string(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_string(value, i.positionalArguments[1]);
  });

  return mock;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\gtk\test\test_utils.mocks.dart =====
// ignore_for_file: non_constant_identifier_names

import 'dart:ffi' as ffi;

import 'package:gtk/src/libgtk.g.dart';
import 'package:mockito/mockito.dart';

class MockLibGtk extends Mock implements LibGtk {
  @override
  ffi.Pointer<GtkSettings> gtk_settings_get_default() {
    return super.noSuchMethod(
      Invocation.method(#gtk_settings_get_default, []),
      returnValue: ffi.nullptr,
    );
  }

  @override
  void gtk_settings_reset_property(ffi.Pointer? settings, ffi.Pointer? name) {
    return super.noSuchMethod(
      Invocation.method(#gtk_settings_reset_property, [settings, name]),
    );
  }

  @override
  void g_object_get_property(ffi.Pointer? object,
      ffi.Pointer<ffi.Char>? property_name, ffi.Pointer? value) {
    return super.noSuchMethod(Invocation.method(#g_object_get_property, [
      object,
      property_name,
      value,
    ]));
  }

  @override
  void g_object_set_property(ffi.Pointer? object,
      ffi.Pointer<ffi.Char>? property_name, ffi.Pointer? value) {
    return super.noSuchMethod(Invocation.method(#g_object_set_property, [
      object,
      property_name,
      value,
    ]));
  }

  @override
  ffi.Pointer<GValue> g_value_init(ffi.Pointer? value, int? g_type) {
    return super.noSuchMethod(
      Invocation.method(#g_value_init, [value, g_type]),
      returnValue: ffi.nullptr,
    );
  }

  @override
  int g_value_get_boolean(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_boolean, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_boolean(ffi.Pointer? value, int? v_boolean) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_boolean, [value, v_boolean]),
    );
  }

  @override
  int g_value_get_schar(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_schar, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_schar(ffi.Pointer? value, int? v_char) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_schar, [value, v_char]),
    );
  }

  @override
  int g_value_get_uchar(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_uchar, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_uchar(ffi.Pointer? value, int? v_uchar) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_uchar, [value, v_uchar]),
    );
  }

  @override
  int g_value_get_int(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_int, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_int(ffi.Pointer? value, int? v_int) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_int, [value, v_int]),
    );
  }

  @override
  int g_value_get_uint(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_uint, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_uint(ffi.Pointer? value, int? v_uint) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_uint, [value, v_uint]),
    );
  }

  @override
  int g_value_get_long(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_long, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_long(ffi.Pointer? value, int? v_long) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_long, [value, v_long]),
    );
  }

  @override
  int g_value_get_ulong(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_ulong, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_ulong(ffi.Pointer? value, int? v_ulong) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_ulong, [value, v_ulong]),
    );
  }

  @override
  int g_value_get_int64(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_int64, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_int64(ffi.Pointer? value, int? v_int64) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_int64, [value, v_int64]),
    );
  }

  @override
  int g_value_get_uint64(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_uint64, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_uint64(ffi.Pointer? value, int? v_uint64) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_uint64, [value, v_uint64]),
    );
  }

  @override
  double g_value_get_float(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_float, [value]),
      returnValue: 0.0,
    );
  }

  @override
  void g_value_set_float(ffi.Pointer? value, double? v_float) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_float, [value, v_float]),
    );
  }

  @override
  double g_value_get_double(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_double, [value]),
      returnValue: 0.0,
    );
  }

  @override
  void g_value_set_double(ffi.Pointer? value, double? v_double) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_double, [value, v_double]),
    );
  }

  @override
  ffi.Pointer<ffi.Char> g_value_get_string(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_string, [value]),
      returnValue: ffi.nullptr,
    );
  }

  @override
  void g_value_set_string(ffi.Pointer? value, ffi.Pointer? v_string) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_string, [value, v_string]),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mime/mime.dart';
import 'package:video_player/video_player.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Image Picker Demo',
      home: MyHomePage(title: 'Image Picker Example'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, this.title});

  final String? title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<XFile>? _mediaFileList;

  // This must be called from within a setState() callback
  void _setImageFileListFromFile(XFile? value) {
    _mediaFileList = value == null ? null : <XFile>[value];
  }

  dynamic _pickImageError;
  bool _isVideo = false;

  VideoPlayerController? _controller;
  VideoPlayerController? _toBeDisposed;
  String? _retrieveDataError;

  final ImagePickerPlatform _picker = ImagePickerPlatform.instance;
  final TextEditingController maxWidthController = TextEditingController();
  final TextEditingController maxHeightController = TextEditingController();
  final TextEditingController qualityController = TextEditingController();

  Future<void> _playVideo(XFile? file) async {
    if (file != null && mounted) {
      await _disposeVideoController();
      final VideoPlayerController controller =
          VideoPlayerController.file(File(file.path));
      _controller = controller;
      await controller.setVolume(1.0);
      await controller.initialize();
      await controller.setLooping(true);
      await controller.play();
      setState(() {});
    }
  }

  Future<void> _onImageButtonPressed(
    ImageSource source, {
    required BuildContext context,
    bool allowMultiple = false,
    bool isMedia = false,
  }) async {
    if (_controller != null) {
      await _controller!.setVolume(0.0);
    }
    if (context.mounted) {
      if (_isVideo) {
        final List<XFile> files;
        if (allowMultiple) {
          files = await _picker.getMultiVideoWithOptions();
        } else {
          final XFile? file = await _picker.getVideo(
              source: source, maxDuration: const Duration(seconds: 10));
          files = <XFile>[if (file != null) file];
        }
        if (files.isNotEmpty && context.mounted) {
          _showPickedSnackBar(context, files);
          // Just play the first file, to keep the example simple.
          await _playVideo(files.first);
        }
      } else if (allowMultiple) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final ImageOptions imageOptions = ImageOptions(
              maxWidth: maxWidth,
              maxHeight: maxHeight,
              imageQuality: quality,
            );
            final List<XFile> pickedFileList = isMedia
                ? await _picker.getMedia(
                    options: MediaOptions(
                      allowMultiple: allowMultiple,
                      imageOptions: imageOptions,
                    ),
                  )
                : await _picker.getMultiImageWithOptions(
                    options: MultiImagePickerOptions(
                      imageOptions: imageOptions,
                    ),
                  );
            if (pickedFileList.isNotEmpty && context.mounted) {
              _showPickedSnackBar(context, pickedFileList);
            }
            setState(() {
              _mediaFileList = pickedFileList;
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      } else if (isMedia) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = <XFile>[];
            final XFile? media = _firstOrNull(await _picker.getMedia(
              options: MediaOptions(
                  allowMultiple: allowMultiple,
                  imageOptions: ImageOptions(
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    imageQuality: quality,
                  )),
            ));

            if (media != null) {
              pickedFileList.add(media);
              setState(() {
                _mediaFileList = pickedFileList;
              });
            }
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      } else {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final XFile? pickedFile = await _picker.getImageFromSource(
              source: source,
              options: ImagePickerOptions(
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                imageQuality: quality,
              ),
            );
            if (pickedFile != null && context.mounted) {
              _showPickedSnackBar(context, <XFile>[pickedFile]);
            }
            setState(() => _setImageFileListFromFile(pickedFile));
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      }
    }
  }

  @override
  void deactivate() {
    if (_controller != null) {
      _controller!.setVolume(0.0);
      _controller!.pause();
    }
    super.deactivate();
  }

  @override
  void dispose() {
    _disposeVideoController();
    maxWidthController.dispose();
    maxHeightController.dispose();
    qualityController.dispose();
    super.dispose();
  }

  Future<void> _disposeVideoController() async {
    if (_toBeDisposed != null) {
      await _toBeDisposed!.dispose();
    }
    _toBeDisposed = _controller;
    _controller = null;
  }

  Widget _previewVideo() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_controller == null) {
      return const Text(
        'You have not yet picked a video',
        textAlign: TextAlign.center,
      );
    }
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: AspectRatioVideo(_controller),
    );
  }

  Widget _previewImages() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_mediaFileList != null) {
      return Semantics(
        label: 'image_picker_example_picked_images',
        child: ListView.builder(
          key: UniqueKey(),
          itemBuilder: (BuildContext context, int index) {
            final XFile image = _mediaFileList![index];
            final String? mime = lookupMimeType(_mediaFileList![index].path);
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                Text(image.name,
                    key: const Key('image_picker_example_picked_image_name')),
                Semantics(
                  label: 'image_picker_example_picked_image',
                  child: mime == null || mime.startsWith('image/')
                      ? Image.file(
                          File(_mediaFileList![index].path),
                          errorBuilder: (BuildContext context, Object error,
                              StackTrace? stackTrace) {
                            return const Center(
                                child:
                                    Text('This image type is not supported'));
                          },
                        )
                      : _buildInlineVideoPlayer(index),
                ),
              ],
            );
          },
          itemCount: _mediaFileList!.length,
        ),
      );
    } else if (_pickImageError != null) {
      return Text(
        'Pick image error: $_pickImageError',
        textAlign: TextAlign.center,
      );
    } else {
      return const Text(
        'You have not yet picked an image.',
        textAlign: TextAlign.center,
      );
    }
  }

  Widget _buildInlineVideoPlayer(int index) {
    final VideoPlayerController controller =
        VideoPlayerController.file(File(_mediaFileList![index].path));
    controller.setVolume(1.0);
    controller.initialize();
    controller.setLooping(true);
    controller.play();
    return Center(child: AspectRatioVideo(controller));
  }

  Widget _handlePreview() {
    if (_isVideo) {
      return _previewVideo();
    } else {
      return _previewImages();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title!),
      ),
      body: Align(
        alignment: Alignment.topCenter,
        child: _handlePreview(),
      ),
      floatingActionButton: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: <Widget>[
          Semantics(
            label: 'image_picker_example_from_gallery',
            child: FloatingActionButton.extended(
              key: const Key('image_picker_example_from_gallery'),
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'image0',
              tooltip: 'Pick image from gallery',
              label: const Text('Pick image from gallery'),
              icon: const Icon(Icons.photo),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                );
              },
              heroTag: 'image1',
              tooltip: 'Pick multiple images',
              label: const Text('Pick multiple images'),
              icon: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMedia: true,
                );
              },
              heroTag: 'media',
              tooltip: 'Pick item from gallery',
              label: const Text('Pick item from gallery'),
              icon: const Icon(Icons.photo_outlined),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                  isMedia: true,
                );
              },
              heroTag: 'multipleMedia',
              tooltip: 'Pick multiple items',
              label: const Text('Pick multiple items'),
              icon: const Icon(Icons.photo_library_outlined),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                onPressed: () {
                  _isVideo = false;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'image2',
                tooltip: 'Take a photo',
                label: const Text('Take a photo'),
                icon: const Icon(Icons.camera_alt),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'video',
              tooltip: 'Pick video from gallery',
              label: const Text('Pick video from gallery'),
              icon: const Icon(Icons.video_file),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery,
                    context: context, allowMultiple: true);
              },
              heroTag: 'multiVideo',
              tooltip: 'Pick multiple videos',
              label: const Text('Pick multiple videos'),
              icon: const Icon(Icons.video_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                backgroundColor: Colors.red,
                onPressed: () {
                  _isVideo = true;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'takeVideo',
                tooltip: 'Take a video',
                label: const Text('Take a video'),
                icon: const Icon(Icons.videocam),
              ),
            ),
        ],
      ),
    );
  }

  Text? _getRetrieveErrorWidget() {
    if (_retrieveDataError != null) {
      final Text result = Text(_retrieveDataError!);
      _retrieveDataError = null;
      return result;
    }
    return null;
  }

  Future<void> _displayPickImageDialog(
      BuildContext context, OnPickImageCallback onPick) async {
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('Add optional parameters'),
            content: Column(
              children: <Widget>[
                TextField(
                  controller: maxWidthController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxWidth if desired'),
                ),
                TextField(
                  controller: maxHeightController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxHeight if desired'),
                ),
                TextField(
                  controller: qualityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                      hintText: 'Enter quality if desired'),
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('CANCEL'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                  child: const Text('PICK'),
                  onPressed: () {
                    final double? width = maxWidthController.text.isNotEmpty
                        ? double.parse(maxWidthController.text)
                        : null;
                    final double? height = maxHeightController.text.isNotEmpty
                        ? double.parse(maxHeightController.text)
                        : null;
                    final int? quality = qualityController.text.isNotEmpty
                        ? int.parse(qualityController.text)
                        : null;
                    onPick(width, height, quality);
                    Navigator.of(context).pop();
                  }),
            ],
          );
        });
  }

  void _showPickedSnackBar(BuildContext context, List<XFile> files) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text('Picked: ${files.map((XFile it) => it.name).join(',')}'),
      duration: const Duration(seconds: 2),
    ));
  }
}

typedef OnPickImageCallback = void Function(
    double? maxWidth, double? maxHeight, int? quality);

class AspectRatioVideo extends StatefulWidget {
  const AspectRatioVideo(this.controller, {super.key});

  final VideoPlayerController? controller;

  @override
  AspectRatioVideoState createState() => AspectRatioVideoState();
}

class AspectRatioVideoState extends State<AspectRatioVideo> {
  VideoPlayerController? get controller => widget.controller;
  bool initialized = false;

  void _onVideoControllerUpdate() {
    if (!mounted) {
      return;
    }
    if (initialized != controller!.value.isInitialized) {
      initialized = controller!.value.isInitialized;
      setState(() {});
    }
  }

  @override
  void initState() {
    super.initState();
    controller!.addListener(_onVideoControllerUpdate);
  }

  @override
  void dispose() {
    controller!.removeListener(_onVideoControllerUpdate);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (initialized) {
      return Center(
        child: AspectRatio(
          aspectRatio: controller!.value.aspectRatio,
          child: VideoPlayer(controller!),
        ),
      );
    } else {
      return Container();
    }
  }
}

T? _firstOrNull<T>(List<T> list) {
  return list.isEmpty ? null : list.first;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\lib\image_picker_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

/// The Linux implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// Linux.
class ImagePickerLinux extends CameraDelegatingImagePickerPlatform {
  /// Constructs a platform implementation.
  ImagePickerLinux();

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorLinux();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerLinux();
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are not currently supported. If any
  // of its fields are set, they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Images', mimeTypes: <String>['image/*']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Videos', mimeTypes: <String>['video/*']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Images', mimeTypes: <String>['image/*']);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  @override
  Future<List<XFile>> getMultiVideoWithOptions(
      {MultiVideoPickerOptions options =
          const MultiVideoPickerOptions()}) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Videos', mimeTypes: <String>['video/*']);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'Images and videos',
      mimeTypes: <String>['image/*', 'video/*'],
    );

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\test\image_picker_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'image_picker_linux_test.mocks.dart';

@GenerateMocks(<Type>[FileSelectorPlatform])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Returns the captured type groups from a mock call result, assuming that
  // exactly one call was made and only the type groups were captured.
  List<XTypeGroup> capturedTypeGroups(VerificationResult result) {
    return result.captured.single as List<XTypeGroup>;
  }

  late ImagePickerLinux plugin;
  late MockFileSelectorPlatform mockFileSelectorPlatform;

  setUp(() {
    plugin = ImagePickerLinux();
    mockFileSelectorPlatform = MockFileSelectorPlatform();

    when(mockFileSelectorPlatform.openFile(
            acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
        .thenAnswer((_) async => null);

    when(mockFileSelectorPlatform.openFiles(
            acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
        .thenAnswer((_) async => List<XFile>.empty());

    ImagePickerLinux.fileSelector = mockFileSelectorPlatform;
  });

  test('registered instance', () {
    ImagePickerLinux.registerWith();
    expect(ImagePickerPlatform.instance, isA<ImagePickerLinux>());
  });

  group('images', () {
    test('pickImage passes the accepted type groups correctly', () async {
      await plugin.pickImage(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImage passes the accepted type groups correctly', () async {
      await plugin.getImage(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImageFromSource passes the accepted type groups correctly',
        () async {
      await plugin.getImageFromSource(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImageFromSource calls delegate when source is camera', () async {
      const String fakePath = '/tmp/foo';
      plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
      expect(
          (await plugin.getImageFromSource(source: ImageSource.camera))!.path,
          fakePath);
    });

    test(
        'getImageFromSource throws StateError when source is camera with no delegate',
        () async {
      await expectLater(plugin.getImageFromSource(source: ImageSource.camera),
          throwsStateError);
    });

    test('getMultiImage passes the accepted type groups correctly', () async {
      await plugin.getMultiImage();

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });
  });

  group('videos', () {
    test('pickVideo passes the accepted type groups correctly', () async {
      await plugin.pickVideo(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });

    test('getVideo passes the accepted type groups correctly', () async {
      await plugin.getVideo(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });

    test('getVideo calls delegate when source is camera', () async {
      const String fakePath = '/tmp/foo';
      plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
      expect(
          (await plugin.getVideo(source: ImageSource.camera))!.path, fakePath);
    });

    test('getVideo throws StateError when source is camera with no delegate',
        () async {
      await expectLater(
          plugin.getVideo(source: ImageSource.camera), throwsStateError);
    });

    test('getMultiVideoWithOptions passes the accepted type groups correctly',
        () async {
      await plugin.getMultiVideoWithOptions();

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });
  });

  group('media', () {
    test('getMedia passes the accepted type groups correctly', () async {
      await plugin.getMedia(options: const MediaOptions(allowMultiple: true));

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes,
          <String>['image/*', 'video/*']);
    });

    test('multiple media handles an empty path response gracefully', () async {
      expect(
          await plugin.getMedia(
            options: const MediaOptions(
              allowMultiple: true,
            ),
          ),
          <String>[]);
    });

    test('single media handles an empty path response gracefully', () async {
      expect(
          await plugin.getMedia(
            options: const MediaOptions(
              allowMultiple: false,
            ),
          ),
          <String>[]);
    });
  });
}

class FakeCameraDelegate extends ImagePickerCameraDelegate {
  FakeCameraDelegate({this.result});

  XFile? result;

  @override
  Future<XFile?> takePhoto(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }

  @override
  Future<XFile?> takeVideo(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\image_picker_linux\test\image_picker_linux_test.mocks.dart =====
// Mocks generated by Mockito 5.4.4 from annotations
// in image_picker_linux/test/image_picker_linux_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [FileSelectorPlatform].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSelectorPlatform extends _i1.Mock
    implements _i2.FileSelectorPlatform {
  MockFileSelectorPlatform() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i2.XFile?> openFile({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFile,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<_i2.XFile?>.value(),
      ) as _i3.Future<_i2.XFile?>);

  @override
  _i3.Future<List<_i2.XFile>> openFiles({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFiles,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<_i2.XFile>>.value(<_i2.XFile>[]),
      ) as _i3.Future<List<_i2.XFile>>);

  @override
  _i3.Future<String?> getSavePath({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSavePath,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #suggestedName: suggestedName,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<_i2.FileSaveLocation?> getSaveLocation({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    _i2.SaveDialogOptions? options = const _i2.SaveDialogOptions(),
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSaveLocation,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #options: options,
          },
        ),
        returnValue: _i3.Future<_i2.FileSaveLocation?>.value(),
      ) as _i3.Future<_i2.FileSaveLocation?>);

  @override
  _i3.Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPath,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPaths,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<String>>.value(<String>[]),
      ) as _i3.Future<List<String>>);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\integration_test\path_provider_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getDownloadDirectory', (WidgetTester tester) async {
    if (!Platform.isLinux) {
      return;
    }
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloadDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _appCacheDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  final PathProviderLinux _provider = PathProviderLinux();

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? appCacheDirectory;
    String? documentsDirectory;
    // Platform messages may fail, so we use a try/catch PlatformException.
    try {
      tempDirectory = await _provider.getTemporaryPath();
    } on PlatformException {
      tempDirectory = 'Failed to get temp directory.';
    }
    try {
      downloadsDirectory = await _provider.getDownloadsPath();
    } on PlatformException {
      downloadsDirectory = 'Failed to get downloads directory.';
    }

    try {
      documentsDirectory = await _provider.getApplicationDocumentsPath();
    } on PlatformException {
      documentsDirectory = 'Failed to get documents directory.';
    }

    try {
      appSupportDirectory = await _provider.getApplicationSupportPath();
    } on PlatformException {
      appSupportDirectory = 'Failed to get documents directory.';
    }

    try {
      appCacheDirectory = await _provider.getApplicationCachePath();
    } on PlatformException {
      appCacheDirectory = 'Failed to get cache directory.';
    }
    // If the widget was removed from the tree while the asynchronous platform
    // message was in flight, we want to discard the reply rather than calling
    // setState to update our non-existent appearance.
    if (!mounted) {
      return;
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _appCacheDirectory = appCacheDirectory;
      _documentsDirectory = documentsDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider Linux example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Application Cache Directory: $_appCacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// getApplicationId() is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'get_application_id_stub.dart'
    if (dart.library.ffi) 'get_application_id_real.dart';
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id_real.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

// GApplication* g_application_get_default();
typedef _GApplicationGetDefaultC = IntPtr Function();
typedef _GApplicationGetDefaultDart = int Function();

// const gchar* g_application_get_application_id(GApplication* application);
typedef _GApplicationGetApplicationIdC = Pointer<Utf8> Function(IntPtr);
typedef _GApplicationGetApplicationIdDart = Pointer<Utf8> Function(int);

/// Interface for interacting with libgio.
@visibleForTesting
class GioUtils {
  /// Creates a default instance that uses the real libgio.
  GioUtils() {
    try {
      _gio = DynamicLibrary.open('libgio-2.0.so');
    } on ArgumentError {
      _gio = null;
    }
  }

  DynamicLibrary? _gio;

  /// True if libgio was opened successfully.
  bool get libraryIsPresent => _gio != null;

  /// Wraps `g_application_get_default`.
  int gApplicationGetDefault() {
    if (_gio == null) {
      return 0;
    }
    final _GApplicationGetDefaultDart getDefault = _gio!
        .lookupFunction<_GApplicationGetDefaultC, _GApplicationGetDefaultDart>(
            'g_application_get_default');
    return getDefault();
  }

  /// Wraps g_application_get_application_id.
  Pointer<Utf8> gApplicationGetApplicationId(int app) {
    if (_gio == null) {
      return nullptr;
    }
    final _GApplicationGetApplicationIdDart gApplicationGetApplicationId = _gio!
        .lookupFunction<_GApplicationGetApplicationIdC,
                _GApplicationGetApplicationIdDart>(
            'g_application_get_application_id');
    return gApplicationGetApplicationId(app);
  }
}

/// Allows overriding the default GioUtils instance with a fake for testing.
@visibleForTesting
GioUtils? gioUtilsOverride;

/// Gets the application ID for this app.
String? getApplicationId() {
  final GioUtils gio = gioUtilsOverride ?? GioUtils();
  if (!gio.libraryIsPresent) {
    return null;
  }

  final int app = gio.gApplicationGetDefault();
  if (app == 0) {
    return null;
  }
  final Pointer<Utf8> appId = gio.gApplicationGetApplicationId(app);
  if (appId == nullptr) {
    return null;
  }
  return appId.toDartString();
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\get_application_id_stub.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Gets the application ID for this app.
String? getApplicationId() => null;
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\src\path_provider_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

import 'get_application_id.dart';

/// The linux implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Linux.
class PathProviderLinux extends PathProviderPlatform {
  /// Constructs an instance of [PathProviderLinux]
  PathProviderLinux() : _environment = Platform.environment;

  /// Constructs an instance of [PathProviderLinux] with the given [environment]
  @visibleForTesting
  PathProviderLinux.private(
      {Map<String, String> environment = const <String, String>{},
      String? executableName,
      String? applicationId})
      : _environment = environment,
        _executableName = executableName,
        _applicationId = applicationId;

  final Map<String, String> _environment;
  String? _executableName;
  String? _applicationId;

  /// Registers this class as the default instance of [PathProviderPlatform]
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderLinux();
  }

  @override
  Future<String?> getTemporaryPath() {
    final String environmentTmpDir = _environment['TMPDIR'] ?? '';
    return Future<String?>.value(
      environmentTmpDir.isEmpty ? '/tmp' : environmentTmpDir,
    );
  }

  @override
  Future<String?> getApplicationSupportPath() async {
    final Directory directory =
        Directory(path.join(xdg.dataHome.path, await _getId()));
    if (directory.existsSync()) {
      return directory.path;
    }

    // This plugin originally used the executable name as a directory.
    // Use that if it exists for backwards compatibility.
    final Directory legacyDirectory =
        Directory(path.join(xdg.dataHome.path, await _getExecutableName()));
    if (legacyDirectory.existsSync()) {
      return legacyDirectory.path;
    }

    // Create the directory, because mobile implementations assume the directory exists.
    await directory.create(recursive: true);
    return directory.path;
  }

  @override
  Future<String?> getApplicationDocumentsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOCUMENTS')?.path);
  }

  @override
  Future<String?> getApplicationCachePath() async {
    final Directory directory =
        Directory(path.join(xdg.cacheHome.path, await _getId()));
    if (!directory.existsSync()) {
      await directory.create(recursive: true);
    }
    return directory.path;
  }

  @override
  Future<String?> getDownloadsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOWNLOAD')?.path);
  }

  // Gets the name of this executable.
  Future<String> _getExecutableName() async {
    _executableName ??= path.basenameWithoutExtension(
        await File('/proc/self/exe').resolveSymbolicLinks());
    return _executableName!;
  }

  // Gets the unique ID for this application.
  Future<String> _getId() async {
    _applicationId ??= getApplicationId();
    // If no application ID then fall back to using the executable name.
    return _applicationId ?? await _getExecutableName();
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\lib\path_provider_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export 'src/path_provider_linux.dart';
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\test\get_application_id_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/src/get_application_id_real.dart';

class _FakeGioUtils implements GioUtils {
  int? application;
  Pointer<Utf8>? applicationId;

  @override
  bool libraryIsPresent = false;

  @override
  int gApplicationGetDefault() => application!;

  @override
  Pointer<Utf8> gApplicationGetApplicationId(int app) => applicationId!;
}

void main() {
  late _FakeGioUtils fakeGio;

  setUp(() {
    fakeGio = _FakeGioUtils();
    gioUtilsOverride = fakeGio;
  });

  tearDown(() {
    gioUtilsOverride = null;
  });

  test('returns null if libgio is not available', () {
    expect(getApplicationId(), null);
  });

  test('returns null if g_paplication_get_default returns 0', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 0;
    expect(getApplicationId(), null);
  });

  test('returns null if g_application_get_application_id returns nullptr', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    fakeGio.applicationId = nullptr;
    expect(getApplicationId(), null);
  });

  test('returns value if g_application_get_application_id returns a value', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    const String id = 'foo';
    final Pointer<Utf8> idPtr = id.toNativeUtf8();
    fakeGio.applicationId = idPtr;
    expect(getApplicationId(), id);
    calloc.free(idPtr);
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\path_provider_linux\test\path_provider_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  PathProviderLinux.registerWith();

  test('registered instance', () {
    expect(PathProviderPlatform.instance, isA<PathProviderLinux>());
  });

  test('getTemporaryPath defaults to TMPDIR', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': '/run/user/0/tmp'},
    );
    expect(await plugin.getTemporaryPath(), '/run/user/0/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is empty', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': ''},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is unset', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getApplicationSupportPath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary',
        applicationId: 'com.example.Test');
    // Note this will fail if ${xdg.dataHome.path}/path_provider_linux_test_binary exists on the local filesystem.
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/com.example.Test');
  });

  test('getApplicationSupportPath uses executable name if no application Id',
      () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/path_provider_linux_test_binary');
  });

  test('getApplicationDocumentsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getApplicationDocumentsPath(), startsWith('/'));
  });

  test('getApplicationCachePath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationCachePath(),
        '${xdg.cacheHome.path}/path_provider_linux_test_binary');
  });

  test('getDownloadsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getDownloadsPath(), startsWith('/'));
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\integration_test\shared_preferences_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesLinux', () {
    late SharedPreferencesLinux preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesLinux();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesLinuxOptions emptyOptions =
        SharedPreferencesLinuxOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncLinux).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesLinuxOptions options =
      const SharedPreferencesLinuxOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\lib\shared_preferences_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Linux implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
class SharedPreferencesLinux extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesLinux].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesLinux instance = SharedPreferencesLinux();

  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesLinux();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncLinux.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _reload(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Linux implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
base class SharedPreferencesAsyncLinux extends SharedPreferencesAsyncPlatform {
  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncLinux();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesLinuxOptions options,
  ) async {
    _cachedPreferences = await _reload(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs =
        Map<String, Object>.from(await _readPreferences(linuxOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _reload(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderLinux();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file and saves them in cache.
Future<Map<String, Object>> _reload(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Linux specific SharedPreferences Options.
class SharedPreferencesLinuxOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesLinuxOptions.
  const SharedPreferencesLinuxOptions({
    this.fileName = 'shared_preferences',
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesLinuxOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesLinuxOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesLinuxOptions) {
      return options;
    }
    return const SharedPreferencesLinuxOptions();
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\fake_path_provider_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// Fake implementation of PathProviderLinux that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Linux.
class FakePathProviderLinux extends PathProviderPlatform
    implements PathProviderLinux {
  @override
  Future<String?> getApplicationSupportPath() async => r'/appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\legacy_shared_preferences_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesLinux.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesLinux getPreferences() {
    final SharedPreferencesLinux prefs = SharedPreferencesLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesLinux.registerWith();
    expect(
        SharedPreferencesStorePlatform.instance, isA<SharedPreferencesLinux>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> someValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(someValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\shared_preferences_linux\test\shared_preferences_linux_async_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesAsyncLinux.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesLinuxOptions emptyOptions =
      SharedPreferencesLinuxOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  SharedPreferencesAsyncLinux getPreferences() {
    final SharedPreferencesAsyncLinux prefs = SharedPreferencesAsyncLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\example\integration_test\url_launcher_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('canLaunch', (WidgetTester _) async {
    final UrlLauncherPlatform launcher = UrlLauncherPlatform.instance;

    expect(await launcher.canLaunch('randomstring'), false);

    // Generally all devices should have some default browser.
    expect(await launcher.canLaunch('http://flutter.dev'), true);
  });
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  Future<void>? _launched;

  Future<void> _launchInBrowser(String url) async {
    if (await UrlLauncherPlatform.instance.canLaunch(url)) {
      await UrlLauncherPlatform.instance.launch(
        url,
        useSafariVC: false,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: <String, String>{},
      );
    } else {
      throw Exception('Could not launch $url');
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  @override
  Widget build(BuildContext context) {
    const String toLaunch = 'https://www.cylog.org/headers/';
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(toLaunch),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\lib\src\messages.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class UrlLauncherApi {
  /// Constructor for [UrlLauncherApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UrlLauncherApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Returns true if the URL can definitely be launched.
  Future<bool> canLaunchUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.url_launcher_linux.UrlLauncherApi.canLaunchUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Opens the URL externally, returning an error string on failure.
  Future<String?> launchUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.url_launcher_linux.UrlLauncherApi.launchUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\lib\url_launcher_linux.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [UrlLauncherPlatform] for Linux.
class UrlLauncherLinux extends UrlLauncherPlatform {
  /// Creates a new URL launcher instance.
  UrlLauncherLinux({@visibleForTesting UrlLauncherApi? api})
      : _hostApi = api ?? UrlLauncherApi();

  /// Registers this class as the default instance of [UrlLauncherPlatform].
  static void registerWith() {
    UrlLauncherPlatform.instance = UrlLauncherLinux();
  }

  final UrlLauncherApi _hostApi;

  @override
  final LinkDelegate? linkDelegate = null;

  @override
  Future<bool> canLaunch(String url) async {
    return _hostApi.canLaunchUrl(url);
  }

  @override
  Future<bool> launch(
    String url, {
    required bool useSafariVC,
    required bool useWebView,
    required bool enableJavaScript,
    required bool enableDomStorage,
    required bool universalLinksOnly,
    required Map<String, String> headers,
    String? webOnlyWindowName,
  }) {
    // None of the options are supported, so they don't need to be converted to
    // LaunchOptions.
    return launchUrl(url, const LaunchOptions());
  }

  @override
  Future<bool> launchUrl(String url, LaunchOptions options) async {
    final String? error = await _hostApi.launchUrl(url);
    if (error != null) {
      // TODO(stuartmorgan): Standardize errors across the entire plugin,
      // instead of using PlatformException. This preserves the pre-Pigeon
      // behavior of the C code returning this error response.
      throw PlatformException(
          code: 'Launch Error', message: 'Failed to launch URL: $error');
    }
    return true;
  }

  @override
  Future<bool> supportsMode(PreferredLaunchMode mode) async {
    return mode == PreferredLaunchMode.platformDefault ||
        mode == PreferredLaunchMode.externalApplication;
  }

  @override
  Future<bool> supportsCloseForMode(PreferredLaunchMode mode) async {
    // No supported mode is closeable.
    return false;
  }
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\pigeons\messages.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  gobjectHeaderOut: 'linux/messages.g.h',
  gobjectSourceOut: 'linux/messages.g.cc',
  gobjectOptions: GObjectOptions(module: 'Ful'),
  copyrightHeader: 'pigeons/copyright.txt',
))
@HostApi()
abstract class UrlLauncherApi {
  /// Returns true if the URL can definitely be launched.
  bool canLaunchUrl(String url);

  /// Opens the URL externally, returning an error string on failure.
  String? launchUrl(String url);
}
===== C:\flutter_apps\im_legends\linux\flutter\ephemeral\.plugin_symlinks\url_launcher_linux\test\url_launcher_linux_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:url_launcher_linux/src/messages.g.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  group('UrlLauncherLinux', () {
    test('registers instance', () {
      UrlLauncherLinux.registerWith();
      expect(UrlLauncherPlatform.instance, isA<UrlLauncherLinux>());
    });

    test('canLaunch passes true', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      final bool canLaunch = await launcher.canLaunch('http://example.com/');

      expect(canLaunch, true);
    });

    test('canLaunch passes false', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(canLaunch: false);
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      final bool canLaunch = await launcher.canLaunch('http://example.com/');

      expect(canLaunch, false);
    });

    test('launch', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);
      const String url = 'http://example.com/';

      final bool launched = await launcher.launch(
        url,
        useSafariVC: true,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: const <String, String>{},
      );

      expect(launched, true);
      expect(api.argument, url);
    });

    test('launch should throw if platform returns an error', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(error: 'An error');
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      await expectLater(
          launcher.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          throwsA(isA<PlatformException>()
              .having((PlatformException e) => e.code, 'code', 'Launch Error')
              .having((PlatformException e) => e.message, 'message',
                  contains('Failed to launch URL: An error'))));
    });

    group('launchUrl', () {
      test('passes URL', () async {
        final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
        final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);
        const String url = 'http://example.com/';

        final bool launched =
            await launcher.launchUrl(url, const LaunchOptions());

        expect(launched, true);
        expect(api.argument, url);
      });

      test('throws if platform returns an error', () async {
        final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(error: 'An error');
        final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

        await expectLater(
            launcher.launchUrl('http://example.com/', const LaunchOptions()),
            throwsA(isA<PlatformException>()
                .having((PlatformException e) => e.code, 'code', 'Launch Error')
                .having((PlatformException e) => e.message, 'message',
                    contains('Failed to launch URL: An error'))));
      });
    });

    group('supportsMode', () {
      test('returns true for platformDefault', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(await launcher.supportsMode(PreferredLaunchMode.platformDefault),
            true);
      });

      test('returns true for external application', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(
            await launcher
                .supportsMode(PreferredLaunchMode.externalApplication),
            true);
      });

      test('returns false for other modes', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(
            await launcher.supportsMode(
                PreferredLaunchMode.externalNonBrowserApplication),
            false);
        expect(
            await launcher.supportsMode(PreferredLaunchMode.inAppBrowserView),
            false);
        expect(await launcher.supportsMode(PreferredLaunchMode.inAppWebView),
            false);
      });
    });

    test('supportsCloseForMode returns false', () async {
      final UrlLauncherLinux launcher = UrlLauncherLinux();
      expect(
          await launcher
              .supportsCloseForMode(PreferredLaunchMode.platformDefault),
          false);
      expect(
          await launcher
              .supportsCloseForMode(PreferredLaunchMode.externalApplication),
          false);
    });
  });
}

class _FakeUrlLauncherApi implements UrlLauncherApi {
  _FakeUrlLauncherApi({this.canLaunch = true, this.error});

  /// The value to return from canLaunch.
  final bool canLaunch;

  /// The error to return from launchUrl, if any.
  final String? error;

  /// The argument that was passed to an API call.
  String? argument;

  @override
  Future<bool> canLaunchUrl(String url) async {
    argument = url;
    return canLaunch;
  }

  @override
  Future<String?> launchUrl(String url) async {
    argument = url;
    return error;
  }

  @override
  // ignore: non_constant_identifier_names
  BinaryMessenger? get pigeonVar_binaryMessenger => null;

  @override
  // ignore: non_constant_identifier_names
  String get pigeonVar_messageChannelSuffix => '';
}
===== C:\flutter_apps\im_legends\test\widget_test.dart =====
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:im_legends/core/router/app_router.dart';
import 'package:im_legends/im_legends_app.dart';


void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(IMLegendsApp(router: router,));

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\example\lib\url_protocol\api.dart =====
import 'protocol.dart';
import 'windows_protocol.dart'
    if (dart.library.js_interop) 'web_url_protocol.dart';

/// Registers a protocol by [scheme] to allow for links in the form `<scheme>://...`
/// to be processed by this application. By default, opening a link will open
/// the executable that was used to register the scheme with the URL as the first
/// argument passed to the executable.
///
/// If a protocol is already registered for the given scheme, this function will
/// attempt to overwrite the previous handler with the current executable information.
/// However, note that depending on process permissions, this operation may be
/// disallowed by the underlying platform.
///
/// You may pass an [executable] to override the path to the executable to run
/// when accessing the URL.
///
/// [arguments] is a list of arguments to be used when running the executable.
/// If passed, the list must contain at least one element, and at least one of
/// those elements must contain the literal value `%s` to denote the URL to open.
/// Quoting arguments is not necessary, as this will be handled for you.
/// Escaping the `%s` as an unprocessed literal is currently unsupported.
void registerProtocolHandler(
  String scheme, {
  String? executable,
  List<String>? arguments,
}) {
  WindowsProtocolHandler().register(
    scheme,
    executable: executable,
    arguments: arguments,
  );
}

/// Unregisters the protocol handler with the underlying platform. The provided
/// [scheme] will no longer be used in links.
///
/// Note that this will unregister a protocol by scheme regardless of which process
/// had registered it. Unregistering a scheme that was not registered by this
/// application is undefined and depends on platform-specific restrictions.
void unregisterProtocolHandler(String scheme) {
  WindowsProtocolHandler().unregister(scheme);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\example\lib\url_protocol\protocol.dart =====
abstract class ProtocolHandler {
  void register(String scheme, {String? executable, List<String>? arguments});

  void unregister(String scheme);

  List<String> getArguments(List<String>? arguments) {
    if (arguments == null) return ['%s'];

    if (arguments.isEmpty && !arguments.any((e) => e.contains('%s'))) {
      throw ArgumentError('arguments must contain at least 1 instance of "%s"');
    }

    return arguments;
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\example\lib\url_protocol\web_url_protocol.dart =====
import './protocol.dart';

class WindowsProtocolHandler extends ProtocolHandler {
  @override
  void register(String scheme, {String? executable, List<String>? arguments}) {}

  @override
  void unregister(String scheme) {}
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\example\lib\url_protocol\windows_protocol.dart =====
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart';
import 'package:win32/win32.dart';

import './protocol.dart';

const _hive = HKEY_CURRENT_USER;

class WindowsProtocolHandler extends ProtocolHandler {
  @override
  void register(String scheme, {String? executable, List<String>? arguments}) {
    if (defaultTargetPlatform != TargetPlatform.windows) return;

    final prefix = _regPrefix(scheme);
    final capitalized = scheme[0].toUpperCase() + scheme.substring(1);
    final args = getArguments(arguments).map((a) => _sanitize(a));
    final cmd =
        '${executable ?? Platform.resolvedExecutable} ${args.join(' ')}';

    _regCreateStringKey(_hive, prefix, '', 'URL:$capitalized');
    _regCreateStringKey(_hive, prefix, 'URL Protocol', '');
    _regCreateStringKey(_hive, '$prefix\\shell\\open\\command', '', cmd);
  }

  @override
  void unregister(String scheme) {
    if (defaultTargetPlatform != TargetPlatform.windows) return;

    final txtKey = TEXT(_regPrefix(scheme));
    try {
      RegDeleteTree(HKEY_CURRENT_USER, txtKey);
    } finally {
      free(txtKey);
    }
  }

  String _regPrefix(String scheme) => 'SOFTWARE\\Classes\\$scheme';

  int _regCreateStringKey(int hKey, String key, String valueName, String data) {
    final txtKey = TEXT(key);
    final txtValue = TEXT(valueName);
    final txtData = TEXT(data);
    try {
      return RegSetKeyValue(
        hKey,
        txtKey,
        txtValue,
        REG_SZ,
        txtData,
        txtData.length * 2 + 2,
      );
    } finally {
      free(txtKey);
      free(txtValue);
      free(txtData);
    }
  }

  String _sanitize(String value) {
    value = value.replaceAll(r'%s', '%1').replaceAll(r'"', '\\"');
    return '"$value"';
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\example\lib\main.dart =====
import 'dart:async';

import 'package:app_links/app_links.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'url_protocol/api.dart';

///////////////////////////////////////////////////////////////////////////////
/// Please make sure to follow the setup instructions below
///
/// Please take a look at:
/// - example/android/app/main/AndroidManifest.xml for Android.
///
/// - example/ios/Runner/Runner.entitlements for Universal Link sample.
/// - example/ios/Runner/Info.plist for Custom URL scheme sample.
///
/// Android launch:
///    adb shell am start -a android.intent.action.VIEW \
///     -d "sample://open.my.app/#/book/hello-world"
///
/// iOS launch:
///    /usr/bin/xcrun simctl openurl booted "app://www.example.com/#/book/hello-world"
///
///
/// Windows & macOS launch:
///   The simplest way to test it is by
///   opening your browser and type: sample://foo/#/book/hello-world2
///
/// On windows:
/// Outside of a browser, in a email for example, you can use:
/// https://example.com/#/book/hello-world2
///////////////////////////////////////////////////////////////////////////////

const kWindowsScheme = 'sample';

void main() {
  // Register our protocol only on Windows platform
  // registerProtocolHandler(kWindowsScheme);

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final _navigatorKey = GlobalKey<NavigatorState>();
  StreamSubscription<Uri>? _linkSubscription;

  @override
  void initState() {
    super.initState();

    initDeepLinks();
  }

  @override
  void dispose() {
    _linkSubscription?.cancel();

    super.dispose();
  }

  Future<void> initDeepLinks() async {
    // Handle links
    _linkSubscription = AppLinks().uriLinkStream.listen((uri) {
      debugPrint('onAppLink: $uri');
      openAppLink(uri);
    });
  }

  void openAppLink(Uri uri) {
    _navigatorKey.currentState?.pushNamed(uri.fragment);
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: _navigatorKey,
      initialRoute: "/",
      onGenerateRoute: (RouteSettings settings) {
        Widget routeWidget = defaultScreen();

        // Mimic web routing
        final routeName = settings.name;
        if (routeName != null) {
          if (routeName.startsWith('/book/')) {
            // Navigated to /book/:id
            routeWidget = customScreen(
              routeName.substring(routeName.indexOf('/book/')),
            );
          } else if (routeName == '/book') {
            // Navigated to /book without other parameters
            routeWidget = customScreen("None");
          }
        }

        return MaterialPageRoute(
          builder: (context) => routeWidget,
          settings: settings,
          fullscreenDialog: true,
        );
      },
    );
  }

  Widget defaultScreen() {
    return Scaffold(
      appBar: AppBar(title: const Text('Default Screen')),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const SelectableText('''
            Launch an intent to get to the second screen.

            On web:
            http://localhost:<port>/#/book/1 for example.

            On windows & macOS, open your browser:
            sample://foo/#/book/hello-deep-linking

            This example code triggers new page from URL fragment.
            '''),
            const SizedBox(height: 20),
            buildWindowsUnregisterBtn(),
          ],
        ),
      ),
    );
  }

  Widget customScreen(String bookId) {
    return Scaffold(
      appBar: AppBar(title: const Text('Second Screen')),
      body: Center(child: Text('Opened with parameter: $bookId')),
    );
  }

  Widget buildWindowsUnregisterBtn() {
    if (defaultTargetPlatform == TargetPlatform.windows) {
      return TextButton(
          onPressed: () => unregisterProtocolHandler(kWindowsScheme),
          child: const Text('Remove Windows protocol registration'));
    }

    return const SizedBox.shrink();
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\lib\src\app_links.dart =====
import 'dart:async';
import 'package:app_links_platform_interface/app_links_platform_interface.dart';

/// App links handler.
///
/// This class is a singleton and should be accessed using `AppLinks()`.
class AppLinks extends AppLinksPlatform {
  static final AppLinks _instance = AppLinks._();

  factory AppLinks() => _instance;

  AppLinks._();

  StreamController<String>? _stringStreamController;
  StreamController<Uri>? _uriStreamController;

  @override
  Future<Uri?> getInitialLink() {
    return AppLinksPlatform.instance.getInitialLink();
  }

  @override
  Future<String?> getInitialLinkString() {
    return AppLinksPlatform.instance.getInitialLinkString();
  }

  @override
  Future<Uri?> getLatestLink() {
    return AppLinksPlatform.instance.getLatestLink();
  }

  @override
  Future<String?> getLatestLinkString() {
    return AppLinksPlatform.instance.getLatestLinkString();
  }

  @override
  Stream<String> get stringLinkStream {
    if (_stringStreamController == null) {
      _stringStreamController = StreamController.broadcast();

      _initController<String>(
        _stringStreamController!,
        AppLinksPlatform.instance.stringLinkStream,
        onCancel: () => _stringStreamController = null,
      );
    }

    return _stringStreamController!.stream;
  }

  @override
  Stream<Uri> get uriLinkStream {
    if (_uriStreamController == null) {
      _uriStreamController = StreamController.broadcast();

      _initController<Uri>(
        _uriStreamController!,
        AppLinksPlatform.instance.uriLinkStream,
        onCancel: () => _uriStreamController = null,
      );
    }

    return _uriStreamController!.stream;
  }

  void _initController<T>(
    StreamController<T> controller,
    Stream<T> stream, {
    required void Function() onCancel,
  }) {
    final subscription = stream.listen(
      controller.add,
      onError: controller.addError,
    );

    // Broadcast controller doesn't support pause/resume
    //
    // Forward cancel event when there's no more listeners
    // and dispose controller
    controller.onCancel = () async {
      await subscription.cancel();
      await controller.close();
      onCancel();
    };
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\app_links\lib\app_links.dart =====
export 'src/app_links.dart';
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\get_directory_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a directory using `getDirectoryPath`,
///  then displays the selected directory in a dialog.
class GetDirectoryPage extends StatelessWidget {
  /// Default Constructor
  const GetDirectoryPage({super.key});

  Future<void> _getDirectoryPath(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final String? directoryPath =
        await FileSelectorPlatform.instance.getDirectoryPath(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPath == null) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(directoryPath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to ask user to choose a directory'),
              onPressed: () => _getDirectoryPath(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPath, {super.key});

  /// The path selected in the dialog.
  final String directoryPath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directory'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPath),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\get_multiple_directories_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select one or more directories using `getDirectoryPaths`,
/// then displays the selected directories in a dialog.
class GetMultipleDirectoriesPage extends StatelessWidget {
  /// Default Constructor
  const GetMultipleDirectoriesPage({super.key});

  Future<void> _getDirectoryPaths(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final List<String?> directoriesPaths =
        await FileSelectorPlatform.instance.getDirectoryPaths(
      confirmButtonText: confirmButtonText,
    );
    if (directoriesPaths.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) =>
            TextDisplay(directoriesPaths.join('\n')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select multiple directories'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text(
                  'Press to ask user to choose multiple directories'),
              onPressed: () => _getDirectoryPaths(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPaths, {super.key});

  /// The paths selected in the dialog.
  final String directoryPaths;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directories'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPaths),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\home_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Home Page of the application.
class HomePage extends StatelessWidget {
  /// Default Constructor
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final ButtonStyle style = ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('File Selector Demo Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: style,
              child: const Text('Open a text file'),
              onPressed: () => Navigator.pushNamed(context, '/open/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open an image'),
              onPressed: () => Navigator.pushNamed(context, '/open/image'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open multiple images'),
              onPressed: () => Navigator.pushNamed(context, '/open/images'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Save a file'),
              onPressed: () => Navigator.pushNamed(context, '/save/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directory dialog'),
              onPressed: () => Navigator.pushNamed(context, '/directory'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directories dialog'),
              onPressed: () =>
                  Navigator.pushNamed(context, '/multi-directories'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

import 'get_directory_page.dart';
import 'get_multiple_directories_page.dart';
import 'home_page.dart';
import 'open_image_page.dart';
import 'open_multiple_images_page.dart';
import 'open_text_page.dart';
import 'save_text_page.dart';

void main() {
  runApp(const MyApp());
}

/// MyApp is the Main Application.
class MyApp extends StatelessWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'File Selector Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const HomePage(),
      routes: <String, WidgetBuilder>{
        '/open/image': (BuildContext context) => const OpenImagePage(),
        '/open/images': (BuildContext context) =>
            const OpenMultipleImagesPage(),
        '/open/text': (BuildContext context) => const OpenTextPage(),
        '/save/text': (BuildContext context) => SaveTextPage(),
        '/directory': (BuildContext context) => const GetDirectoryPage(),
        '/multi-directories': (BuildContext context) =>
            const GetMultipleDirectoriesPage()
      },
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\open_image_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select an image file using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenImagePage extends StatelessWidget {
  /// Default Constructor
  const OpenImagePage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'images',
      extensions: <String>['jpg', 'png'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String filePath = file.path;

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => ImageDisplay(fileName, filePath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open an image'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open an image file(png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays an image in a dialog.
class ImageDisplay extends StatelessWidget {
  /// Default Constructor.
  const ImageDisplay(this.fileName, this.filePath, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The path to the selected file.
  final String filePath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: kIsWeb ? Image.network(filePath) : Image.file(File(filePath)),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\open_multiple_images_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select multiple image files using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenMultipleImagesPage extends StatelessWidget {
  /// Default Constructor
  const OpenMultipleImagesPage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup jpgsTypeGroup = XTypeGroup(
      label: 'JPEGs',
      extensions: <String>['jpg', 'jpeg'],
    );
    const XTypeGroup pngTypeGroup = XTypeGroup(
      label: 'PNGs',
      extensions: <String>['png'],
    );
    final List<XFile> files = await FileSelectorPlatform.instance
        .openFiles(acceptedTypeGroups: <XTypeGroup>[
      jpgsTypeGroup,
      pngTypeGroup,
    ]);
    if (files.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => MultipleImagesDisplay(files),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open multiple images'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open multiple images (png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class MultipleImagesDisplay extends StatelessWidget {
  /// Default Constructor.
  const MultipleImagesDisplay(this.files, {super.key});

  /// The files containing the images.
  final List<XFile> files;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Gallery'),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: Center(
        child: Row(
          children: <Widget>[
            ...files.map(
              (XFile file) => Flexible(
                  child: kIsWeb
                      ? Image.network(file.path)
                      : Image.file(File(file.path))),
            )
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\open_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a text file using `openFile`, then
/// displays its contents in a dialog.
class OpenTextPage extends StatelessWidget {
  /// Default Constructor
  const OpenTextPage({super.key});

  Future<void> _openTextFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'text',
      extensions: <String>['txt', 'json'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String fileContent = await file.readAsString();

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(fileName, fileContent),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open a text file (json, txt)'),
              onPressed: () => _openTextFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Default Constructor.
  const TextDisplay(this.fileName, this.fileContent, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The contents of the text file.
  final String fileContent;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(fileContent),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\example\lib\save_text_page.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'dart:typed_data';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a save location using `getSavePath`,
/// then writes text to a file at that location.
class SaveTextPage extends StatelessWidget {
  /// Default Constructor
  SaveTextPage({super.key});

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  Future<void> _saveFile() async {
    final String fileName = _nameController.text;
    final FileSaveLocation? result =
        await FileSelectorPlatform.instance.getSaveLocation(
      options: SaveDialogOptions(suggestedName: fileName),
      acceptedTypeGroups: const <XTypeGroup>[
        XTypeGroup(
          label: 'Plain text',
          extensions: <String>['txt'],
        ),
        XTypeGroup(
          label: 'JSON',
          extensions: <String>['json'],
        ),
      ],
    );
    // Operation was canceled by the user.
    if (result == null) {
      return;
    }
    String path = result.path;
    // Append an extension based on the selected type group if the user didn't
    // include one.
    if (!path.split(Platform.pathSeparator).last.contains('.')) {
      final XTypeGroup? activeGroup = result.activeFilter;
      if (activeGroup != null) {
        // The group is one of the groups passed in above, each of which has
        // exactly one `extensions` entry.
        path = '$path.${activeGroup.extensions!.first}';
      }
    }
    final String text = _contentController.text;
    final Uint8List fileData = Uint8List.fromList(text.codeUnits);
    final XFile textFile = XFile.fromData(fileData, name: fileName);
    await textFile.saveTo(result.path);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Save text into a file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: '(Optional) Suggest File Name',
                ),
              ),
            ),
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _contentController,
                decoration: const InputDecoration(
                  hintText: 'Enter File Contents',
                ),
              ),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              onPressed: _saveFile,
              child: const Text('Press to save a text file'),
            ),
          ],
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\lib\src\messages.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

class TypeGroup {
  TypeGroup({
    required this.label,
    required this.extensions,
  });

  String label;

  List<String> extensions;

  Object encode() {
    return <Object?>[
      label,
      extensions,
    ];
  }

  static TypeGroup decode(Object result) {
    result as List<Object?>;
    return TypeGroup(
      label: result[0]! as String,
      extensions: (result[1] as List<Object?>?)!.cast<String>(),
    );
  }
}

class SelectionOptions {
  SelectionOptions({
    this.allowMultiple = false,
    this.selectFolders = false,
    this.allowedTypes = const <TypeGroup>[],
  });

  bool allowMultiple;

  bool selectFolders;

  List<TypeGroup> allowedTypes;

  Object encode() {
    return <Object?>[
      allowMultiple,
      selectFolders,
      allowedTypes,
    ];
  }

  static SelectionOptions decode(Object result) {
    result as List<Object?>;
    return SelectionOptions(
      allowMultiple: result[0]! as bool,
      selectFolders: result[1]! as bool,
      allowedTypes: (result[2] as List<Object?>?)!.cast<TypeGroup>(),
    );
  }
}

/// The result from an open or save dialog.
class FileDialogResult {
  FileDialogResult({
    required this.paths,
    this.typeGroupIndex,
  });

  /// The selected paths.
  ///
  /// Empty if the dialog was canceled.
  List<String> paths;

  /// The type group index (into the list provided in [SelectionOptions]) of
  /// the group that was selected when the dialog was confirmed.
  ///
  /// Null if no type groups were provided, or the dialog was canceled.
  int? typeGroupIndex;

  Object encode() {
    return <Object?>[
      paths,
      typeGroupIndex,
    ];
  }

  static FileDialogResult decode(Object result) {
    result as List<Object?>;
    return FileDialogResult(
      paths: (result[0] as List<Object?>?)!.cast<String>(),
      typeGroupIndex: result[1] as int?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is TypeGroup) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is SelectionOptions) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is FileDialogResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        return TypeGroup.decode(readValue(buffer)!);
      case 130:
        return SelectionOptions.decode(readValue(buffer)!);
      case 131:
        return FileDialogResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileSelectorApi {
  /// Constructor for [FileSelectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileSelectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<FileDialogResult> showOpenDialog(SelectionOptions options,
      String? initialDirectory, String? confirmButtonText) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[options, initialDirectory, confirmButtonText])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FileDialogResult?)!;
    }
  }

  Future<FileDialogResult> showSaveDialog(
      SelectionOptions options,
      String? initialDirectory,
      String? suggestedName,
      String? confirmButtonText) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[
      options,
      initialDirectory,
      suggestedName,
      confirmButtonText
    ]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FileDialogResult?)!;
    }
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\lib\file_selector_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [FileSelectorPlatform] for Windows.
class FileSelectorWindows extends FileSelectorPlatform {
  final FileSelectorApi _hostApi = FileSelectorApi();

  /// Registers the Windows implementation.
  static void registerWith() {
    FileSelectorPlatform.instance = FileSelectorWindows();
  }

  @override
  Future<XFile?> openFile({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? null : XFile(result.paths.first);
  }

  @override
  Future<List<XFile>> openFiles({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowMultiple: true,
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.map((String? path) => XFile(path!)).toList();
  }

  @override
  Future<String?> getSavePath({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) async {
    final FileSaveLocation? location = await getSaveLocation(
        acceptedTypeGroups: acceptedTypeGroups,
        options: SaveDialogOptions(
          initialDirectory: initialDirectory,
          suggestedName: suggestedName,
          confirmButtonText: confirmButtonText,
        ));
    return location?.path;
  }

  @override
  Future<FileSaveLocation?> getSaveLocation({
    List<XTypeGroup>? acceptedTypeGroups,
    SaveDialogOptions options = const SaveDialogOptions(),
  }) async {
    final FileDialogResult result = await _hostApi.showSaveDialog(
        SelectionOptions(
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        options.initialDirectory,
        options.suggestedName,
        options.confirmButtonText);
    final int? groupIndex = result.typeGroupIndex;
    return result.paths.isEmpty
        ? null
        : FileSaveLocation(result.paths.first,
            activeFilter:
                groupIndex == null ? null : acceptedTypeGroups?[groupIndex]);
  }

  @override
  Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          selectFolders: true,
          allowedTypes: <TypeGroup>[],
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? null : result.paths.first;
  }

  @override
  Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowMultiple: true,
          selectFolders: true,
          allowedTypes: <TypeGroup>[],
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? <String>[] : List<String>.from(result.paths);
  }
}

List<TypeGroup> _typeGroupsFromXTypeGroups(List<XTypeGroup>? xtypes) {
  return (xtypes ?? <XTypeGroup>[]).map((XTypeGroup xtype) {
    if (!xtype.allowsAny && (xtype.extensions?.isEmpty ?? true)) {
      throw ArgumentError('Provided type group $xtype does not allow '
          'all files, but does not set any of the Windows-supported filter '
          'categories. "extensions" must be non-empty for Windows if '
          'anything is non-empty.');
    }
    return TypeGroup(
        label: xtype.label ?? '', extensions: xtype.extensions ?? <String>[]);
  }).toList();
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\pigeons\messages.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  dartTestOut: 'test/test_api.g.dart',
  cppOptions: CppOptions(namespace: 'file_selector_windows'),
  cppHeaderOut: 'windows/messages.g.h',
  cppSourceOut: 'windows/messages.g.cpp',
  copyrightHeader: 'pigeons/copyright.txt',
))
class TypeGroup {
  TypeGroup(this.label, {required this.extensions});

  String label;
  List<String> extensions;
}

class SelectionOptions {
  SelectionOptions({
    this.allowMultiple = false,
    this.selectFolders = false,
    this.allowedTypes = const <TypeGroup>[],
  });
  bool allowMultiple;
  bool selectFolders;
  List<TypeGroup> allowedTypes;
}

/// The result from an open or save dialog.
class FileDialogResult {
  FileDialogResult({required this.paths, this.typeGroupIndex});

  /// The selected paths.
  ///
  /// Empty if the dialog was canceled.
  List<String> paths;

  /// The type group index (into the list provided in [SelectionOptions]) of
  /// the group that was selected when the dialog was confirmed.
  ///
  /// Null if no type groups were provided, or the dialog was canceled.
  int? typeGroupIndex;
}

@HostApi(dartHostTestHandler: 'TestFileSelectorApi')
abstract class FileSelectorApi {
  FileDialogResult showOpenDialog(
    SelectionOptions options,
    String? initialDirectory,
    String? confirmButtonText,
  );
  FileDialogResult showSaveDialog(
    SelectionOptions options,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\test\file_selector_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:file_selector_windows/src/messages.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'file_selector_windows_test.mocks.dart';
import 'test_api.g.dart';

@GenerateMocks(<Type>[TestFileSelectorApi])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  final FileSelectorWindows plugin = FileSelectorWindows();
  late MockTestFileSelectorApi mockApi;

  setUp(() {
    mockApi = MockTestFileSelectorApi();
    TestFileSelectorApi.setUp(mockApi);
  });

  test('registered instance', () {
    FileSelectorWindows.registerWith();
    expect(FileSelectorPlatform.instance, isA<FileSelectorWindows>());
  });

  group('openFile', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final XFile? file = await plugin.openFile();

      expect(file!.path, 'foo');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.openFile(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.openFile(confirmButtonText: 'Open File');

      verify(mockApi.showOpenDialog(any, null, 'Open File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]), completes);
    });
  });

  group('openFiles', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo', 'bar']));
    });

    test('simple call works', () async {
      final List<XFile> file = await plugin.openFiles();

      expect(file[0].path, 'foo');
      expect(file[1].path, 'bar');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, true);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.openFiles(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.openFiles(confirmButtonText: 'Open Files');

      verify(mockApi.showOpenDialog(any, null, 'Open Files'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]), completes);
    });
  });

  group('getDirectoryPath', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final String? path = await plugin.getDirectoryPath();

      expect(path, 'foo');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getDirectoryPath(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getDirectoryPath(confirmButtonText: 'Open Directory');

      verify(mockApi.showOpenDialog(any, null, 'Open Directory'));
    });
  });

  group('getDirectoryPaths', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo', 'bar']));
    });

    test('simple call works', () async {
      final List<String> paths = await plugin.getDirectoryPaths();

      expect(paths[0], 'foo');
      expect(paths[1], 'bar');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, true);
      expect(options.selectFolders, true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getDirectoryPath(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getDirectoryPath(confirmButtonText: 'Open Directory');

      verify(mockApi.showOpenDialog(any, null, 'Open Directory'));
    });
  });

  group('getSaveLocation', () {
    setUp(() {
      when(mockApi.showSaveDialog(any, any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final FileSaveLocation? location = await plugin.getSaveLocation();

      expect(location?.path, 'foo');
      expect(location?.activeFilter, null);
      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('returns the selected type group correctly', () async {
      when(mockApi.showSaveDialog(any, any, any, any)).thenReturn(
          FileDialogResult(paths: <String>['foo'], typeGroupIndex: 1));
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      final FileSaveLocation? result = await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      verify(mockApi.showSaveDialog(captureAny, null, null, null));

      expect(result?.activeFilter, groupTwo);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getSaveLocation(
          options:
              const SaveDialogOptions(initialDirectory: '/example/directory'));

      verify(mockApi.showSaveDialog(any, '/example/directory', null, null));
    });

    test('passes suggestedName correctly', () async {
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(suggestedName: 'baz.txt'));

      verify(mockApi.showSaveDialog(any, null, 'baz.txt', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(confirmButtonText: 'Save File'));

      verify(mockApi.showSaveDialog(any, null, null, 'Save File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          completes);
    });
  });

  group('getSavePath (deprecated)', () {
    setUp(() {
      when(mockApi.showSaveDialog(any, any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final String? path = await plugin.getSavePath();

      expect(path, 'foo');
      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSavePath(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getSavePath(initialDirectory: '/example/directory');

      verify(mockApi.showSaveDialog(any, '/example/directory', null, null));
    });

    test('passes suggestedName correctly', () async {
      await plugin.getSavePath(suggestedName: 'baz.txt');

      verify(mockApi.showSaveDialog(any, null, 'baz.txt', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getSavePath(confirmButtonText: 'Save File');

      verify(mockApi.showSaveDialog(any, null, null, 'Save File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          completes);
    });
  });
}

// True if the given options match.
//
// This is needed because Pigeon data classes don't have custom equality checks,
// so only match for identical instances.
bool _typeGroupListsMatch(List<TypeGroup?> a, List<TypeGroup?> b) {
  if (a.length != b.length) {
    return false;
  }
  for (int i = 0; i < a.length; i++) {
    if (!_typeGroupsMatch(a[i], b[i])) {
      return false;
    }
  }
  return true;
}

// True if the given type groups match.
//
// This is needed because Pigeon data classes don't have custom equality checks,
// so only match for identical instances.
bool _typeGroupsMatch(TypeGroup? a, TypeGroup? b) {
  return a!.label == b!.label && listEquals(a.extensions, b.extensions);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\test\file_selector_windows_test.mocks.dart =====
// Mocks generated by Mockito 5.4.4 from annotations
// in file_selector_windows/test/file_selector_windows_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:file_selector_windows/src/messages.g.dart' as _i2;
import 'package:mockito/mockito.dart' as _i1;

import 'test_api.g.dart' as _i3;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeFileDialogResult_0 extends _i1.SmartFake
    implements _i2.FileDialogResult {
  _FakeFileDialogResult_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [TestFileSelectorApi].
///
/// See the documentation for Mockito's code generation for more information.
class MockTestFileSelectorApi extends _i1.Mock
    implements _i3.TestFileSelectorApi {
  MockTestFileSelectorApi() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.FileDialogResult showOpenDialog(
    _i2.SelectionOptions? options,
    String? initialDirectory,
    String? confirmButtonText,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #showOpenDialog,
          [
            options,
            initialDirectory,
            confirmButtonText,
          ],
        ),
        returnValue: _FakeFileDialogResult_0(
          this,
          Invocation.method(
            #showOpenDialog,
            [
              options,
              initialDirectory,
              confirmButtonText,
            ],
          ),
        ),
      ) as _i2.FileDialogResult);

  @override
  _i2.FileDialogResult showSaveDialog(
    _i2.SelectionOptions? options,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #showSaveDialog,
          [
            options,
            initialDirectory,
            suggestedName,
            confirmButtonText,
          ],
        ),
        returnValue: _FakeFileDialogResult_0(
          this,
          Invocation.method(
            #showSaveDialog,
            [
              options,
              initialDirectory,
              suggestedName,
              confirmButtonText,
            ],
          ),
        ),
      ) as _i2.FileDialogResult);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\file_selector_windows\test\test_api.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, unnecessary_import, no_leading_underscores_for_local_identifiers
// ignore_for_file: avoid_relative_lib_imports
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;
import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:file_selector_windows/src/messages.g.dart';

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is TypeGroup) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is SelectionOptions) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is FileDialogResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        return TypeGroup.decode(readValue(buffer)!);
      case 130:
        return SelectionOptions.decode(readValue(buffer)!);
      case 131:
        return FileDialogResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class TestFileSelectorApi {
  static TestDefaultBinaryMessengerBinding? get _testBinaryMessengerBinding =>
      TestDefaultBinaryMessengerBinding.instance;
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  FileDialogResult showOpenDialog(SelectionOptions options,
      String? initialDirectory, String? confirmButtonText);

  FileDialogResult showSaveDialog(
      SelectionOptions options,
      String? initialDirectory,
      String? suggestedName,
      String? confirmButtonText);

  static void setUp(
    TestFileSelectorApi? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel, null);
      } else {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel,
                (Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SelectionOptions? arg_options = (args[0] as SelectionOptions?);
          assert(arg_options != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog was null, expected non-null SelectionOptions.');
          final String? arg_initialDirectory = (args[1] as String?);
          final String? arg_confirmButtonText = (args[2] as String?);
          try {
            final FileDialogResult output = api.showOpenDialog(
                arg_options!, arg_initialDirectory, arg_confirmButtonText);
            return <Object?>[output];
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel, null);
      } else {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel,
                (Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SelectionOptions? arg_options = (args[0] as SelectionOptions?);
          assert(arg_options != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog was null, expected non-null SelectionOptions.');
          final String? arg_initialDirectory = (args[1] as String?);
          final String? arg_suggestedName = (args[2] as String?);
          final String? arg_confirmButtonText = (args[3] as String?);
          try {
            final FileDialogResult output = api.showSaveDialog(arg_options!,
                arg_initialDirectory, arg_suggestedName, arg_confirmButtonText);
            return <Object?>[output];
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\lib\firebase_options.dart =====
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      // TODO(Lyokone): Remove when FlutterFire CLI updated
      case TargetPlatform.windows:
        return android;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:0d4ed619c031c0ac3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\example\lib\main.dart =====
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  String get name => 'foo';

  Future<void> initializeDefault() async {
    FirebaseApp app = await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('Initialized default app $app');
  }

  Future<void> initializeDefaultFromAndroidResource() async {
    if (defaultTargetPlatform != TargetPlatform.android || kIsWeb) {
      print('Not running on Android, skipping');
      return;
    }
    FirebaseApp app = await Firebase.initializeApp();
    print('Initialized default app $app from Android resource');
  }

  Future<void> initializeSecondary() async {
    FirebaseApp app = await Firebase.initializeApp(
      name: name,
      options: DefaultFirebaseOptions.currentPlatform,
    );

    print('Initialized $app');
  }

  void apps() {
    final List<FirebaseApp> apps = Firebase.apps;
    print('Currently initialized apps: $apps');
  }

  void options() {
    final FirebaseApp app = Firebase.app();
    final options = app.options;
    print('Current options for app ${app.name}: $options');
  }

  Future<void> delete() async {
    final FirebaseApp app = Firebase.app(name);
    await app.delete();
    print('App $name deleted');
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Firebase Core example app'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              ElevatedButton(
                onPressed: initializeDefault,
                child: const Text('Initialize default app'),
              ),
              if (defaultTargetPlatform == TargetPlatform.android && !kIsWeb)
                ElevatedButton(
                  onPressed: initializeDefaultFromAndroidResource,
                  child: const Text(
                    'Initialize default app from Android resources',
                  ),
                ),
              ElevatedButton(
                onPressed: initializeSecondary,
                child: const Text('Initialize secondary app'),
              ),
              ElevatedButton(
                onPressed: apps,
                child: const Text('List apps'),
              ),
              ElevatedButton(
                onPressed: options,
                child: const Text('List default options'),
              ),
              ElevatedButton(
                onPressed: delete,
                child: const Text('Delete secondary app'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\src\firebase.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// The entry point for accessing Firebase.
class Firebase {
  // Ensures end-users cannot initialize the class.
  Firebase._();

  // Cached & lazily loaded instance of [FirebasePlatform].
  // Avoids a [MethodChannelFirebase] being initialized until the user
  // starts using Firebase.
  // The property is visible for testing to allow tests to set a mock
  // instance directly as a static property since the class is not initialized.
  @visibleForTesting
  // ignore: public_member_api_docs
  static FirebasePlatform? delegatePackingProperty;

  static FirebasePlatform get _delegate {
    return delegatePackingProperty ??= FirebasePlatform.instance;
  }

  /// Returns a list of all [FirebaseApp] instances that have been created.
  static List<FirebaseApp> get apps {
    return _delegate.apps.map(FirebaseApp._).toList(growable: false);
  }

  /// Initializes a new [FirebaseApp] instance by [name] and [options] and returns
  /// the created app. This method should be called before any usage of FlutterFire plugins.
  ///
  /// The default app instance can be initialized here simply by passing no "name" as an argument
  /// in both Dart & manual initialization flows.
  /// If you have a `google-services.json` file in your android project or a `GoogleService-Info.plist` file in your iOS+ project,
  /// it will automatically create a default (named "[DEFAULT]") app instance on the native platform. However, you will still need to call this method
  /// before using any FlutterFire plugins.
  static Future<FirebaseApp> initializeApp({
    String? name,
    FirebaseOptions? options,
    String? demoProjectId,
  }) async {
    if (demoProjectId != null) {
      late final String platformString;
      if (defaultTargetPlatform == TargetPlatform.android) {
        platformString = 'android';
      } else if (defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.macOS) {
        platformString = 'ios';
      } else {
        // We use 'web' as the default platform for unknown platforms.
        platformString = 'web';
      }
      FirebaseAppPlatform app = await _delegate.initializeApp(
        options: FirebaseOptions(
          apiKey: '',
          appId: '1:1:$platformString:1',
          messagingSenderId: '',
          projectId: demoProjectId,
        ),
      );

      return FirebaseApp._(app);
    }
    FirebaseAppPlatform app = await _delegate.initializeApp(
      name: name,
      options: options,
    );

    return FirebaseApp._(app);
  }

  /// Returns a [FirebaseApp] instance.
  ///
  /// If no name is provided, the default app instance is returned.
  /// Throws if the app does not exist.
  static FirebaseApp app([String name = defaultFirebaseAppName]) {
    FirebaseAppPlatform app = _delegate.app(name);

    return FirebaseApp._(app);
  }

  // TODO(rrousselGit): remove ==/hashCode
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Firebase) return false;
    return other.hashCode == hashCode;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => toString().hashCode;

  @override
  String toString() => '$Firebase';
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\src\firebase_app.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// Represents a single Firebase app instance.
///
/// You can get an instance by calling [Firebase.app()].
class FirebaseApp {
  /// A [FirebaseApp] instance can only be accessed from a call to `app()` on
  /// [FirebaseCore].
  ///
  /// This constructor ensures that the delegate instance it is
  /// constructed with is one which extends [FirebaseAppPlatform].
  FirebaseApp._(this._delegate) {
    FirebaseAppPlatform.verify(_delegate);
  }

  final FirebaseAppPlatform _delegate;

  /// Deletes this app and frees up system resources.
  ///
  /// Once deleted, any plugin functionality using this app instance will throw
  /// an error.
  ///
  /// Deleting the default app is not possible and throws an exception.
  Future<void> delete() async {
    await _delegate.delete();
  }

  /// The name of this [FirebaseApp].
  String get name => _delegate.name;

  /// The [FirebaseOptions] this app was created with.
  FirebaseOptions get options => _delegate.options;

  /// Returns whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// Automatic data collection can be enabled or disabled via `setAutomaticDataCollectionEnabled`.
  bool get isAutomaticDataCollectionEnabled =>
      _delegate.isAutomaticDataCollectionEnabled;

  /// Sets whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// To check whether it is currently enabled or not, call [isAutomaticDataCollectionEnabled].
  Future<void> setAutomaticDataCollectionEnabled(bool enabled) {
    return _delegate.setAutomaticDataCollectionEnabled(enabled);
  }

  /// Sets whether automatic resource management is enabled or disabled for this
  /// app.
  Future<void> setAutomaticResourceManagementEnabled(bool enabled) {
    return _delegate.setAutomaticResourceManagementEnabled(enabled);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! FirebaseApp) return false;
    return other.name == name && other.options == options;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hash(name, options);

  @override
  String toString() => '$FirebaseApp($name)';
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\src\port_mapping.dart =====
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../firebase_core.dart';

String getMappedHost(String originalHost) {
  String mappedHost = originalHost;

  if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
    if (mappedHost == 'localhost' || mappedHost == '127.0.0.1') {
      // ignore: avoid_print
      print('Mapping Auth Emulator host "$mappedHost" to "10.0.2.2".');
      mappedHost = '10.0.2.2';
    }
  }
  return mappedHost;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\lib\firebase_core.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    hide MethodChannelFirebaseApp, MethodChannelFirebase;
import 'package:flutter/foundation.dart';

export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseOptions, defaultFirebaseAppName, FirebaseException;

part 'src/firebase.dart';
part 'src/firebase_app.dart';
part 'src/port_mapping.dart';
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\firebase_core\test\firebase_core_test.dart =====
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  group('$FirebaseApp', () {
    final mock = MockFirebaseCore();

    const FirebaseOptions testOptions = FirebaseOptions(
      apiKey: 'apiKey',
      appId: 'appId',
      messagingSenderId: 'messagingSenderId',
      projectId: 'projectId',
    );

    String testAppName = 'testApp';

    setUp(() async {
      clearInteractions(mock);
      Firebase.delegatePackingProperty = mock;

      final FirebaseAppPlatform platformApp =
          FirebaseAppPlatform(testAppName, testOptions);

      when(mock.apps).thenReturn([platformApp]);
      when(mock.app(testAppName)).thenReturn(platformApp);
      when(mock.initializeApp(name: testAppName, options: testOptions))
          .thenAnswer((_) {
        return Future.value(platformApp);
      });
    });

    test('.apps', () {
      List<FirebaseApp> apps = Firebase.apps;
      verify(mock.apps);
      expect(apps[0], Firebase.app(testAppName));
    });

    test('.app()', () {
      FirebaseApp app = Firebase.app(testAppName);
      verify(mock.app(testAppName));

      expect(app.name, testAppName);
      expect(app.options, testOptions);
    });

    test('.initializeApp()', () async {
      FirebaseApp initializedApp =
          await Firebase.initializeApp(name: testAppName, options: testOptions);
      FirebaseApp app = Firebase.app(testAppName);

      expect(initializedApp, app);
      verifyInOrder([
        mock.initializeApp(name: testAppName, options: testOptions),
        mock.app(testAppName),
      ]);
    });
  });
}

class MockFirebaseCore extends Mock
    with
        // ignore: prefer_mixin, plugin_platform_interface needs to migrate to use `mixin`
        MockPlatformInterfaceMixin
    implements
        FirebasePlatform {
  @override
  FirebaseAppPlatform app([String name = defaultFirebaseAppName]) {
    return super.noSuchMethod(
      Invocation.method(#app, [name]),
      returnValue: FakeFirebaseAppPlatform(),
      returnValueForMissingStub: FakeFirebaseAppPlatform(),
    );
  }

  @override
  Future<FirebaseAppPlatform> initializeApp({
    String? name,
    FirebaseOptions? options,
  }) {
    return super.noSuchMethod(
      Invocation.method(
        #initializeApp,
        const [],
        {
          #name: name,
          #options: options,
        },
      ),
      returnValue: Future.value(FakeFirebaseAppPlatform()),
      returnValueForMissingStub: Future.value(FakeFirebaseAppPlatform()),
    );
  }

  @override
  List<FirebaseAppPlatform> get apps {
    return super.noSuchMethod(
      Invocation.getter(#apps),
      returnValue: <FirebaseAppPlatform>[],
      returnValueForMissingStub: <FirebaseAppPlatform>[],
    );
  }
}

// ignore: avoid_implementing_value_types
class FakeFirebaseAppPlatform extends Fake implements FirebaseAppPlatform {}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\action.dart =====
import 'package:xml/xml.dart';
import '../notification_action.dart';

/// Converts a [WindowsAction] to XML
extension ActionToXml on WindowsAction {
  /// Serializes this notification action as Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-action#syntax
  void buildXml(XmlBuilder builder) {
    builder.element(
      'action',
      attributes: <String, String>{
        'content': content,
        'arguments': arguments,
        'activationType': activationType.name,
        'afterActivationBehavior': activationBehavior.name,
        if (placement != null) 'placement': placement!.name,
        if (imageUri != null) 'imageUri': imageUri!.toString(),
        if (inputId != null) 'hint-inputId': inputId!,
        if (buttonStyle != null) 'hint-buttonStyle': buttonStyle!.name,
        if (tooltip != null) 'hint-toolTip': tooltip!,
      },
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\audio.dart =====
import 'package:xml/xml.dart';
import '../notification_audio.dart';

/// Converts a [WindowsNotificationAudio] to XML
extension AudioToXml on WindowsNotificationAudio {
  /// Serializes this audio to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-audio
  void buildXml(XmlBuilder builder) => builder.element(
        'audio',
        attributes: <String, String>{
          'src': source,
          'silent': isSilent.toString(),
          'loop': shouldLoop.toString(),
        },
      );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\details.dart =====
import 'package:xml/xml.dart';

import '../notification_action.dart';
import '../notification_details.dart';
import '../notification_input.dart';
import '../notification_progress.dart';
import '../notification_row.dart';

import 'action.dart';
import 'audio.dart';
import 'header.dart';
import 'image.dart';
import 'input.dart';
import 'progress.dart';
import 'row.dart';

extension on DateTime {
  String toIso8601StringTz() {
    // Get offset
    final Duration offset = timeZoneOffset;
    final String sign = offset.isNegative ? '-' : '+';
    final String hours = offset.inHours.abs().toString().padLeft(2, '0');
    final String minutes =
        offset.inMinutes.abs().remainder(60).toString().padLeft(2, '0');
    final String offsetString = '$sign$hours:$minutes';
    // Get first part of properly formatted ISO 8601 date
    final String formattedDate = toIso8601String().split('.').first;
    return '$formattedDate$offsetString';
  }
}

/// Converts a [WindowsNotificationDetails] to XML
extension DetailsToXml on WindowsNotificationDetails {
  /// Builds all relevant XML parts under the root `<toast>` element.
  void buildXml(XmlBuilder builder) {
    if (actions.length > 5) {
      throw ArgumentError(
        'WindowsNotificationDetails can only have up to 5 actions',
      );
    }
    if (inputs.length > 5) {
      throw ArgumentError(
        'WindowsNotificationDetails can only have up to 5 inputs',
      );
    }
    builder.element(
      'actions',
      nest: () {
        for (final WindowsInput input in inputs) {
          switch (input) {
            case WindowsTextInput():
              input.buildXml(builder);
            case WindowsSelectionInput():
              input.buildXml(builder);
          }
        }
        for (final WindowsAction action in actions) {
          action.buildXml(builder);
        }
      },
    );
    audio?.buildXml(builder);
    header?.buildXml(builder);
  }

  /// Generates the `<binding>` element of the notification.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-binding
  void generateBinding(XmlBuilder builder) {
    if (subtitle != null) {
      builder.element('text', nest: subtitle);
    }
    for (final WindowsImage image in images) {
      image.buildXml(builder);
    }
    for (final WindowsRow row in rows) {
      row.buildXml(builder);
    }
    for (final WindowsProgressBar progressBar in progressBars) {
      progressBar.buildXml(builder);
    }
  }

  /// XML attributes for the toast notification as a whole.
  Map<String, String> get attributes => <String, String>{
        if (duration != null) 'duration': duration!.name,
        if (timestamp != null)
          'displayTimestamp': timestamp!.toIso8601StringTz(),
        if (scenario != null) 'scenario': scenario!.name,
      };
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\header.dart =====
import 'package:xml/xml.dart';

import '../notification_header.dart';

/// Converts a [WindowsHeader] to XML
extension HeaderToXml on WindowsHeader {
  /// Serializes this header to XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-header
  void buildXml(XmlBuilder builder) => builder.element(
        'header',
        attributes: <String, String>{
          'id': id,
          'title': title,
          'arguments': arguments,
          if (activation != null) 'activationType': activation!.name,
        },
      );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\image.dart =====
import 'package:xml/xml.dart';

import '../notification_parts.dart';

/// Converts a [WindowsImage] to XML
extension ImageToXml on WindowsImage {
  /// Serializes this image to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-image
  void buildXml(XmlBuilder builder) {
    builder.element(
      'image',
      attributes: <String, String>{
        'src': uri.toString(),
        'alt': altText,
        'addImageQuery': addQueryParams.toString(),
        if (placement != null) 'placement': placement!.name,
        if (crop != null) 'hint-crop': crop!.name,
      },
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\input.dart =====
import 'package:xml/xml.dart';

import '../notification_input.dart';

/// Converts a [WindowsTextInput] to XML
extension TextInputToXml on WindowsTextInput {
  /// Serializes this input to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-input
  void buildXml(XmlBuilder builder) => builder.element(
        'input',
        attributes: <String, String>{
          'id': id,
          'type': type.name,
          if (title != null) 'title': title!,
          if (placeHolderContent != null)
            'placeHolderContent': placeHolderContent!,
        },
      );
}

/// Converts a [WindowsSelectionInput] to XML
extension SelectionInputToXml on WindowsSelectionInput {
  /// Serializes this input to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-input
  void buildXml(XmlBuilder builder) => builder.element(
        'input',
        attributes: <String, String>{
          'id': id,
          'type': type.name,
          if (title != null) 'title': title!,
          if (defaultItem != null) 'defaultInput': defaultItem!,
        },
        nest: () {
          for (final WindowsSelection item in items) {
            item.buildXml(builder);
          }
        },
      );
}

/// Converts a [WindowsSelection] to XML
extension SelectionToXml on WindowsSelection {
  /// Serializes this selection to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-selection
  void buildXml(XmlBuilder builder) => builder.element(
        'selection',
        attributes: <String, String>{
          'id': id,
          'content': content,
        },
      );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\progress.dart =====
import 'package:xml/xml.dart';

import '../notification_progress.dart';

/// Converts a [WindowsProgressBar] to XML
extension ProgressBarToXml on WindowsProgressBar {
  /// Serializes this progress bar to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-progress
  void buildXml(XmlBuilder builder) => builder.element(
        'progress',
        attributes: <String, String>{
          'status': status,
          'value': '{$id-progressValue}',
          if (title != null) 'title': title!,
          if (label != null) 'valueStringOverride': '{$id-progressString}',
        },
      );

  /// The data bindings for this progress bar.
  ///
  /// To support dynamic updates, [buildXml] will inject placeholder strings
  /// called data bindings instead of actual values. This can then be updated
  /// dynamically later by calling
  /// [FlutterLocalNotificationsWindows.updateProgressBar].
  Map<String, String> get data => <String, String>{
        '$id-progressValue': value?.toString() ?? 'indeterminate',
        if (label != null) '$id-progressString': label!,
      };
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\row.dart =====
import 'package:xml/xml.dart';

import '../notification_parts.dart';
import '../notification_row.dart';

import 'image.dart';
import 'text.dart';

/// Converts a [WindowsRow] to XML
extension RowToXml on WindowsRow {
  /// Serializes this group to XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-group
  void buildXml(XmlBuilder builder) => builder.element(
        'group',
        nest: () {
          for (final WindowsColumn column in columns) {
            builder.element(
              'subgroup',
              attributes: <String, String>{'hint-weight': '1'},
              nest: () {
                for (final WindowsNotificationPart part in column.parts) {
                  switch (part) {
                    case WindowsImage():
                      part.buildXml(builder);
                    case WindowsNotificationText():
                      part.buildXml(builder);
                  }
                }
              },
            );
          }
        },
      );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\xml\text.dart =====
import 'package:xml/xml.dart';

import '../notification_parts.dart';

/// Converts a [WindowsNotificationText] to XML
extension TextToXml on WindowsNotificationText {
  /// Serializes this text to Windows-compatible XML.
  ///
  /// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-text
  void buildXml(XmlBuilder builder) => builder.element(
        'text',
        attributes: <String, String>{
          if (languageCode != null) 'lang': languageCode!,
          if (placement != null) 'placement': placement!.name,
          'hint-callScenarioCenterAlign': centerIfCall.toString(),
          'hint-align': 'center',
          if (isCaption) 'hint-style': 'captionsubtle',
        },
        nest: text,
      );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\initialization_settings.dart =====
/// Plugin initialization settings for Windows.
class WindowsInitializationSettings {
  /// Creates a new settings object for initializing this plugin on Windows.
  const WindowsInitializationSettings({
    required this.appName,
    required this.appUserModelId,
    required this.guid,
    this.iconPath,
  });

  /// The name of the app that should be shown in the notification toast.
  final String appName;

  /// The unique app user model ID that identifies the app,
  /// in the form of CompanyName.ProductName.SubProduct.VersionInformation.
  ///
  /// See https://docs.microsoft.com/en-us/windows/win32/shell/appids
  /// for more information.
  final String appUserModelId;

  /// The GUID that identifies the notification activation callback.
  final String guid;

  /// The path to the icon of the notification.
  final String? iconPath;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_action.dart =====
import 'notification_parts.dart';

// NOTE: All enum values in this file have Windows RT-specific names.
// If you change their Dart names, be sure to override [Enum.name].

/// Decides how the [WindowsAction] will launch the app.
enum WindowsActivationType {
  /// The application will launch in the foreground (the default).
  foreground,

  /// Any application can be launched using its protocol.
  protocol,
}

/// Decides how a [WindowsAction] will react to being pressed.
enum WindowsNotificationBehavior {
  /// The notification will be dismissed.
  dismiss('default'),

  /// The notification will remain on screen and show a loading status.
  pendingUpdate('pendingUpdate');

  const WindowsNotificationBehavior(this.name);

  /// The Windows API name for this choice.
  final String name;
}

/// Decides how a [WindowsAction] will be styled.
enum WindowsButtonStyle {
  /// A green button.
  success('Success'),

  /// A red button.
  critical('Critical');

  const WindowsButtonStyle(this.name);

  /// The Windows API name for this choice.
  final String name;
}

/// Decides how a [WindowsAction] is placed on a notification.
enum WindowsActionPlacement {
  /// Instead of a separate button, the action is part of the context menu.
  contextMenu,
}

/// A button in a Windows notification.
///
/// See https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-action#attributes
class WindowsAction {
  /// Constructs a Windows notification button from parameters.
  const WindowsAction({
    required this.content,
    required this.arguments,
    this.activationType = WindowsActivationType.foreground,
    this.activationBehavior = WindowsNotificationBehavior.dismiss,
    this.placement,
    this.imageUri,
    this.inputId,
    this.buttonStyle,
    this.tooltip,
  });

  /// The body text of the button.
  final String content;

  /// An app-defined string that will be passed back if the button is pressed.
  final String arguments;

  /// How the application should open if the button is pressed.
  ///
  /// The default value is [WindowsActivationType.foreground].
  final WindowsActivationType activationType;

  /// How the notification should react when the button is pressed.
  ///
  /// The default value is [WindowsNotificationBehavior.dismiss].
  final WindowsNotificationBehavior activationBehavior;

  /// How the button should be placed on the notification.
  ///
  /// Null indicates a regular button.
  final WindowsActionPlacement? placement;

  /// An image to show on the button.
  ///
  /// Images must be white with a transparent background, and should be
  /// 16x16 pixels with no padding. If you provide an image for one button,
  /// you should provide images for all your buttons.
  ///
  /// Check the docs for [WindowsImage] for an explanation of supported URIs.
  final Uri? imageUri;

  /// The ID of an input box.
  ///
  /// If provided, this button will be placed next to the specified input.
  final String? inputId;

  /// The style of the button. Null indicates a plain button.
  final WindowsButtonStyle? buttonStyle;

  /// The tooltip, useful if [content] is empty.
  final String? tooltip;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_audio.dart =====
import '../../flutter_local_notifications_windows.dart';

/// A preset sound for a Windows notification.
enum WindowsNotificationSound {
  /// The default sound.
  defaultSound('ms-winsoundevent:Notification.Default'),

  /// The IM sound.
  im('ms-winsoundevent:Notification.IM'),

  /// The Mail sound.
  mail('ms-winsoundevent:Notification.Mail'),

  /// The Reminder sound.
  reminder('ms-winsoundevent:Notification.Reminder'),

  /// The SMS sound.
  sms('ms-winsoundevent:Notification.SMS'),

  /// Alarm sound 1.
  alarm1('ms-winsoundevent:Notification.Looping.Alarm1'),

  /// Alarm sound 2.
  alarm2('ms-winsoundevent:Notification.Looping.Alarm2'),

  /// Alarm sound 3.
  alarm3('ms-winsoundevent:Notification.Looping.Alarm3'),

  /// Alarm sound 4.
  alarm4('ms-winsoundevent:Notification.Looping.Alarm4'),

  /// Alarm sound 5.
  alarm5('ms-winsoundevent:Notification.Looping.Alarm5'),

  /// Alarm sound 6.
  alarm6('ms-winsoundevent:Notification.Looping.Alarm6'),

  /// Alarm sound 7.
  alarm7('ms-winsoundevent:Notification.Looping.Alarm7'),

  /// Alarm sound 8.
  alarm8('ms-winsoundevent:Notification.Looping.Alarm8'),

  /// Alarm sound 9.
  alarm9('ms-winsoundevent:Notification.Looping.Alarm9'),

  /// Alarm sound 10.
  alarm10('ms-winsoundevent:Notification.Looping.Alarm10'),

  /// Call sound 1.
  call1('ms-winsoundevent:Notification.Looping.Call1'),

  /// Call sound 2.
  call2('ms-winsoundevent:Notification.Looping.Call2'),

  /// Call sound 3.
  call3('ms-winsoundevent:Notification.Looping.Call3'),

  /// Call sound 4.
  call4('ms-winsoundevent:Notification.Looping.Call4'),

  /// Call sound 5.
  call5('ms-winsoundevent:Notification.Looping.Call5'),

  /// Call sound 6.
  call6('ms-winsoundevent:Notification.Looping.Call6'),

  /// Call sound 7.
  call7('ms-winsoundevent:Notification.Looping.Call7'),

  /// Call sound 8.
  call8('ms-winsoundevent:Notification.Looping.Call8'),

  /// Call sound 9.
  call9('ms-winsoundevent:Notification.Looping.Call9'),

  /// Call sound 10.
  call10('ms-winsoundevent:Notification.Looping.Call10');

  const WindowsNotificationSound(this.name);

  /// The Windows API name for this sound.
  final String name;
}

/// Specifies custom audio to play during a notification.
class WindowsNotificationAudio {
  /// No sound will play during this notification.
  WindowsNotificationAudio.silent()
      : source = WindowsNotificationSound.defaultSound.name,
        shouldLoop = false,
        isSilent = true;

  /// Audio from a Windows preset. See [WindowsNotificationSound] for options.
  WindowsNotificationAudio.preset({
    required WindowsNotificationSound sound,
    this.shouldLoop = false,
  })  : isSilent = false,
        source = sound.name;

  /// Uses an audio file from a Flutter asset.
  ///
  /// Note that this will only work in release builds that have been packaged as
  /// an MSIX installer. If you pass a [WindowsNotificationSound] for `fallback`
  /// it will be used in debug and releases without MSIX.
  ///
  /// Windows supports the following formats: `.aac`, `.flac`, `.m4a`, `.mp3`,
  /// `.wav`, and `.wma`.
  WindowsNotificationAudio.asset(
    String assetName, {
    this.shouldLoop = false,
    WindowsNotificationSound fallback = WindowsNotificationSound.defaultSound,
  })  : isSilent = false,
        source = MsixUtils.hasPackageIdentity()
            ? MsixUtils.getAssetUri(assetName).toString()
            : fallback.name;

  /// Whether this audio should loop.
  final bool shouldLoop;

  /// Whether this notification should be silent.
  final bool isSilent;

  /// The source of the audio.
  final String source;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_details.dart =====
import 'notification_action.dart';
import 'notification_audio.dart';
import 'notification_header.dart';
import 'notification_input.dart';
import 'notification_parts.dart';
import 'notification_progress.dart';
import 'notification_row.dart';

export 'notification_parts.dart';

/// The duration for a Windows notification.
enum WindowsNotificationDuration {
  /// The notification will stay for a long time.
  long,

  /// The notification will stay for a short time.
  short,
}

/// The scenario a notification is being used for.
enum WindowsNotificationScenario {
  /// Reminders are expanded and remain until manually dismissed.
  ///
  /// This will be ignored unless the notification also has at least one
  /// [WindowsAction] that activates a background task.
  reminder,

  /// Alarms are expanded and remain until manually dismissed.
  ///
  /// By default, alarm notifications loop the standard "alarm" sound.
  alarm,

  /// Calls are expanded and show in a special format.
  ///
  /// By default, call notifications loop the standard "call" sound.
  incomingCall,

  /// Urgent notifications can break through Do Not Disturb settings.
  urgent,
}

/// Contains notification details specific to Windows.
///
/// See: https://learn.microsoft.com/en-us/windows/apps/design/shell/tiles-and-notifications/adaptive-interactive-toasts
class WindowsNotificationDetails {
  /// Creates a Windows notification from the given options.
  const WindowsNotificationDetails({
    this.actions = const <WindowsAction>[],
    this.inputs = const <WindowsInput>[],
    this.images = const <WindowsImage>[],
    this.rows = const <WindowsRow>[],
    this.progressBars = const <WindowsProgressBar>[],
    this.bindings = const <String, String>{},
    this.header,
    this.audio,
    this.duration,
    this.scenario,
    this.timestamp,
    this.subtitle,
  });

  /// A list of at most five action buttons.
  final List<WindowsAction> actions;

  /// A list of at most five input elements.
  final List<WindowsInput> inputs;

  /// A custom audio to play during this notification.
  final WindowsNotificationAudio? audio;

  /// The duration for this notification.
  final WindowsNotificationDuration? duration;

  /// The scenario for this notification. Sets some defaults based on the value.
  final WindowsNotificationScenario? scenario;

  /// The header for this group of notifications.
  final WindowsHeader? header;

  /// Overrides the timestamp to show on the notification.
  final DateTime? timestamp;

  /// A third line to show under the notification body.
  final String? subtitle;

  /// A list of images to show.
  final List<WindowsImage> images;

  /// A list of rows to show.
  final List<WindowsRow> rows;

  /// A list of progress bars to show.
  final List<WindowsProgressBar> progressBars;

  /// Custom bindings in the notification.
  ///
  /// Text elements can contains "bindings", which are entered as
  /// `{bindingName}` directly into the string values. You can then update them
  /// while or after the notification is launched by using the binding name as
  /// the key here, and the value as any string you want.
  final Map<String, String> bindings;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_header.dart =====
/// Decides how the application will open when the header is pressed.
enum WindowsHeaderActivation {
  /// Opens the app in the foreground.
  foreground,

  /// Opens any app using a custom protocol.
  protocol,
}

/// A header that groups multiple Windows notifications.
class WindowsHeader {
  /// Creates a Windows header.
  const WindowsHeader({
    required this.id,
    required this.title,
    required this.arguments,
    this.activation,
  });

  /// A unique ID for this header.
  final String id;

  /// The title of the header.
  final String title;

  /// An application-defined payload that will be passed back when pressed.
  final String arguments;

  /// Specifies how the application will open.
  final WindowsHeaderActivation? activation;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_input.dart =====
/// The type of a [WindowsInput].
enum WindowsInputType {
  /// A text input.
  text,

  /// A multiple choice input.
  selection,
}

/// A text or multiple choice input element in a Windows notification.
sealed class WindowsInput {
  /// Creates an input field in a notification.
  const WindowsInput({
    required this.id,
    required this.type,
    this.title,
  });

  /// A unique ID for this input.
  ///
  /// Can be used by buttons to be placed next to this input.
  final String id;

  /// The type of this input.
  final WindowsInputType type;

  /// The title of this input.
  final String? title;
}

/// A text input.
class WindowsTextInput extends WindowsInput {
  /// Creates an input field in a notification.
  const WindowsTextInput({
    required super.id,
    this.placeHolderContent,
    super.title,
  }) : super(type: WindowsInputType.text);

  /// A placeholder shown before the user enters input, like a hint text.
  final String? placeHolderContent;
}

/// A multiple choice input.
class WindowsSelectionInput extends WindowsInput {
  /// Creates a selection input.
  const WindowsSelectionInput({
    required super.id,
    required this.items,
    this.defaultItem,
    super.title,
  }) : super(type: WindowsInputType.selection);

  /// The items that can be selected.
  final List<WindowsSelection> items;

  /// The default item that is selected.
  final String? defaultItem;
}

/// An option that can be selected by a [WindowsSelectionInput].
class WindowsSelection {
  /// Creates a selectable choice.
  const WindowsSelection({
    required this.id,
    required this.content,
  });

  /// A unique ID for this item.
  final String id;

  /// The content of this item in the UI.
  final String content;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_parts.dart =====
import 'dart:io';

import 'package:flutter/foundation.dart';
import '../../flutter_local_notifications_windows.dart';

/// A text or image element in a Windows notification.
///
/// Note: This should not be used for anything else as notification
/// groups can only contain text and images.
// This class needs to be abstract so [WindowsNotificationText] and
// [WindowsImage] can extend it. Specifically, this class is a marker
// type for classes that are valid as part of a [WindowsColumn].
// ignore: one_member_abstracts
sealed class WindowsNotificationPart {
  /// A const constructor.
  const WindowsNotificationPart();
}

/// Where a Windows notification image can be placed.
enum WindowsImagePlacement {
  /// The image replaces the app logo.
  appLogoOverride,

  /// The image is shown on top of the notification body.
  hero,
}

/// How a Windows notification image can be cropped.
enum WindowsImageCrop {
  /// The image is cropped into a circle.
  circle,
}

/// An image in a Windows notification.
///
/// Windows supports a few different URI types, and supports them differently
/// depending on if your app is packaged as an MSIX. Refer to the following:
///
/// | URI | Debug | Release (EXE) | Release (MSIX) |
/// |--------|--------|--------|--------|
/// | `http(s)://` | âŒ | âŒ | âœ… |
/// | `ms-appx://` | âŒ | âŒ | âœ… |
/// | `file:///`   | âœ… | âœ… | ðŸŸ¨ |
/// | `getAssetUri()` | âœ… | âœ… | âœ… |
///
/// Each URI type has different uses:
/// - For Flutter assets, use [getAssetUri], which return the correct file URI
/// for debug and release (exe) builds, and an `ms-appx` URI in MSIX builds.
/// - For images from the web, use an `https` or `http` URI, but note that
/// these only work in MSIX apps. If you need a network image without using
/// MSIX, consider downloading it directly and using a file URI after. Also
/// note that showing the notification will cause the image to be downloaded,
/// which could cause a small delay. Try to use small images.
/// - For images that come from the user's device, or have to be retrieved at
/// runtime, use a file URI, but as always, be aware of how paths might change
/// from your device to your users. Note that file URIs must be absolute
/// paths, not relative, which can be complicated if referring to MSIX assets.
/// - For images that are bundled with your app but not through Flutter, use
/// an `ms-appx` URI.
class WindowsImage extends WindowsNotificationPart {
  /// Creates a Windows notification image from an image URI.
  const WindowsImage(
    this.uri, {
    required this.altText,
    this.addQueryParams = false,
    this.placement,
    this.crop,
  });

  /// Returns a URI for a [Flutter asset](https://docs.flutter.dev/ui/assets/assets-and-images#loading-images).
  ///
  /// - In debug mode, resolves to a file URI to the asset itself
  /// - In non-MSIX release builds, resolves to a file URI to the bundled asset
  /// - In MSIX releases, resolves to an `ms-appx` URI from [Msix.getAssetUri].
  static Uri getAssetUri(String assetName) {
    if (kDebugMode) {
      return Uri.file(File(assetName).absolute.path, windows: true);
    } else if (MsixUtils.hasPackageIdentity()) {
      return MsixUtils.getAssetUri(assetName);
    } else {
      return Uri.file(
        File('data/flutter_assets/$assetName').absolute.path,
        windows: true,
      );
    }
  }

  /// Whether Windows should add URL query parameters when fetching the image.
  final bool addQueryParams;

  /// A description of the image to be used by assistive technology.
  final String altText;

  /// The source of the image.
  final Uri uri;

  /// Where this image will be placed. Null indicates below the notification.
  final WindowsImagePlacement? placement;

  /// How the image will be cropped. Null indicates uncropped.
  final WindowsImageCrop? crop;
}

/// Where text can be placed in a Windows notification.
enum WindowsTextPlacement {
  /// Shown at the bottom of the notification body in smaller text.
  attribution,
}

/// Text in a Windows notification.
///
/// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-text
class WindowsNotificationText extends WindowsNotificationPart {
  /// Creates text for a Windows notification.
  const WindowsNotificationText({
    required this.text,
    this.centerIfCall = false,
    this.isCaption = false,
    this.placement,
    this.languageCode,
  });

  /// The text being displayed.
  final String text;

  /// Whether to center this text. Only relevant if in an incoming call.
  final bool centerIfCall;

  /// Whether the text should be smaller like a caption.
  final bool isCaption;

  /// The placement of this text.
  ///
  /// The default placement (null) is in the main body of the notification.
  final WindowsTextPlacement? placement;

  /// The language of this text.
  final String? languageCode;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_progress.dart =====
import '../../flutter_local_notifications_windows.dart';

/// A progress bar in a Windows notification.
///
/// To update the progress after the notification has been shown,
/// use [FlutterLocalNotificationsWindows.updateProgressBar].
class WindowsProgressBar {
  /// Creates a progress bar for a Windows notification.
  WindowsProgressBar({
    required this.id,
    required this.status,
    required this.value,
    this.title,
    this.label,
  });

  /// A unique ID for this progress bar.
  final String id;

  /// An optional title.
  final String? title;

  /// Describes what's happening, like `Downloading...` or `Installing...`
  final String status;

  /// The value of the progress, from 0.0 to 1.0.
  ///
  /// Setting this to null indicates a indeterminate progress bar.
  double? value;

  /// Overrides the default reading as a percent with a different text.
  ///
  /// Useful for indicating discrete progress, like `3/10` instead of `30%`.
  String? label;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_row.dart =====
import 'notification_parts.dart';

/// A group of notification content that must be displayed as a whole row.
///
/// See: https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/element-group
class WindowsRow {
  /// Makes a group of multiple columns.
  const WindowsRow(this.columns);

  /// The different columns being grouped together.
  final List<WindowsColumn> columns;
}

/// A vertical column of text and images in a Windows notification.
class WindowsColumn {
  /// A const constructor.
  const WindowsColumn(this.parts);

  /// A list of text or images in this column.
  final List<WindowsNotificationPart> parts;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details\notification_to_xml.dart =====
import 'package:xml/xml.dart';

import '../../flutter_local_notifications_windows.dart';
import 'xml/details.dart';

export 'xml/progress.dart';

/// Converts a notification with [WindowsNotificationDetails] into XML.
///
/// For more details, refer to the [Toast Notification XML schema](https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/schema-root).
String notificationToXml({
  String? title,
  String? body,
  String? payload,
  WindowsNotificationDetails? details,
}) {
  final XmlBuilder builder = XmlBuilder();
  builder.element(
    'toast',
    attributes: <String, String>{
      ...details?.attributes ?? <String, String>{},
      if (payload != null) 'launch': payload,
      if (details?.scenario == null) 'useButtonStyle': 'true',
    },
    nest: () {
      builder.element(
        'visual',
        nest: () {
          builder.element(
            'binding',
            attributes: <String, String>{'template': 'ToastGeneric'},
            nest: () {
              builder
                ..element('text', nest: title)
                ..element('text', nest: body);
              details?.generateBinding(builder);
            },
          );
        },
      );
      details?.buildXml(builder);
    },
  );
  return builder
      .buildDocument()
      .toXmlString(pretty: true, indentAttribute: (_) => true);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\ffi\bindings.dart =====
// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for `src/ffi_api.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NotificationsPluginBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NotificationsPluginBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NotificationsPluginBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Checks whether the current application has package identity.
  ///
  /// This impacts whether apps can query active notifications or cancel them.
  /// For more details, see
  /// https://learn.microsoft.com/en-us/windows/apps/desktop/modernize/package-identity-overview.
  bool hasPackageIdentity() {
    return _hasPackageIdentity();
  }

  late final _hasPackageIdentityPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('hasPackageIdentity');
  late final _hasPackageIdentity =
      _hasPackageIdentityPtr.asFunction<bool Function()>();

  bool isValidXml(
    ffi.Pointer<pkg_ffi.Utf8> xml,
  ) {
    return _isValidXml(
      xml,
    );
  }

  late final _isValidXmlPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<pkg_ffi.Utf8>)>>(
          'isValidXml');
  late final _isValidXml =
      _isValidXmlPtr.asFunction<bool Function(ffi.Pointer<pkg_ffi.Utf8>)>();

  /// Allocates a new plugin that must be released with [disposePlugin].
  ffi.Pointer<NativePlugin> createPlugin() {
    return _createPlugin();
  }

  late final _createPluginPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NativePlugin> Function()>>(
          'createPlugin');
  late final _createPlugin =
      _createPluginPtr.asFunction<ffi.Pointer<NativePlugin> Function()>();

  /// Releases the plugin and any resources it was holding onto.
  void disposePlugin(
    ffi.Pointer<NativePlugin> ptr,
  ) {
    return _disposePlugin(
      ptr,
    );
  }

  late final _disposePluginPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NativePlugin>)>>(
          'disposePlugin');
  late final _disposePlugin =
      _disposePluginPtr.asFunction<void Function(ffi.Pointer<NativePlugin>)>();

  /// Initializes the plugin and registers the callback to be run when a notification is pressed.
  bool init(
    ffi.Pointer<NativePlugin> plugin,
    ffi.Pointer<pkg_ffi.Utf8> appName,
    ffi.Pointer<pkg_ffi.Utf8> aumId,
    ffi.Pointer<pkg_ffi.Utf8> guid,
    ffi.Pointer<pkg_ffi.Utf8> iconPath,
    NativeNotificationCallback callback,
  ) {
    return _init(
      plugin,
      appName,
      aumId,
      guid,
      iconPath,
      callback,
    );
  }

  late final _initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<NativePlugin>,
              ffi.Pointer<pkg_ffi.Utf8>,
              ffi.Pointer<pkg_ffi.Utf8>,
              ffi.Pointer<pkg_ffi.Utf8>,
              ffi.Pointer<pkg_ffi.Utf8>,
              NativeNotificationCallback)>>('init');
  late final _init = _initPtr.asFunction<
      bool Function(
          ffi.Pointer<NativePlugin>,
          ffi.Pointer<pkg_ffi.Utf8>,
          ffi.Pointer<pkg_ffi.Utf8>,
          ffi.Pointer<pkg_ffi.Utf8>,
          ffi.Pointer<pkg_ffi.Utf8>,
          NativeNotificationCallback)>();

  /// Shows the XML as a notification with the given ID. See [updateNotification] for details on
  /// bindings.
  bool showNotification(
    ffi.Pointer<NativePlugin> plugin,
    int id,
    ffi.Pointer<pkg_ffi.Utf8> xml,
    NativeStringMap bindings,
  ) {
    return _showNotification(
      plugin,
      id,
      xml,
      bindings,
    );
  }

  late final _showNotificationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<NativePlugin>, ffi.Int,
              ffi.Pointer<pkg_ffi.Utf8>, NativeStringMap)>>('showNotification');
  late final _showNotification = _showNotificationPtr.asFunction<
      bool Function(ffi.Pointer<NativePlugin>, int, ffi.Pointer<pkg_ffi.Utf8>,
          NativeStringMap)>();

  /// Schedules the notification to be shown at the given time (as a [time_t]).
  bool scheduleNotification(
    ffi.Pointer<NativePlugin> plugin,
    int id,
    ffi.Pointer<pkg_ffi.Utf8> xml,
    int time,
  ) {
    return _scheduleNotification(
      plugin,
      id,
      xml,
      time,
    );
  }

  late final _scheduleNotificationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<NativePlugin>, ffi.Int,
              ffi.Pointer<pkg_ffi.Utf8>, ffi.Int)>>('scheduleNotification');
  late final _scheduleNotification = _scheduleNotificationPtr.asFunction<
      bool Function(
          ffi.Pointer<NativePlugin>, int, ffi.Pointer<pkg_ffi.Utf8>, int)>();

  /// Updates a notification with the provided bindings after it's been shown.
  ///
  /// String values in the `<binding>` element of the XML can be placeholders instead of values,
  /// for example, `<text>{name}</text>` and then call this function with a map with a `name` key,
  /// and any string value, and the notification will be updated with that value where `name` was.
  NativeUpdateResult updateNotification(
    ffi.Pointer<NativePlugin> plugin,
    int id,
    NativeStringMap bindings,
  ) {
    return NativeUpdateResult.fromValue(_updateNotification(
      plugin,
      id,
      bindings,
    ));
  }

  late final _updateNotificationPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<NativePlugin>, ffi.Int,
              NativeStringMap)>>('updateNotification');
  late final _updateNotification = _updateNotificationPtr.asFunction<
      int Function(ffi.Pointer<NativePlugin>, int, NativeStringMap)>();

  /// Cancels all notifications.
  void cancelAll(
    ffi.Pointer<NativePlugin> plugin,
  ) {
    return _cancelAll(
      plugin,
    );
  }

  late final _cancelAllPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NativePlugin>)>>(
          'cancelAll');
  late final _cancelAll =
      _cancelAllPtr.asFunction<void Function(ffi.Pointer<NativePlugin>)>();

  /// Cancels a notification with the given ID.
  ///
  /// Only applications with "package identity" (ie, installed with an MSIX installer), can use this.
  void cancelNotification(
    ffi.Pointer<NativePlugin> plugin,
    int id,
  ) {
    return _cancelNotification(
      plugin,
      id,
    );
  }

  late final _cancelNotificationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NativePlugin>, ffi.Int)>>('cancelNotification');
  late final _cancelNotification = _cancelNotificationPtr
      .asFunction<void Function(ffi.Pointer<NativePlugin>, int)>();

  /// Gets all notifications that have already been shown but are still in the Action center.
  ///
  /// Only applications with "package identity" (ie, installed with an MSIX installer), can use this.
  /// When your app does not have identity, such as in debug mode, this will return an empty array.
  ffi.Pointer<NativeNotificationDetails> getActiveNotifications(
    ffi.Pointer<NativePlugin> plugin,
    ffi.Pointer<ffi.Int> size,
  ) {
    return _getActiveNotifications(
      plugin,
      size,
    );
  }

  late final _getActiveNotificationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NativeNotificationDetails> Function(
              ffi.Pointer<NativePlugin>,
              ffi.Pointer<ffi.Int>)>>('getActiveNotifications');
  late final _getActiveNotifications = _getActiveNotificationsPtr.asFunction<
      ffi.Pointer<NativeNotificationDetails> Function(
          ffi.Pointer<NativePlugin>, ffi.Pointer<ffi.Int>)>();

  /// Gets all notifications that have been scheduled but not yet shown.
  ffi.Pointer<NativeNotificationDetails> getPendingNotifications(
    ffi.Pointer<NativePlugin> plugin,
    ffi.Pointer<ffi.Int> size,
  ) {
    return _getPendingNotifications(
      plugin,
      size,
    );
  }

  late final _getPendingNotificationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NativeNotificationDetails> Function(
              ffi.Pointer<NativePlugin>,
              ffi.Pointer<ffi.Int>)>>('getPendingNotifications');
  late final _getPendingNotifications = _getPendingNotificationsPtr.asFunction<
      ffi.Pointer<NativeNotificationDetails> Function(
          ffi.Pointer<NativePlugin>, ffi.Pointer<ffi.Int>)>();

  /// Releases the memory associated with a [NativeNotificationDetails] array.
  void freeDetailsArray(
    ffi.Pointer<NativeNotificationDetails> ptr,
  ) {
    return _freeDetailsArray(
      ptr,
    );
  }

  late final _freeDetailsArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NativeNotificationDetails>)>>('freeDetailsArray');
  late final _freeDetailsArray = _freeDetailsArrayPtr
      .asFunction<void Function(ffi.Pointer<NativeNotificationDetails>)>();

  /// Releases the memory associated with a [NativeLaunchDetails].
  void freeLaunchDetails(
    NativeLaunchDetails details,
  ) {
    return _freeLaunchDetails(
      details,
    );
  }

  late final _freeLaunchDetailsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(NativeLaunchDetails)>>(
          'freeLaunchDetails');
  late final _freeLaunchDetails =
      _freeLaunchDetailsPtr.asFunction<void Function(NativeLaunchDetails)>();
}

final class NativePlugin extends ffi.Opaque {}

/// A key-value pair in a map where both the keys and values are strings.
final class StringMapEntry extends ffi.Struct {
  external ffi.Pointer<pkg_ffi.Utf8> key;

  external ffi.Pointer<pkg_ffi.Utf8> value;
}

/// A map where the keys and values are all strings.
final class NativeStringMap extends ffi.Struct {
  external ffi.Pointer<StringMapEntry> entries;

  @ffi.Int()
  external int size;
}

/// Details about a notification.
final class NativeNotificationDetails extends ffi.Struct {
  @ffi.Int()
  external int id;
}

/// How the app was launched, either by pressing on the notification or an action within it.
enum NativeLaunchType {
  notification(0),
  action(1);

  final int value;
  const NativeLaunchType(this.value);

  static NativeLaunchType fromValue(int value) => switch (value) {
        0 => notification,
        1 => action,
        _ => throw ArgumentError("Unknown value for NativeLaunchType: $value"),
      };
}

/// Details about how the app was launched.
final class NativeLaunchDetails extends ffi.Struct {
  /// Whether the app was launched by a notification
  @ffi.Bool()
  external bool didLaunch;

  /// What part of the notification launched the app.
  @ffi.UnsignedInt()
  external int launchType;

  /// The payload sent to the app by the notification. Usually the action that was pressed.
  external ffi.Pointer<pkg_ffi.Utf8> payload;

  /// The IDs and values of any text inputs in the notification.
  external NativeStringMap data;
}

/// See: https://learn.microsoft.com/en-us/uwp/api/windows.ui.notifications.notificationupdateresult
enum NativeUpdateResult {
  success(0),
  failed(1),
  notFound(2);

  final int value;
  const NativeUpdateResult(this.value);

  static NativeUpdateResult fromValue(int value) => switch (value) {
        0 => success,
        1 => failed,
        2 => notFound,
        _ =>
          throw ArgumentError("Unknown value for NativeUpdateResult: $value"),
      };
}

/// A callback that is run with [NativeLaunchDetails] when a notification is pressed.
///
/// This may be called at app launch or even while the app is running.
typedef NativeNotificationCallback
    = ffi.Pointer<ffi.NativeFunction<NativeNotificationCallbackFunction>>;
typedef NativeNotificationCallbackFunction = ffi.Void Function(
    NativeLaunchDetails details);
typedef DartNativeNotificationCallbackFunction = void Function(
    NativeLaunchDetails details);
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\ffi\utils.dart =====
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';

import '../details.dart';
import '../plugin/base.dart';
import 'bindings.dart';

/// Helpful methods on native string maps.
extension NativeStringMapUtils on NativeStringMap {
  /// Converts this map to a typical Dart map.
  Map<String, String> toMap() => <String, String>{
        for (int index = 0; index < size; index++)
          entries[index].key.toDartString():
              entries[index].value.toDartString(),
      };
}

/// Gets the [NotificationResponseType] from a [NativeLaunchType].
NotificationResponseType getResponseType(int launchType) {
  switch (NativeLaunchType.fromValue(launchType)) {
    case NativeLaunchType.notification:
      return NotificationResponseType.selectedNotification;
    case NativeLaunchType.action:
      return NotificationResponseType.selectedNotificationAction;
  }
}

/// Gets the [NotificationUpdateResult] from a [NativeUpdateResult].
NotificationUpdateResult getUpdateResult(NativeUpdateResult result) {
  switch (result) {
    case NativeUpdateResult.success:
      return NotificationUpdateResult.success;
    case NativeUpdateResult.failed:
      return NotificationUpdateResult.error;
    case NativeUpdateResult.notFound:
      return NotificationUpdateResult.notFound;
  }
}

/// Helpful methods on string maps.
extension MapToNativeMap on Map<String, String> {
  /// Allocates a [NativeStringMap] using the provided arena.
  NativeStringMap toNativeMap(Arena arena) {
    final Pointer<NativeStringMap> pointer = arena<NativeStringMap>();
    pointer.ref.size = length;
    pointer.ref.entries = arena<StringMapEntry>(length);
    int index = 0;
    for (final MapEntry<String, String> entry in entries) {
      pointer.ref.entries[index].key = entry.key.toNativeUtf8(allocator: arena);
      pointer.ref.entries[index].value =
          entry.value.toNativeUtf8(allocator: arena);
      index++;
    }
    return pointer.ref;
  }
}

/// Helpful methods on native notification details.
extension NativeNotificationDetailsUtils on Pointer<NativeNotificationDetails> {
  /// Parses this array as a list of [ActiveNotification]s.
  List<ActiveNotification> asActiveNotifications(int length) =>
      <ActiveNotification>[
        for (int index = 0; index < length; index++)
          ActiveNotification(id: this[index].id),
      ];

  /// Parses this array os a list of [PendingNotificationRequest]s.
  List<PendingNotificationRequest> asPendingRequests(int length) =>
      <PendingNotificationRequest>[
        for (int index = 0; index < length; index++)
          PendingNotificationRequest(this[index].id, null, null, null),
      ];
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\msix\ffi.dart =====
import 'dart:ffi';
import 'dart:io';

import '../../flutter_local_notifications_windows.dart';
import '../ffi/bindings.dart';

/// Helpful methods to support MSIX and package identity.
class MsixUtils {
  /// Returns whether the current app was installed with an MSIX installer.
  ///
  /// Using an MSIX grants your application [package identity](https://learn.microsoft.com/en-us/windows/apps/desktop/modernize/package-identity-overview),
  /// which allows it to use [certain APIs](https://learn.microsoft.com/en-us/windows/apps/desktop/modernize/modernize-packaged-apps).
  ///
  /// Specifically, using an MSIX installer allows your app to:
  /// - use [FlutterLocalNotificationsWindows.getActiveNotifications]
  /// - use [FlutterLocalNotificationsWindows.cancel]
  /// - use custom files for notification sounds
  /// - use network sources for notifications
  /// - use `ms-appx:///` URIs for resources
  ///
  /// These functions will simply do nothing or return empty data in apps
  /// without package identity. Additionally:
  /// - [WindowsImage.getAssetUri] will return a `file:///` or `ms-appx:///` URI,
  /// depending on whether the app is running in debug, release, or as an MSIX.
  /// - [WindowsNotificationAudio.asset] takes an audio file to use for apps
  /// with package identity, and a preset fallbacks for apps without.
  static bool hasPackageIdentity() {
    final bool? cached = _hasPackageIdentity;
    if (cached != null) {
      return cached;
    } else if (!Platform.isWindows) {
      return false;
    } else {
      final DynamicLibrary lib = DynamicLibrary.open(
        'flutter_local_notifications_windows.dll',
      );
      final NotificationsPluginBindings bindings =
          NotificationsPluginBindings(lib);
      final bool result = bindings.hasPackageIdentity();
      _hasPackageIdentity = result;
      return result;
    }
  }

  static bool? _hasPackageIdentity;

  /// Returns an `ms-appx:///` URI from a [Flutter asset](https://docs.flutter.dev/ui/assets/assets-and-images).
  static Uri getAssetUri(String path) =>
      Uri.parse('ms-appx:///data/flutter_assets/$path');
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\msix\stub.dart =====
import '../../flutter_local_notifications_windows.dart';

/// Helpful methods to support MSIX and package identity.
class MsixUtils {
  /// Returns whether the current app was installed with an MSIX installer.
  ///
  /// Using an MSIX grants your application [package identity](https://learn.microsoft.com/en-us/windows/apps/desktop/modernize/package-identity-overview),
  /// which allows it to use [certain APIs](https://learn.microsoft.com/en-us/windows/apps/desktop/modernize/modernize-packaged-apps).
  ///
  /// Specifically, using an MSIX installer allows your app to:
  /// - use [FlutterLocalNotificationsWindows.getActiveNotifications]
  /// - use [FlutterLocalNotificationsWindows.cancel]
  /// - use custom files for notification sounds
  /// - use network sources for notifications
  /// - use `ms-appx:///` URIs for resources
  ///
  /// These functions will simply do nothing or return empty data in apps
  /// without package identity. Additionally:
  /// - [WindowsImage.getAssetUri] will return a `file:///` or `ms-appx:///` URI,
  /// depending on whether the app is running in debug, release, or as an MSIX.
  /// - [WindowsNotificationAudio.asset] takes an audio file to use for apps
  /// with package identity, and a preset fallbacks for apps without.
  static bool hasPackageIdentity() => false; // platforms without FFI

  /// Gets an `ms-appx:///` URI from a [Flutter asset](https://docs.flutter.dev/ui/assets/assets-and-images).
  static Uri getAssetUri(String path) =>
      Uri.parse('ms-appx:///data/flutter_assets/$path');
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\plugin\base.dart =====
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';
import 'package:timezone/timezone.dart';

import '../details.dart';
import '../details/xml/progress.dart';

export 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';
export 'package:timezone/timezone.dart';

/// The Windows implementation of `package:flutter_local_notifications`.
abstract class WindowsNotificationsBase
    extends FlutterLocalNotificationsPlatform {
  /// Initializes the plugin. No other method should be called before this.
  Future<bool> initialize(
    WindowsInitializationSettings settings, {
    DidReceiveNotificationResponseCallback? onNotificationReceived,
  });

  /// Releases any resources used by this plugin.
  void dispose();

  /// Shows a notification using raw XML passed to the Windows APIs.
  ///
  /// To check if the XML is valid, use [isValidXml].
  Future<void> showRawXml({
    required int id,
    required String xml,
    Map<String, String> bindings = const <String, String>{},
  });

  @override
  Future<void> show(
    int id,
    String? title,
    String? body, {
    String? payload,
    WindowsNotificationDetails? details,
  });

  /// Schedules a notification to appear at the given date and time.
  Future<void> zonedSchedule(
    int id,
    String? title,
    String? body,
    TZDateTime scheduledDate,
    WindowsNotificationDetails? details, {
    String? payload,
  });

  /// Schedules a notification to appear using raw XML at this date and time.
  ///
  /// See https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/schema-root.
  /// For validation, see [the Windows Notifications Visualizer](https://learn.microsoft.com/en-us/windows/apps/design/shell/tiles-and-notifications/notifications-visualizer).
  Future<void> zonedScheduleRawXml(
    int id,
    String xml,
    TZDateTime scheduledDate,
    WindowsNotificationDetails? details,
  );

  /// Updates the progress bar in the notification with the given ID.
  ///
  /// Note that in order to update [WindowsProgressBar.label], it must
  /// not have been set to `null` when the notification was created
  Future<NotificationUpdateResult> updateProgressBar({
    required int notificationId,
    required WindowsProgressBar progressBar,
  }) =>
      updateBindings(
        id: notificationId,
        bindings: progressBar.data,
      );

  /// Updates any data binding in the given notification.
  ///
  /// Instead of a text value, you can replace any value in the `<binding>`
  /// element with `{name}`, and then use this function to update that value
  /// by passing `data: {'name': value}`.
  Future<NotificationUpdateResult> updateBindings({
    required int id,
    required Map<String, String> bindings,
  });

  /// Checks if some XML is a valid Windows notification.
  ///
  /// See https://learn.microsoft.com/en-us/uwp/schemas/tiles/toastschema/schema-root.
  /// For validation, see [the Windows Notifications Visualizer](https://learn.microsoft.com/en-us/windows/apps/design/shell/tiles-and-notifications/notifications-visualizer).
  bool isValidXml(String xml);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\plugin\ffi.dart =====
import 'dart:ffi';

import 'package:ffi/ffi.dart';

import '../details.dart';
import '../details/notification_to_xml.dart';
import '../ffi/bindings.dart';
import '../ffi/utils.dart';

import 'base.dart';

void _globalLaunchCallback(NativeLaunchDetails details) {
  FlutterLocalNotificationsWindows.instance?._onNotificationReceived(details);
}

extension on String {
  bool get isValidGuid =>
      length == 36 &&
      this[8] == '-' &&
      this[13] == '-' &&
      this[18] == '-' &&
      this[23] == '-';
}

/// The Windows implementation of `package:flutter_local_notifications`.
class FlutterLocalNotificationsWindows extends WindowsNotificationsBase {
  /// Creates an instance of the native plugin.
  FlutterLocalNotificationsWindows();

  /// Registers the Windows implementation with Flutter.
  static void registerWith() {
    FlutterLocalNotificationsPlatform.instance =
        FlutterLocalNotificationsWindows();
  }

  /// The global instance of this plugin. Used in [_globalLaunchCallback].
  static FlutterLocalNotificationsWindows? instance;

  /// The FFI generated bindings to the native code.
  late final NotificationsPluginBindings _bindings =
      NotificationsPluginBindings(_library);

  final DynamicLibrary _library =
      DynamicLibrary.open('flutter_local_notifications_windows.dll');

  /// A pointer to the C++ handler class.
  late final Pointer<NativePlugin> _plugin;

  bool _isReady = false;

  /// The last recorded launch details, if any.
  ///
  /// If the app is opened with a notification, this can be read with
  /// [getNotificationAppLaunchDetails]. If a notification is pressed while the
  /// app is running, this will be passed to [userCallback].
  NativeLaunchDetails? _details;

  /// A callback from [initialize] to run when a notification is pressed.
  DidReceiveNotificationResponseCallback? userCallback;

  @override
  Future<bool> initialize(
    WindowsInitializationSettings settings, {
    DidReceiveNotificationResponseCallback? onNotificationReceived,
  }) async =>
      using((Arena arena) {
        if (_isReady) {
          return true;
        }
        _plugin = _bindings.createPlugin();
        // The C++ code will crash if there's an invalid GUID, so check it here
        if (!settings.guid.isValidGuid) {
          throw ArgumentError.value(
            settings.guid,
            'GUID',
            'Invalid GUID. Please use xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
                ' format.\nYou can get one by searching GUID generators online',
          );
        }
        instance = this;
        userCallback = onNotificationReceived;
        final Pointer<Utf8> appName =
            settings.appName.toNativeUtf8(allocator: arena);
        final Pointer<Utf8> aumId =
            settings.appUserModelId.toNativeUtf8(allocator: arena);
        final Pointer<Utf8> guid = settings.guid.toNativeUtf8(allocator: arena);
        final Pointer<Utf8> iconPath =
            settings.iconPath?.toNativeUtf8(allocator: arena) ?? nullptr;
        final NativeNotificationCallback callback =
            NativeCallable<NativeNotificationCallbackFunction>.listener(
          _globalLaunchCallback,
        ).nativeFunction;
        final bool result =
            _bindings.init(_plugin, appName, aumId, guid, iconPath, callback);
        _isReady = result;
        return result;
      });

  @override
  void dispose() {
    if (!_isReady) {
      return;
    }
    _bindings.disposePlugin(_plugin);
    instance = null;
    _isReady = false;
  }

  void _onNotificationReceived(NativeLaunchDetails details) {
    if (!_isReady) {
      return;
    } else if (_details != null) {
      _bindings.freeLaunchDetails(_details!);
    }
    _details = details;
    final Map<String, String> data = details.data.toMap();
    final NotificationResponse response = NotificationResponse(
      notificationResponseType: getResponseType(details.launchType),
      payload: details.payload.toDartString(),
      actionId: details.payload.toDartString(),
      data: data,
    );
    userCallback?.call(response);
  }

  @override
  Future<void> cancel(int id) async {
    if (!_isReady) {
      throw StateError(
        'Flutter Local Notifications must be initialized before use',
      );
    }
    _bindings.cancelNotification(_plugin, id);
  }

  @override
  Future<void> cancelAll() async {
    if (!_isReady) {
      throw StateError(
        'Flutter Local Notifications must be initialized before use',
      );
    }
    _bindings.cancelAll(_plugin);
  }

  @override
  Future<List<ActiveNotification>> getActiveNotifications() async =>
      using((Arena arena) {
        if (!_isReady) {
          throw StateError(
            'Flutter Local Notifications must be initialized before use',
          );
        }
        final Pointer<Int> length = arena<Int>();
        final Pointer<NativeNotificationDetails> array =
            _bindings.getActiveNotifications(_plugin, length);
        final List<ActiveNotification> result =
            array.asActiveNotifications(length.value);
        _bindings.freeDetailsArray(array);
        return result;
      });

  @override
  Future<List<PendingNotificationRequest>>
      pendingNotificationRequests() async => using((Arena arena) {
            if (!_isReady) {
              throw StateError(
                'Flutter Local Notifications must be initialized before use',
              );
            }
            final Pointer<Int> length = arena<Int>();
            final Pointer<NativeNotificationDetails> array =
                _bindings.getPendingNotifications(_plugin, length);
            final List<PendingNotificationRequest> result =
                array.asPendingRequests(length.value);
            _bindings.freeDetailsArray(array);
            return result;
          });

  @override
  Future<NotificationAppLaunchDetails?>
      getNotificationAppLaunchDetails() async {
    if (!_isReady) {
      throw StateError(
        'Flutter Local Notifications must be initialized before use',
      );
    }
    final NativeLaunchDetails? details = _details;
    if (details == null) {
      return null;
    }
    final Map<String, String> data = details.data.toMap();
    return NotificationAppLaunchDetails(
      details.didLaunch,
      notificationResponse: NotificationResponse(
        notificationResponseType: getResponseType(details.launchType),
        payload: details.payload.toDartString(),
        actionId: details.payload.toDartString(),
        data: data,
      ),
    );
  }

  @override
  Future<void> periodicallyShow(
    int id,
    String? title,
    String? body,
    RepeatInterval repeatInterval,
  ) async {
    throw UnsupportedError(
      'Windows devices cannot periodically show notifications',
    );
  }

  @override
  Future<void> periodicallyShowWithDuration(
    int id,
    String? title,
    String? body,
    Duration repeatDurationInterval,
  ) async {
    throw UnsupportedError(
      'Windows devices cannot periodically show notifications',
    );
  }

  @override
  Future<void> show(int id, String? title, String? body,
          {String? payload, WindowsNotificationDetails? details}) async =>
      using((Arena arena) {
        if (!_isReady) {
          throw StateError(
            'Flutter Local Notifications must be initialized before use',
          );
        }
        final Map<String, String> bindings = <String, String>{
          if (details != null) ...details.bindings,
          for (final WindowsProgressBar progressBar
              in details?.progressBars ?? <WindowsProgressBar>[])
            ...progressBar.data,
        };
        final NativeStringMap nativeMap = bindings.toNativeMap(arena);
        final String xml = notificationToXml(
          title: title,
          body: body,
          payload: payload,
          details: details,
        );
        final bool result = _bindings.showNotification(
          _plugin,
          id,
          xml.toNativeUtf8(allocator: arena),
          nativeMap,
        );
        if (!result) {
          throw Exception(
            'Flutter Local Notifications could not show notification',
          );
        }
      });

  @override
  Future<void> showRawXml({
    required int id,
    required String xml,
    Map<String, String> bindings = const <String, String>{},
  }) async =>
      using((Arena arena) {
        if (!_isReady) {
          throw StateError(
            'Flutter Local Notifications must be initialized before use',
          );
        }
        final bool result = _bindings.showNotification(_plugin, id,
            xml.toNativeUtf8(allocator: arena), bindings.toNativeMap(arena));
        if (!result) {
          throw ArgumentError('Flutter Local Notifications: Invalid XML');
        }
      });

  @override
  bool isValidXml(String xml) => using((Arena arena) {
        final Pointer<Utf8> nativeXml = xml.toNativeUtf8(allocator: arena);
        return _bindings.isValidXml(nativeXml);
      });

  @override
  Future<void> zonedSchedule(
    int id,
    String? title,
    String? body,
    TZDateTime scheduledDate,
    WindowsNotificationDetails? details, {
    String? payload,
  }) async =>
      using((Arena arena) {
        if (!_isReady) {
          throw StateError(
            'Flutter Local Notifications must be initialized before use',
          );
        }
        if (scheduledDate.isBefore(DateTime.now())) {
          throw ArgumentError(
            'Flutter Local Notifications cannot'
            ' schedule notifications in the past',
          );
        }
        final String xml = notificationToXml(
          title: title,
          body: body,
          payload: payload,
          details: details,
        );
        final int secondsSinceEpoch =
            scheduledDate.millisecondsSinceEpoch ~/ 1000;
        _bindings.scheduleNotification(
          _plugin,
          id,
          xml.toNativeUtf8(allocator: arena),
          secondsSinceEpoch,
        );
      });

  @override
  Future<void> zonedScheduleRawXml(
    int id,
    String xml,
    TZDateTime scheduledDate,
    WindowsNotificationDetails? details,
  ) async =>
      using((Arena arena) {
        if (!_isReady) {
          throw StateError(
            'Flutter Local Notifications must be initialized before use',
          );
        }
        if (scheduledDate.isBefore(DateTime.now())) {
          throw ArgumentError(
            'Flutter Local Notifications cannot'
            ' schedule notifications in the past',
          );
        }
        final int secondsSinceEpoch =
            scheduledDate.millisecondsSinceEpoch ~/ 1000;
        _bindings.scheduleNotification(
          _plugin,
          id,
          xml.toNativeUtf8(allocator: arena),
          secondsSinceEpoch,
        );
      });

  @override
  Future<NotificationUpdateResult> updateBindings({
    required int id,
    required Map<String, String> bindings,
  }) async =>
      using((Arena arena) {
        if (!_isReady) {
          throw StateError(
            'Flutter Local Notifications must be initialized before use',
          );
        }
        final NativeUpdateResult result = _bindings.updateNotification(
            _plugin, id, bindings.toNativeMap(arena));
        return getUpdateResult(result);
      });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\plugin\stub.dart =====
import '../details.dart';
import 'base.dart';

/// The Windows implementation of `package:flutter_local_notifications`.
class FlutterLocalNotificationsWindows extends WindowsNotificationsBase {
  @override
  Future<bool> initialize(
    WindowsInitializationSettings settings, {
    DidReceiveNotificationResponseCallback? onNotificationReceived,
  }) async {
    throw UnsupportedError(
      'This platform does not support Windows notifications',
    );
  }

  @override
  void dispose() {}

  @override
  Future<void> cancel(int id) async {}

  @override
  Future<void> cancelAll() async {}

  @override
  Future<List<ActiveNotification>> getActiveNotifications() async =>
      <ActiveNotification>[];

  @override
  Future<NotificationAppLaunchDetails?>
      getNotificationAppLaunchDetails() async => null;

  @override
  Future<List<PendingNotificationRequest>>
      pendingNotificationRequests() async => <PendingNotificationRequest>[];

  @override
  Future<void> periodicallyShow(
    int id,
    String? title,
    String? body,
    RepeatInterval repeatInterval,
  ) async {}

  @override
  Future<void> periodicallyShowWithDuration(
    int id,
    String? title,
    String? body,
    Duration repeatDurationInterval,
  ) async {}

  @override
  Future<void> show(
    int id,
    String? title,
    String? body, {
    String? payload,
    WindowsNotificationDetails? details,
  }) async {}

  @override
  Future<void> showRawXml({
    required int id,
    required String xml,
    Map<String, String> bindings = const <String, String>{},
  }) async {}

  @override
  Future<void> zonedSchedule(
    int id,
    String? title,
    String? body,
    TZDateTime scheduledDate,
    WindowsNotificationDetails? details, {
    String? payload,
  }) async {}

  @override
  Future<void> zonedScheduleRawXml(
    int id,
    String xml,
    TZDateTime scheduledDate,
    WindowsNotificationDetails? details,
  ) async {}

  @override
  Future<NotificationUpdateResult> updateBindings({
    required int id,
    required Map<String, String> bindings,
  }) async =>
      NotificationUpdateResult.success;

  @override
  bool isValidXml(String xml) => false;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\src\details.dart =====
export 'details/initialization_settings.dart';
export 'details/notification_action.dart';
export 'details/notification_audio.dart';
export 'details/notification_details.dart';
export 'details/notification_header.dart';
export 'details/notification_input.dart';
export 'details/notification_parts.dart';
export 'details/notification_progress.dart';
export 'details/notification_row.dart';

/// The result of updating a notification.
enum NotificationUpdateResult {
  /// The update was successful.
  success,

  /// There was an unexpected error updating the notification.
  error,

  /// No notification with the provided ID could be found.
  notFound,
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\lib\flutter_local_notifications_windows.dart =====
export 'src/details.dart';
export 'src/msix/stub.dart' if (dart.library.ffi) 'src/msix/ffi.dart';
export 'src/plugin/stub.dart' if (dart.library.ffi) 'src/plugin/ffi.dart';
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\test\bindings_test.dart =====
import 'package:flutter_local_notifications_windows/flutter_local_notifications_windows.dart';
import 'package:test/test.dart';

const WindowsInitializationSettings settings = WindowsInitializationSettings(
  appName: 'Test app',
  appUserModelId: 'com.test.test',
  guid: 'a8c22b55-049e-422f-b30f-863694de08c8',
);

const Map<String, String> bindings = <String, String>{
  'title': 'Bindings title',
  'body': 'Bindings body',
};

void main() => group('Bindings', () {
      final FlutterLocalNotificationsWindows plugin =
          FlutterLocalNotificationsWindows();
      setUpAll(() => plugin.initialize(settings));
      tearDownAll(() async {
        await plugin.cancelAll();
        plugin.dispose();
      });

      test('work in simple cases', () async {
        await plugin.show(500, '{title}', '{body}');
        final NotificationUpdateResult result =
            await plugin.updateBindings(id: 500, bindings: bindings);
        expect(result, NotificationUpdateResult.success);
      });

      test('fail when ID is not found in simple cases', () async {
        await plugin.show(501, '{title}', '{body}');
        final NotificationUpdateResult result =
            await plugin.updateBindings(id: 599, bindings: bindings);
        expect(result, NotificationUpdateResult.notFound);
      });

      test('are included in show()', () async {
        await plugin.show(
          502,
          '{title}',
          '{body}',
          details: const WindowsNotificationDetails(bindings: bindings),
        );
      });

      test('fail when notification has been cancelled', () async {
        await Future<void>.delayed(const Duration(milliseconds: 200));
        await plugin.show(503, '{title}', '{body}');
        final NotificationUpdateResult result =
            await plugin.updateBindings(id: 503, bindings: bindings);
        expect(result, NotificationUpdateResult.success);
        await plugin.cancelAll();
        final NotificationUpdateResult result2 =
            await plugin.updateBindings(id: 503, bindings: bindings);
        expect(result2, NotificationUpdateResult.notFound);
      });
    });
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\test\details_test.dart =====
import 'package:flutter_local_notifications_windows/flutter_local_notifications_windows.dart';
import 'package:flutter_local_notifications_windows/src/details/notification_to_xml.dart';
import 'package:test/test.dart';

const WindowsInitializationSettings settings = WindowsInitializationSettings(
  appName: 'Test app',
  appUserModelId: 'com.test.test',
  guid: 'a8c22b55-049e-422f-b30f-863694de08c8',
);

extension PluginUtils on FlutterLocalNotificationsWindows {
  static int id = 15;

  void testDetails(WindowsNotificationDetails details) => expect(
        isValidXml(
          notificationToXml(
            title: 'title',
            body: 'body',
            payload: 'payload',
            details: details,
          ),
        ),
        isTrue,
      );
}

void main() => group('Details:', () {
      final FlutterLocalNotificationsWindows plugin =
          FlutterLocalNotificationsWindows();
      setUpAll(() => plugin.initialize(settings));
      tearDownAll(() async {
        await plugin.cancelAll();
        plugin.dispose();
      });

      test('No details', () async {
        expect(plugin.show(100, null, null), completes);
        expect(plugin.show(101, 'Title', null), completes);
        expect(plugin.show(102, null, 'Body'), completes);
        expect(plugin.show(103, 'Title', 'Body'), completes);
        expect(plugin.show(-1, 'Negative ID', 'Body'), completes);
      });

      test(
          'Simple details',
          () async => plugin
            ..testDetails(const WindowsNotificationDetails())
            ..testDetails(
                const WindowsNotificationDetails(subtitle: 'Subtitle'))
            ..testDetails(const WindowsNotificationDetails(
                duration: WindowsNotificationDuration.long))
            ..testDetails(const WindowsNotificationDetails(
                scenario: WindowsNotificationScenario.reminder))
            ..testDetails(WindowsNotificationDetails(timestamp: DateTime.now()))
            ..testDetails(const WindowsNotificationDetails(
                subtitle: '{message}',
                bindings: <String, String>{'message': 'Hello, Mr. Person'})));

      test('Actions', () {
        const WindowsAction simpleAction =
            WindowsAction(content: 'Press me', arguments: '123');
        final WindowsAction complexAction = WindowsAction(
          content: 'content',
          arguments: 'args',
          activationBehavior: WindowsNotificationBehavior.pendingUpdate,
          buttonStyle: WindowsButtonStyle.success,
          inputId: 'input-id',
          tooltip: 'tooltip',
          imageUri: WindowsImage.getAssetUri('test/icon.png'),
        );
        plugin
          ..testDetails(const WindowsNotificationDetails(
              actions: <WindowsAction>[simpleAction]))
          ..testDetails(WindowsNotificationDetails(
              actions: <WindowsAction>[complexAction]))
          ..testDetails(WindowsNotificationDetails(
              actions: List<WindowsAction>.filled(5, simpleAction)));
        expect(
          () => notificationToXml(
              details: WindowsNotificationDetails(
            actions: List<WindowsAction>.filled(6, simpleAction),
          )),
          throwsArgumentError,
        );
      });

      test(
          'Audio',
          () => plugin
            ..testDetails(WindowsNotificationDetails(
                audio: WindowsNotificationAudio.silent()))
            ..testDetails(WindowsNotificationDetails(
                audio: WindowsNotificationAudio.preset(
                    sound: WindowsNotificationSound.call10))));

      test('Rows', () {
        const WindowsColumn emptyColumn =
            WindowsColumn(<WindowsNotificationPart>[]);
        final WindowsImage image = WindowsImage(
          WindowsImage.getAssetUri('test/icon.png'),
          altText: 'an icon',
        );
        const WindowsNotificationText text =
            WindowsNotificationText(text: 'Text');
        final WindowsColumn simpleColumn =
            WindowsColumn(<WindowsNotificationPart>[image, text]);
        final WindowsRow bigRow = WindowsRow(
          List<WindowsColumn>.filled(5, simpleColumn),
        );
        plugin
          ..testDetails(const WindowsNotificationDetails())
          ..testDetails(const WindowsNotificationDetails(
              rows: <WindowsRow>[WindowsRow(<WindowsColumn>[])]))
          ..testDetails(const WindowsNotificationDetails(rows: <WindowsRow>[
            WindowsRow(<WindowsColumn>[emptyColumn])
          ]))
          ..testDetails(WindowsNotificationDetails(rows: <WindowsRow>[
            WindowsRow(<WindowsColumn>[simpleColumn])
          ]))
          ..testDetails(WindowsNotificationDetails(rows: <WindowsRow>[bigRow]))
          ..testDetails(WindowsNotificationDetails(
              rows: List<WindowsRow>.filled(5, bigRow)));
      });

      test('Header', () async {
        const WindowsHeader header = WindowsHeader(
          id: 'header1',
          title: 'Header 1',
          arguments: 'args1',
          activation: WindowsHeaderActivation.foreground,
        );
        plugin
          ..testDetails(const WindowsNotificationDetails(header: header))
          ..testDetails(const WindowsNotificationDetails(header: header));
      });

      test('Images', () async {
        final WindowsImage simpleImage = WindowsImage(
          WindowsImage.getAssetUri('asset.png'),
          altText: 'an icon',
        );
        final WindowsImage complexImage = WindowsImage(
          Uri.parse('https://picsum.photos/500'),
          altText: 'an icon',
          addQueryParams: true,
          crop: WindowsImageCrop.circle,
          placement: WindowsImagePlacement.appLogoOverride,
        );
        plugin
          ..testDetails(
              WindowsNotificationDetails(images: <WindowsImage>[simpleImage]))
          ..testDetails(WindowsNotificationDetails(
              images: <WindowsImage>[simpleImage, complexImage]))
          ..testDetails(
            WindowsNotificationDetails(
              images: List<WindowsImage>.filled(6, simpleImage),
            ),
          );
      });

      test('Inputs', () async {
        const WindowsTextInput textInput = WindowsTextInput(
          id: 'input',
          placeHolderContent: 'Text hint',
          title: 'Text title',
        );
        const WindowsSelectionInput selection = WindowsSelectionInput(
          id: 'input',
          items: <WindowsSelection>[
            WindowsSelection(id: 'item1', content: 'Item 1'),
            WindowsSelection(id: 'item2', content: 'Item 2'),
            WindowsSelection(id: 'item3', content: 'Item 3'),
          ],
        );
        const WindowsAction action = WindowsAction(
          content: 'Submit',
          arguments: 'submit',
          inputId: 'input',
        );
        plugin
          ..testDetails(const WindowsNotificationDetails(
              inputs: <WindowsInput>[textInput]))
          ..testDetails(const WindowsNotificationDetails(
              inputs: <WindowsInput>[selection]))
          ..testDetails(
            WindowsNotificationDetails(
              inputs: List<WindowsInput>.filled(5, textInput),
            ),
          )
          ..testDetails(const WindowsNotificationDetails(
              inputs: <WindowsInput>[textInput],
              actions: <WindowsAction>[action]))
          ..testDetails(const WindowsNotificationDetails(
              inputs: <WindowsInput>[selection, textInput],
              actions: <WindowsAction>[action]));
        expect(
          () => notificationToXml(
            details: WindowsNotificationDetails(
              inputs: List<WindowsInput>.filled(6, textInput),
            ),
          ),
          throwsArgumentError,
        );
      });

      test('Progress', () async {
        final WindowsProgressBar simple = WindowsProgressBar(
          id: 'simple',
          status: 'Testing...',
          value: 0.25,
        );
        final WindowsProgressBar complex = WindowsProgressBar(
          id: 'complex',
          status: 'Testing...',
          value: 0.75,
          label: 'Progress label',
          title: 'Progress title',
        );
        final WindowsProgressBar dynamic = WindowsProgressBar(
          id: 'dynamic',
          status: 'Testing...',
          value: 0,
        );
        plugin
          ..testDetails(WindowsNotificationDetails(
              progressBars: <WindowsProgressBar>[simple]))
          ..testDetails(WindowsNotificationDetails(
              progressBars: <WindowsProgressBar>[complex]))
          ..testDetails(WindowsNotificationDetails(
              progressBars: <WindowsProgressBar>[simple, complex]))
          ..testDetails(
            WindowsNotificationDetails(
              progressBars: List<WindowsProgressBar>.filled(6, simple),
            ),
          );
        await plugin.show(
          201,
          null,
          null,
          details: WindowsNotificationDetails(
            progressBars: <WindowsProgressBar>[dynamic],
          ),
        );
        for (double i = 0; i <= 1.5; i += 0.05) {
          dynamic.value = i;
          final NotificationUpdateResult result = await plugin
              .updateProgressBar(notificationId: 201, progressBar: dynamic);
          expect(result, NotificationUpdateResult.success);
          await Future<void>.delayed(const Duration(milliseconds: 10));
        }
        expect(
          await plugin.updateProgressBar(
              notificationId: 202, progressBar: dynamic),
          NotificationUpdateResult.notFound,
        );
      });
    });
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\test\plugin_test.dart =====
import 'package:flutter_local_notifications_platform_interface/flutter_local_notifications_platform_interface.dart';
import 'package:flutter_local_notifications_windows/flutter_local_notifications_windows.dart';
import 'package:test/test.dart';
import 'package:timezone/data/latest_all.dart';
import 'package:timezone/standalone.dart';

const WindowsInitializationSettings goodSettings =
    WindowsInitializationSettings(
  appName: 'test',
  appUserModelId: 'com.test.test',
  guid: 'a8c22b55-049e-422f-b30f-863694de08c8',
);

const WindowsInitializationSettings badSettings = WindowsInitializationSettings(
  appName: 'test',
  appUserModelId: 'com.test.test',
  guid: '123',
);

void main() => group('Plugin', () {
      setUpAll(initializeTimeZones);

      test('initializes safely', () async {
        final FlutterLocalNotificationsWindows plugin =
            FlutterLocalNotificationsWindows();
        final bool result = await plugin.initialize(goodSettings);
        expect(result, isTrue);
        plugin.dispose();
      });

      test('catches bad GUIDs', () async {
        final FlutterLocalNotificationsWindows plugin =
            FlutterLocalNotificationsWindows();
        expect(plugin.initialize(badSettings), throwsArgumentError);
        plugin.dispose();
      });

      test('cannot be used before initializing', () async {
        final FlutterLocalNotificationsWindows plugin =
            FlutterLocalNotificationsWindows();
        final WindowsProgressBar progress =
            WindowsProgressBar(id: 'progress', status: 'Testing', value: 0);
        final TZDateTime now = TZDateTime.local(2024, 7, 18);
        expect(plugin.cancel(0), throwsStateError);
        expect(plugin.cancelAll(), throwsStateError);
        expect(plugin.getActiveNotifications(), throwsStateError);
        expect(plugin.getNotificationAppLaunchDetails(), throwsStateError);
        expect(plugin.pendingNotificationRequests(), throwsStateError);
        expect(plugin.show(0, 'Title', 'Body'), throwsStateError);
        expect(plugin.showRawXml(id: 0, xml: ''), throwsStateError);
        expect(
          plugin.updateBindings(id: 0, bindings: <String, String>{}),
          throwsStateError,
        );
        expect(
          plugin.updateProgressBar(progressBar: progress, notificationId: 0),
          throwsStateError,
        );
        expect(
          plugin.zonedSchedule(0, null, null, now, null),
          throwsStateError,
        );
        plugin.dispose();
      });

      test('cannot be used after disposed', () async {
        final FlutterLocalNotificationsWindows plugin =
            FlutterLocalNotificationsWindows();
        final WindowsProgressBar progress =
            WindowsProgressBar(id: 'progress', status: 'Testing', value: 0);
        final TZDateTime now = TZDateTime.local(2024, 7, 18);
        await plugin.initialize(goodSettings);
        plugin.dispose();
        expect(plugin.cancel(0), throwsStateError);
        expect(plugin.cancelAll(), throwsStateError);
        expect(plugin.getActiveNotifications(), throwsStateError);
        expect(plugin.getNotificationAppLaunchDetails(), throwsStateError);
        expect(plugin.pendingNotificationRequests(), throwsStateError);
        expect(plugin.show(0, 'Title', 'Body'), throwsStateError);
        expect(plugin.showRawXml(id: 0, xml: ''), throwsStateError);
        expect(
          plugin.updateBindings(id: 0, bindings: <String, String>{}),
          throwsStateError,
        );
        expect(
          plugin.updateProgressBar(progressBar: progress, notificationId: 0),
          throwsStateError,
        );
        expect(
            plugin.zonedSchedule(0, null, null, now, null), throwsStateError);
        plugin.dispose();
      });

      test('does not support repeating notifications', () async {
        final FlutterLocalNotificationsWindows plugin =
            FlutterLocalNotificationsWindows();
        await plugin.initialize(goodSettings);
        expect(
          plugin.periodicallyShow(0, null, null, RepeatInterval.everyMinute),
          throwsUnsupportedError,
        );
        expect(
          plugin.periodicallyShowWithDuration(0, null, null, Duration.zero),
          throwsUnsupportedError,
        );
        plugin.dispose();
      });
    });
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\test\scheduled_test.dart =====
import 'package:flutter_local_notifications_windows/flutter_local_notifications_windows.dart';
import 'package:test/test.dart';
import 'package:timezone/data/latest_all.dart';
import 'package:timezone/standalone.dart';

const WindowsInitializationSettings settings = WindowsInitializationSettings(
    appName: 'Test app',
    appUserModelId: 'com.test.test',
    guid: 'a8c22b55-049e-422f-b30f-863694de08c8');

void main() => group('Schedules', () {
      final FlutterLocalNotificationsWindows plugin =
          FlutterLocalNotificationsWindows();
      setUpAll(initializeTimeZones);
      setUpAll(() => plugin.initialize(settings));
      tearDownAll(() async {
        await plugin.cancelAll();
        plugin.dispose();
      });

      Future<int> countPending() async =>
          (await plugin.pendingNotificationRequests()).length;
      late final Location location = getLocation('US/Eastern');

      test('do not work with earlier time', () async {
        final TZDateTime now = TZDateTime.now(location);
        final TZDateTime earlier = now.subtract(const Duration(days: 1));
        await plugin.cancelAll();
        expect(await countPending(), 0);
        expect(plugin.zonedSchedule(302, null, null, now, null),
            throwsArgumentError);
        expect(plugin.zonedSchedule(302, null, null, earlier, null),
            throwsArgumentError);
      });
    });
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_local_notifications_windows\test\xml_test.dart =====
import 'package:flutter_local_notifications_windows/flutter_local_notifications_windows.dart';
import 'package:test/test.dart';

const WindowsInitializationSettings settings = WindowsInitializationSettings(
  appName: 'test',
  appUserModelId: 'com.test.test',
  guid: 'a8c22b55-049e-422f-b30f-863694de08c8',
);

const String emptyXml = '';
const String invalidXml = 'Blah blah blah';
const String notWindowsXml = '<text>Hi<text>';
const String unmatchedXml = '<text>Hi';
const String validXml = '''
<toast>

  <visual>
    <binding template="ToastGeneric">
      <text>Hello World</text>
      <text>This is a simple toast message</text>
    </binding>
  </visual>

</toast>
''';

const String complexXml = '''
<toast launch="action=viewEvent&amp;eventId=63851">

  <visual>
    <binding template="ToastGeneric">
      <text>Surface Launch Party</text>
      <text>Studio S / Ballroom</text>
      <text>4:00 PM, 10/26/2015</text>
    </binding>
  </visual>

  <actions>

    <input id="status" type="selection" defaultInput="yes">
      <selection id="yes" content="Going"/>
      <selection id="maybe" content="Maybe"/>
      <selection id="no" content="Decline"/>
    </input>

    <action
      activationType="background"
      arguments="action=rsvpEvent&amp;eventId=63851"
      content="RSVP"/>

    <action
      activationType="system"
      arguments="dismiss"
      content=""/>

  </actions>

</toast>
''';

void main() {
  group('XML', () {
    final FlutterLocalNotificationsWindows plugin =
        FlutterLocalNotificationsWindows();

    setUpAll(() => plugin.initialize(settings));
    tearDownAll(() async {
      await plugin.cancelAll();
      plugin.dispose();
    });

    test('catches invalid XML', () async {
      expect(plugin.isValidXml(emptyXml), isFalse);
      expect(plugin.isValidXml(invalidXml), isFalse);
      expect(plugin.isValidXml(notWindowsXml), isFalse);
      expect(plugin.isValidXml(unmatchedXml), isFalse);
      expect(plugin.isValidXml(validXml), isTrue);
      expect(plugin.isValidXml(complexXml), isTrue);
    });
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_secure_storage_windows\example\integration_test\app_test.dart =====
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'package:flutter_secure_storage_windows_example/main.dart' as app;
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

// For legacy behavior investigation, change bellow line.
// Note that "Special charactors handling" cases can cause app crash
// or file creation outside of app support directory.

const useMethodChannelOnly = false;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  Future<void> cleanUpFiles() async {
    // Clean up current & legacy files.
    final directory = await getApplicationSupportDirectory();
    if (directory.existsSync()) {
      directory
          .listSync(recursive: false, followLinks: false)
          .whereType<File>()
          .where((f) =>
              path.basename(f.path) == 'flutter_secure_storage.dat' ||
              f.path.endsWith('.secure'))
          .forEach((f) => f.deleteSync());
    }

    // Check parent directory, too.
    if (directory.parent.existsSync()) {
      directory.parent
          .listSync(recursive: false, followLinks: false)
          .whereType<File>()
          .where((f) => f.path.endsWith('.secure'))
          .forEach((f) => f.deleteSync());
    }
  }

  setUpAll(() async {
    await cleanUpFiles();
  });

  tearDown(() async {
    await cleanUpFiles();
  });

  app.MyAppState getState(
    WidgetTester tester, {
    required bool useBackwardCompatibility,
  }) {
    final state = tester.state<app.MyAppState>(find.byType(app.MyApp));

    state.useBackwardCompatibilityKey.currentState!.value =
        useBackwardCompatibility;
    state.useMethodChannelOnlyKey.currentState!.value = useMethodChannelOnly;

    return state;
  }

  Future<String> checkSuccess(
    WidgetTester tester,
    app.MyAppState state, {
    String? expectedDetail,
  }) async {
    printOnFailure('checkSuccess');
    await tester.pumpAndSettle();

    expect(
      state.resultSummaryFieldController.text,
      'SUCCESS',
      reason: 'Failed: ${state.resultDetailFieldController}',
    );

    if (expectedDetail != null) {
      expect(state.resultDetailFieldController.text, expectedDetail);
    }

    return state.resultDetailFieldController.text;
  }

  Future<void> doTestSuite(
    WidgetTester tester, {
    required String key1,
    String? key2,
    String? writingValue1,
    String? writingValue2,
    bool useBackwardCompatibility = true,
  }) async {
    app.main();
    await tester.pumpAndSettle();

    final state = getState(
      tester,
      useBackwardCompatibility: useBackwardCompatibility,
    );

    // write 1
    state.keyFieldController.text = key1;
    state.valueFieldController.text = writingValue1 ?? '';

    await tester.tap(find.text('Write'));
    final value1 = await checkSuccess(tester, state);

    late final String value2;
    if (key2 != null) {
      // write 2
      state.keyFieldController.text = key2;
      state.valueFieldController.text = writingValue2 ?? '';
      await tester.tap(find.text('Write'));
      value2 = await checkSuccess(tester, state);
    }

    state.valueFieldController.text = '';

    // read for write 1
    state.keyFieldController.text = key1;
    await tester.tap(find.text('Read'));
    await checkSuccess(tester, state, expectedDetail: value1);

    if (key2 != null) {
      // read for write 2
      state.keyFieldController.text = key2;
      await tester.tap(find.text('Read'));
      await checkSuccess(tester, state, expectedDetail: value2);
    }

    // containsKey for write 1
    state.keyFieldController.text = key1;
    await tester.tap(find.text('ContainsKey'));
    await checkSuccess(tester, state, expectedDetail: 'true');

    if (key2 != null) {
      // containsKey for write 2
      state.keyFieldController.text = key2;
      await tester.tap(find.text('ContainsKey'));
      await checkSuccess(tester, state, expectedDetail: 'true');
    }

    // readAll
    await tester.tap(find.text('ReadAll'));
    await checkSuccess(
      tester,
      state,
      // Standard map's order and toString() result should be stable
      // even if there are no guarantee nand backward compatibility.
      expectedDetail:
          (key2 != null ? {key1: value1, key2: value2} : {key1: value1})
              .toString(),
    );

    // delete for write 1
    state.keyFieldController.text = key1;
    await tester.tap(find.text('Delete'));
    await checkSuccess(tester, state);

    // read for delete
    await tester.tap(find.text('Read'));
    await checkSuccess(tester, state, expectedDetail: '<null>');

    // containsKey for delete
    await tester.tap(find.text('ContainsKey'));
    await checkSuccess(tester, state, expectedDetail: 'false');

    // readAll for delete
    await tester.tap(find.text('ReadAll'));
    await checkSuccess(
      tester, state,
      // Standard map's order and toString() result should be stable
      // even if there are no guarantee nand backward compatibility.
      expectedDetail: (key2 == null ? {} : {key2: value2}).toString(),
    );

    if (key2 == null) {
      // re-write for deleteAll
      state.keyFieldController.text = key1;
      state.valueFieldController.text = writingValue1 ?? '';
      await tester.tap(find.text('Write'));
      await checkSuccess(tester, state);
      // clear
      state.valueFieldController.text = '';
    }

    // deleteAll
    await tester.tap(find.text('DeleteAll'));
    await checkSuccess(tester, state);

    // read for delete 2
    state.keyFieldController.text = key2 ?? key1;
    await tester.tap(find.text('Read'));
    await checkSuccess(tester, state, expectedDetail: '<null>');

    // containsKey for delete 2
    await tester.tap(find.text('ContainsKey'));
    await checkSuccess(tester, state, expectedDetail: 'false');

    // readAll for delete
    await tester.tap(find.text('ReadAll'));
    await checkSuccess(
      tester, state,
      // Standard map's order and toString() result should be stable
      // even if there are no guarantee nand backward compatibility.
      expectedDetail: {}.toString(),
    );
  }

  group(
    'Basic test',
    () {
      testWidgets('Smoke test', (tester) async {
        await doTestSuite(tester, key1: 'key1', key2: 'key2');
      });
    },
    skip: kIsWeb || !Platform.isWindows
        ? 'These tests only work on Windows'
        : null,
  );

  group(
    'Backwards compatibilty cases',
    () {
      Future<void> checkMigration(
        WidgetTester tester,
        app.MyAppState state,
      ) async {
        printOnFailure('checkMigration');
        await tester.tap(find.text('LegacyReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      }

      testWidgets('readAll - empty, empty', (tester) async {
        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
        await checkMigration(tester, state);
      });

      testWidgets('readAll - 1 entry, 1 entry, different keys', (tester) async {
        const key1 = 'key1';
        const key2 = 'key2';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key1;
        await tester.tap(find.text('Write'));
        final value1 = await checkSuccess(tester, state);

        state.keyFieldController.text = key2;
        await tester.tap(find.text('LegacyWrite'));
        final value2 = await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {key1: value1, key2: value2}.toString(),
        );
        await checkMigration(tester, state);
      });

      testWidgets('readAll - 1 entry, 1 entry, same keys', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        final value = await checkSuccess(tester, state);

        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {key: value}.toString(),
        );
        await checkMigration(tester, state);
      });

      testWidgets('readAll - empty, 1entry', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('LegacyWrite'));
        final value = await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {key: value}.toString(),
        );
        await checkMigration(tester, state);
      });

      testWidgets('readAll - 1entry, empty', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        final value = await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {key: value}.toString(),
        );
        await checkMigration(tester, state);
      });

      testWidgets('readAll - 2 entries, 2 entries, same keys and diffrent keys',
          (tester) async {
        const key1 = 'key1';
        const key2 = 'key2';
        const key3 = 'key3';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key1;
        await tester.tap(find.text('Write'));
        final value1 = await checkSuccess(tester, state);

        state.keyFieldController.text = key2;
        await tester.tap(find.text('Write'));
        final value2 = await checkSuccess(tester, state);

        state.keyFieldController.text = key3;
        await tester.tap(find.text('LegacyWrite'));
        final value3 = await checkSuccess(tester, state);

        state.keyFieldController.text = key1;
        await tester.tap(find.text('LegacyWrite'));
        final value4 = await checkSuccess(tester, state);

        assert(value1 != value4);

        // Do test
        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {key1: value1, key2: value2, key3: value3}.toString(),
        );
        await checkMigration(tester, state);
      });

      testWidgets('read - exists, exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        final value = await checkSuccess(tester, state);

        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: value);
        await checkMigration(tester, state);
      });

      testWidgets('read - does not exist, exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('LegacyWrite'));
        final value = await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: value);
        await checkMigration(tester, state);
      });

      testWidgets('read - exists, does not exist', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        final value = await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: value);
        await checkMigration(tester, state);
      });

      testWidgets('read - does not exist, does not exist', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Do test
        state.keyFieldController.text = key;
        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: '<null>');
        await checkMigration(tester, state);
      });

      testWidgets('containsKey - exists, exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'true');
        // containsKey does not execute auto-migration
      });

      testWidgets('containsKey - does not exist, exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'true');
        // containsKey does not execute auto-migration
      });

      testWidgets('containsKey - exists, does not exist', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'true');
        // containsKey does not execute auto-migration
      });

      testWidgets('containsKey - does not exist, does not exist',
          (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Do test
        state.keyFieldController.text = key;
        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'false');
        // containsKey does not execute auto-migration
      });

      testWidgets('write - new', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Do test
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await tester.pumpAndSettle();
        final writtenValue = await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        final readValue = await checkSuccess(tester, state);
        expect(readValue, writtenValue);
      });

      testWidgets('write - overwrite', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Do test
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await tester.pumpAndSettle();
        final writtenValue1 = await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('Write'));
        await tester.pumpAndSettle();
        final writtenValue2 = await checkSuccess(tester, state);
        await checkMigration(tester, state);

        assert(writtenValue1 != writtenValue2);

        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        final readValue = await checkSuccess(tester, state);
        expect(readValue, writtenValue2);
      });

      testWidgets('write - legacy value exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('LegacyWrite'));
        await tester.pumpAndSettle();
        final legacyValue = await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Write'));
        await tester.pumpAndSettle();
        final writtenValue = await checkSuccess(tester, state);
        await checkMigration(tester, state);

        assert(writtenValue != legacyValue);

        await tester.tap(find.text('Read'));
        await tester.pumpAndSettle();
        final readValue = await checkSuccess(tester, state);
        expect(readValue, writtenValue);
      });

      testWidgets('delete - exists, exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);
        await tester.tap(find.text('LegacyWrite'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Delete'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'false');
      });

      testWidgets('delete - exists, does not exist', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Delete'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'false');
      });

      testWidgets('delete - does not exist, exists', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('LegacyWrite'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('Delete'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'false');
      });

      testWidgets('delete - does not exist, does not exist', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Do test
        state.keyFieldController.text = key;
        await tester.tap(find.text('Delete'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ContainsKey'));
        await tester.pumpAndSettle();
        await checkSuccess(tester, state, expectedDetail: 'false');
      });

      testWidgets('deleteAll - empty, empty', (tester) async {
        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        await tester.tap(find.text('DeleteAll'));
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      });

      testWidgets('deleteAll - 1 entry, 1 entry, different keys',
          (tester) async {
        const key1 = 'key1';
        const key2 = 'key2';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key1;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        state.keyFieldController.text = key2;
        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('DeleteAll'));
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      });

      testWidgets('deleteAll - 1 entry, 1 entry, same keys', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('DeleteAll'));
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      });

      testWidgets('deleteAll - empty, 1entry', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('DeleteAll'));
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      });

      testWidgets('deleteAll - 1entry, empty', (tester) async {
        const key = 'key';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('DeleteAll'));
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      });

      testWidgets(
          'deleteAll - 2 entries, 2 entries, same keys and diffrent keys',
          (tester) async {
        const key1 = 'key1';
        const key2 = 'key2';
        const key3 = 'key3';

        app.main();
        await tester.pumpAndSettle();

        final state = getState(
          tester,
          useBackwardCompatibility: true,
        );

        // Prepare
        state.keyFieldController.text = key1;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        state.keyFieldController.text = key2;
        await tester.tap(find.text('Write'));
        await checkSuccess(tester, state);

        state.keyFieldController.text = key3;
        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        state.keyFieldController.text = key1;
        await tester.tap(find.text('LegacyWrite'));
        await checkSuccess(tester, state);

        // Do test
        await tester.tap(find.text('DeleteAll'));
        await checkSuccess(tester, state);
        await checkMigration(tester, state);

        await tester.tap(find.text('ReadAll'));
        await tester.pumpAndSettle();
        await checkSuccess(
          tester,
          state,
          // Standard map's order and toString() result should be stable
          // even if there are no guarantee nand backward compatibility.
          expectedDetail: {}.toString(),
        );
      });
    },
    skip: kIsWeb || !Platform.isWindows
        ? 'These tests only work on Windows'
        : null,
  );

  group(
    'Special charactors handling',
    () {
      testWidgets('URL', (tester) async {
        await doTestSuite(
          tester,
          key1: 'http://example.com',
          useBackwardCompatibility: false,
        );
      });

      testWidgets('Double dot', (tester) async {
        await doTestSuite(
          tester,
          key1: '/../a',
        );
      });

      testWidgets('Long key', (tester) async {
        await doTestSuite(
          tester,
          key1:
              String.fromCharCodes(Iterable.generate(256, (_) => 65 /* 'A' */)),
          useBackwardCompatibility: false,
        );
      });

      testWidgets('Empty key & value', (tester) async {
        await doTestSuite(
          tester,
          key1: '',
          writingValue1: '',
        );
      });

      for (final char in <String, int>{
        'ASCII whitespace': 0x20,
        'Nbsp': 0xA0,
        'Full-width space': 0x3000,
      }.entries) {
        testWidgets(
            'Space key & value - ${char.key} (U+${char.value.toRadixString(16).padLeft(4, '0')})',
            (tester) async {
          await doTestSuite(
            tester,
            key1: String.fromCharCode(char.value),
            writingValue1: String.fromCharCode(char.value),
          );
        });
      }

      for (final char in <String, int>{
        'Horizontal tab': 0x09,
      }.entries) {
        testWidgets(
            'Space key & value - ${char.key} (U+${char.value.toRadixString(16).padLeft(4, '0')})',
            (tester) async {
          await doTestSuite(
            tester,
            key1: String.fromCharCode(char.value),
            writingValue1: String.fromCharCode(char.value),
            useBackwardCompatibility: false,
          );
        });
      }

      for (final char in <String, String>{
        'Latin-1 (French)': 'cl\u00E9',
        'CJK (Japanese)': '\u30AD\u30FC',
        'Surrogate Pair (Emoji)': '\uD83D\uDD11',
      }.entries) {
        testWidgets('Non ASCII key & value - ${char.key}', (tester) async {
          await doTestSuite(
            tester,
            key1: char.value,
            writingValue1: char.value,
          );
        });
      }

      testWidgets('Only casing is differ', (tester) async {
        await doTestSuite(
          tester,
          key1: 'key',
          key2: 'KEY',
        );
      });
    },
    skip: kIsWeb || !Platform.isWindows
        ? 'These tests only work on Windows'
        : null,
  );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_secure_storage_windows\example\lib\main.dart =====
import 'package:flutter/material.dart';
import 'dart:async';

import 'package:flutter_secure_storage_platform_interface/flutter_secure_storage_platform_interface.dart';
import 'package:flutter_secure_storage_windows/flutter_secure_storage_windows.dart';

// testing application.
void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  State<MyApp> createState() => MyAppState();
}

class MyAppState extends State<MyApp> {
  final TextEditingController keyFieldController = TextEditingController();
  final TextEditingController valueFieldController = TextEditingController();
  final TextEditingController resultSummaryFieldController =
      TextEditingController();
  final TextEditingController resultDetailFieldController =
      TextEditingController();
  final GlobalKey<LabeledCheckboxState> useMethodChannelOnlyKey = GlobalKey();
  final GlobalKey<LabeledCheckboxState> useBackwardCompatibilityKey =
      GlobalKey();

  Future<TestResult>? _future;

  FlutterSecureStoragePlatform _flutterSecureStorageWindowsPlugin =
      FlutterSecureStorageWindows();
  final Map<String, String> _options = {'useBackwardCompatibility': 'false'};

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Plugin example app'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(8),
          child: Column(children: [
            TextField(
              controller: keyFieldController,
              decoration: const InputDecoration(label: Text('Key')),
            ),
            TextField(
              controller: valueFieldController,
              decoration: const InputDecoration(label: Text('Value')),
            ),
            LabeledCheckbox(
              key: useMethodChannelOnlyKey,
              initialValue: false,
              label: 'UseMethodChannelOnly',
              onChanged: (useMethodChannelOnly) {
                setState(() {
                  _flutterSecureStorageWindowsPlugin = useMethodChannelOnly
                      ? MethodChannelFlutterSecureStorage()
                      : FlutterSecureStorageWindows();
                });
              },
            ),
            LabeledCheckbox(
              key: useBackwardCompatibilityKey,
              initialValue: false,
              label: 'UseBackwardCompatibility',
              onChanged: (useBackwardCompatibility) {
                setState(() {
                  _options['useBackwardCompatibility'] =
                      useBackwardCompatibility.toString();
                });
              },
            ),
            Row(
              children: [
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doRead,
                    child: const Text('Read'),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doReadAll,
                    child: const Text('ReadAll'),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doContainsKey,
                    child: const Text('ContainsKey'),
                  ),
                ),
              ],
            ),
            Row(
              children: [
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doWrite,
                    child: const Text('Write'),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doDelete,
                    child: const Text('Delete'),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doDeleteAll,
                    child: const Text('DeleteAll'),
                  ),
                ),
              ],
            ),
            Row(
              children: [
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doLegacyWrite,
                    child: const Text('LegacyWrite'),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(4),
                  child: ElevatedButton(
                    onPressed: doLegacyReadAll,
                    child: const Text('LegacyReadAll'),
                  ),
                ),
              ],
            ),
            if (_future != null)
              FutureBuilder<TestResult>(
                builder: (context, snapshot) {
                  if (!snapshot.hasData && !snapshot.hasError) {
                    return const CircularProgressIndicator();
                  }

                  resultSummaryFieldController.text =
                      (snapshot.data?.success ?? false) ? 'SUCCESS' : 'FAIL';

                  return TextField(
                    controller: resultSummaryFieldController,
                    decoration: const InputDecoration(label: Text('Result')),
                  );
                },
                future: _future,
              ),

            if (_future != null)
              FutureBuilder<TestResult>(
                builder: (context, snapshot) {
                  if (!snapshot.hasData && !snapshot.hasError) {
                    return const CircularProgressIndicator();
                  }

                  resultDetailFieldController.text =
                      snapshot.error?.toString() ??
                          snapshot.data!.detail ??
                          '<null>';

                  return Column(
                    children: [
                      TextField(
                        controller: resultSummaryFieldController,
                        decoration:
                            const InputDecoration(label: Text('Result')),
                      ),
                      TextField(
                        controller: resultDetailFieldController,
                        decoration:
                            const InputDecoration(label: Text('Detail')),
                      ),
                    ],
                  );
                },
                future: _future,
              ),
            // const Expanded(child: SizedBox()),
          ]),
        ),
      ),
    );
  }

  Future<TestResult> doTestCore(FutureOr<TestResult> Function() test) async {
    late final TestResult result;
    try {
      result = await test();
    } catch (e, s) {
      debugPrint(e.toString());
      debugPrintStack(stackTrace: s);
      result = TestResult(success: false, detail: e.toString());
    }

    return result;
  }

  void doTest(FutureOr<TestResult> Function() test) {
    setState(() {
      _future = doTestCore(test);
    });
  }

  void doRead() => doTest(() async {
        final key = keyFieldController.text;
        return TestResult(
          success: true,
          detail: await _flutterSecureStorageWindowsPlugin.read(
            key: key,
            options: _options,
          ),
        );
      });

  void doReadAll() => doTest(() async {
        return TestResult(
          success: true,
          detail: (await _flutterSecureStorageWindowsPlugin.readAll(
            options: _options,
          ))
              .toString(),
        );
      });

  void doContainsKey() => doTest(() async {
        final key = keyFieldController.text;
        return TestResult(
          success: true,
          detail: (await _flutterSecureStorageWindowsPlugin.containsKey(
            key: key,
            options: _options,
          ))
              .toString(),
        );
      });

  void doWrite() => doTest(() async {
        final key = keyFieldController.text;
        final value = valueFieldController.text.isNotEmpty
            ? valueFieldController.text
            : DateTime.now().toIso8601String();
        await _flutterSecureStorageWindowsPlugin.write(
          key: key,
          value: value,
          options: _options,
        );
        return TestResult(success: true, detail: value);
      });

  void doDelete() => doTest(() async {
        final key = keyFieldController.text;
        await _flutterSecureStorageWindowsPlugin.delete(
          key: key,
          options: _options,
        );
        return TestResult(
          success: true,
          detail: null,
        );
      });

  void doDeleteAll() => doTest(() async {
        await _flutterSecureStorageWindowsPlugin.deleteAll(
          options: _options,
        );
        return TestResult(
          success: true,
          detail: null,
        );
      });

  void doLegacyWrite() => doTest(() async {
        final key = keyFieldController.text;
        final value = valueFieldController.text.isNotEmpty
            ? valueFieldController.text
            : DateTime.now().toIso8601String();
        // call MethodChannelFlutterSecureStorage directly
        final legacyStorage = MethodChannelFlutterSecureStorage();
        await legacyStorage.write(
          key: key,
          value: value,
          options: _options,
        );
        return TestResult(success: true, detail: value);
      });

  void doLegacyReadAll() => doTest(() async {
        // call MethodChannelFlutterSecureStorage directly
        final legacyStorage = MethodChannelFlutterSecureStorage();
        return TestResult(
            success: true,
            detail: (await legacyStorage.readAll(
              options: _options,
            ))
                .toString());
      });
}

class TestResult {
  final bool success;
  final String? detail;
  TestResult({
    required this.success,
    required this.detail,
  });
}

class LabeledCheckbox extends StatefulWidget {
  final String label;
  final EdgeInsetsGeometry padding;
  final bool initialValue;
  final ValueChanged<bool>? onChanged;
  const LabeledCheckbox({
    Key? key,
    required this.label,
    this.padding = const EdgeInsets.all(4),
    this.initialValue = false,
    this.onChanged,
  }) : super(key: key);

  @override
  State<StatefulWidget> createState() => LabeledCheckboxState._();
}

class LabeledCheckboxState extends State<LabeledCheckbox> {
  late bool _value;

  bool get value => _value;
  set value(bool v) {
    setState(() {
      _value = v;
    });

    widget.onChanged?.call(v);
  }

  LabeledCheckboxState._();

  @override
  void initState() {
    super.initState();
    _value = widget.initialValue;
  }

  @override
  Widget build(BuildContext context) => InkWell(
        onTap: () {
          value = !value;
        },
        child: Padding(
          padding: widget.padding,
          child: Row(children: [
            Expanded(child: Text(widget.label)),
            Checkbox(
                value: value,
                onChanged: (newValue) {
                  if (newValue != null) {
                    value = newValue;
                  }
                })
          ]),
        ),
      );
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_secure_storage_windows\lib\src\flutter_secure_storage_windows_ffi.dart =====
import 'dart:async';
import 'dart:convert';
import 'dart:ffi';
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:flutter/services.dart';
import 'package:flutter_secure_storage_platform_interface/flutter_secure_storage_platform_interface.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:win32/win32.dart';

@visibleForTesting
extension OptionsExtension on Map<String, String> {
  bool get useBackwardCompatibility =>
      this['useBackwardCompatibility'] != 'false';
}

class FlutterSecureStorageWindows extends FlutterSecureStoragePlatform {
  final FlutterSecureStoragePlatform _backwardCompatible;
  final MapStorage _storage;

  FlutterSecureStorageWindows()
      : this._(
          MethodChannelFlutterSecureStorage(),
          DpapiJsonFileMapStorage(),
        );

  FlutterSecureStorageWindows._(
    this._backwardCompatible,
    this._storage,
  );

  /// Registers this plugin.
  static void registerWith() {
    FlutterSecureStoragePlatform.instance = FlutterSecureStorageWindows();
  }

  @override
  Future<bool> containsKey({
    required String key,
    required Map<String, String> options,
  }) async {
    final map = await _storage.load(options);
    if (map.containsKey(key)) {
      return true;
    }

    if (options.useBackwardCompatibility) {
      return _backwardCompatible.containsKey(key: key, options: options);
    }

    return false;
  }

  @override
  Future<void> delete({
    required String key,
    required Map<String, String> options,
  }) async {
    final map = await _storage.load(options);
    final initialSize = map.length;
    map.remove(key);
    if (map.length != initialSize) {
      await _storage.save(map, options);
    }

    if (options.useBackwardCompatibility) {
      await _backwardCompatible.delete(key: key, options: options);
    }
  }

  @override
  Future<void> deleteAll({required Map<String, String> options}) async {
    await _storage.clear(options);

    if (options.useBackwardCompatibility) {
      await _backwardCompatible.deleteAll(options: options);
    }
  }

  @override
  Future<String?> read({
    required String key,
    required Map<String, String> options,
  }) async {
    final map = await _storage.load(options);

    var result = map[key];
    if (options.useBackwardCompatibility) {
      if (result == null) {
        final compatible =
            await _backwardCompatible.read(key: key, options: options);
        if (compatible != null) {
          // Write back now, so the value should be retrieved from JSON file next.
          result = map[key] = compatible;
          await _storage.save(map, options);
        }
      }

      // Clear old entry.
      await _backwardCompatible.delete(key: key, options: options);
    }

    return result;
  }

  @override
  Future<Map<String, String>> readAll({
    required Map<String, String> options,
  }) async {
    final map = await _storage.load(options);
    if (!options.useBackwardCompatibility) {
      // Just return a map.
      return map;
    }

    final compatible = await _backwardCompatible.readAll(options: options);

    if (compatible.isEmpty) {
      return map;
    }

    for (final entry in compatible.entries) {
      map.putIfAbsent(entry.key, () => entry.value);
    }

    // Write back now, so the value should be retrieved from JSON file next.
    await _storage.save(map, options);

    // Clear old entries.
    await _backwardCompatible.deleteAll(options: options);

    return map;
  }

  @override
  Future<void> write({
    required String key,
    required String value,
    required Map<String, String> options,
  }) async {
    final map = await _storage.load(options);
    map[key] = value;
    await _storage.save(map, options);

    if (options.useBackwardCompatibility) {
      // Clear old entry.
      _backwardCompatible.delete(key: key, options: options);
    }
  }

  // @override
  // Future<bool> isCupertinoProtectedDataAvailable() => Future.value(true);
  //
  // @override
  // Stream<bool> get onCupertinoProtectedDataAvailabilityChanged =>
  //     Stream.value(true);
}

@visibleForTesting
FlutterSecureStorageWindows createFlutterSecureStorageWindows(
  FlutterSecureStoragePlatform backwardCompatible,
  MapStorage mapStorage,
) =>
    FlutterSecureStorageWindows._(backwardCompatible, mapStorage);

@visibleForTesting
abstract class MapStorage {
  FutureOr<Map<String, String>> load(Map<String, String> options);
  FutureOr<void> save(Map<String, String> data, Map<String, String> options);
  FutureOr<void> clear(Map<String, String> options);
}

@visibleForTesting
const String encryptedJsonFileName = 'flutter_secure_storage.dat';

@visibleForTesting
class DpapiJsonFileMapStorage extends MapStorage {
  DpapiJsonFileMapStorage();

  FutureOr<String> _getJsonFilePath() async {
    final appDataDirectory = await getApplicationSupportDirectory();

    return path.canonicalize(
      path.join(
        appDataDirectory.path,
        encryptedJsonFileName,
      ),
    );
  }

  @override
  FutureOr<Map<String, String>> load(Map<String, String> options) async {
    final file = File(await _getJsonFilePath());
    if (!(await file.exists())) {
      return {};
    }

    late final Uint8List encryptedText;
    try {
      encryptedText = await file.readAsBytes();
    } on FileSystemException catch (e) {
      // Another process has been deleted a file or parent directory
      // since previous File.exists() call.
      // We can ignore it.
      debugPrint(
        'Reading file has been deleted by another process. $e',
      );
      return {};
    }

    late final String plainText;
    try {
      plainText = using((alloc) {
        final Pointer<Uint8> pEncryptedText = alloc(encryptedText.length);
        pEncryptedText
            .asTypedList(encryptedText.length)
            .setAll(0, encryptedText);

        // Specify size of the struct explicitly.
        final Pointer<CRYPT_INTEGER_BLOB> encryptedTextBlob =
            alloc.allocate(sizeOf<CRYPT_INTEGER_BLOB>());
        encryptedTextBlob.ref.cbData = encryptedText.length;
        encryptedTextBlob.ref.pbData = pEncryptedText;

        // Specify size of the struct explicitly.
        final Pointer<CRYPT_INTEGER_BLOB> plainTextBlob =
            alloc.allocate(sizeOf<CRYPT_INTEGER_BLOB>());
        if (CryptUnprotectData(
              encryptedTextBlob,
              nullptr,
              nullptr,
              nullptr,
              nullptr,
              0,
              plainTextBlob,
            ) ==
            0) {
          throw WindowsException(
            GetLastError(),
            message: 'Failure on CryptUnprotectData()',
          );
        }

        if (plainTextBlob.ref.pbData.address == NULL) {
          throw WindowsException(
            ERROR_OUTOFMEMORY,
            message: 'Failure on CryptUnprotectData()',
          );
        }

        try {
          return utf8.decoder.convert(
            plainTextBlob.ref.pbData.asTypedList(plainTextBlob.ref.cbData),
          );
        } finally {
          if (plainTextBlob.ref.pbData.address != NULL) {
            if (LocalFree(plainTextBlob.ref.pbData).address != NULL) {
              debugPrint(
                'load: Failed to LocalFree with: 0x${GetLastError().toHexString(32)}',
              );
            }
          }
        }
      });
    } on FormatException catch (e) {
      // A file content should be malformed.
      debugPrint(
        'Failed to decrypt data: $e Delete corrupt file: ${file.path}',
      );
      await file.delete();
      rethrow;
    } on WindowsException catch (e) {
      // A file content should be malformed.
      debugPrint(
        'Failed to decrypt data: $e Delete corrupt file: ${file.path}',
      );
      await file.delete();
      rethrow;
    }

    final dynamic decoded;
    try {
      decoded = jsonDecode(plainText);
    } on FormatException catch (e) {
      // A file content should be malformed.
      debugPrint(
        'Failed to parse JSON: $e Delete corrupt file: ${file.path}',
      );
      await file.delete();
      rethrow;
    }

    if (decoded is! Map) {
      debugPrint(
        'Failed to parse JSON: Not an object. Delete corrupt file: ${file.path}',
      );
      await file.delete();
      throw const FormatException('JSON is not an object.');
    }

    return {
      for (final e
          in decoded.entries.where((x) => x.key is String && x.value is String))
        e.key as String: e.value as String,
    };
  }

  @override
  FutureOr<void> save(
    Map<String, String> data,
    Map<String, String> options,
  ) async {
    final file = File(await _getJsonFilePath());
    final json = jsonEncode(data);
    final plainText = utf8.encode(json);

    await using<FutureOr<void>>((alloc) async {
      final Pointer<Uint8> pPlainText = alloc(plainText.length);
      pPlainText.asTypedList(plainText.length).setAll(0, plainText);

      // Specify size of the struct explicitly.
      final Pointer<CRYPT_INTEGER_BLOB> plainTextBlob =
          alloc.allocate(sizeOf<CRYPT_INTEGER_BLOB>());
      plainTextBlob.ref.cbData = plainText.length;
      plainTextBlob.ref.pbData = pPlainText;

      // Specify size of the struct explicitly.
      final Pointer<CRYPT_INTEGER_BLOB> encryptedTextBlob =
          alloc.allocate(sizeOf<CRYPT_INTEGER_BLOB>());
      if (CryptProtectData(
            plainTextBlob,
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            0,
            encryptedTextBlob,
          ) ==
          0) {
        throw WindowsException(
          GetLastError(),
          message: 'Failure on CryptProtectData()',
        );
      }

      if (encryptedTextBlob.ref.pbData.address == NULL) {
        throw WindowsException(
          ERROR_OUTOFMEMORY,
          message: 'Failure on CryptProtectData()',
        );
      }

      try {
        final encryptedText = encryptedTextBlob.ref.pbData
            .asTypedList(encryptedTextBlob.ref.cbData);

        // Loop to handle race condition.
        while (true) {
          try {
            await (await file.create(recursive: true))
                .writeAsBytes(encryptedText, flush: true);
            // If success, finish loop.
            break;
          } on FileSystemException catch (e) {
            // Another process has been deleted a file or parent directory
            // since previous File.create() call.
            // We will retry writing.
            debugPrint(
              'Reading file has been deleted by another process. $e',
            );
          }
        }
      } finally {
        if (encryptedTextBlob.ref.pbData.address != NULL) {
          if (LocalFree(encryptedTextBlob.ref.pbData).address != NULL) {
            debugPrint(
              'save: Failed to LocalFree with: 0x${GetLastError().toHexString(32)}',
            );
          }
        }
      }
    });
  }

  @override
  FutureOr<void> clear(Map<String, String> options) async {
    final file = File(await _getJsonFilePath());
    if (await file.exists()) {
      try {
        await file.delete();
      } on FileSystemException catch (e) {
        // Another process has been deleted a file or parent directory
        // since previous File.exists() call.
        // We can ignore it.
        debugPrint(
          'Deleting file has been deleted by another process. $e',
        );
      }
    }
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_secure_storage_windows\lib\src\flutter_secure_storage_windows_stub.dart =====
import 'package:flutter_secure_storage_platform_interface/flutter_secure_storage_platform_interface.dart';

/// A stub implementation to avoid extra transitive dependencies
/// on non-Windows platforms including web.
class FlutterSecureStorageWindows extends FlutterSecureStoragePlatform {
  /// Cannot be instantiated.
  FlutterSecureStorageWindows()
      : assert(false, 'Cannot instantiate this class.');

  /// Registers this plugin.
  static void registerWith() {
    FlutterSecureStoragePlatform.instance = FlutterSecureStorageWindows();
  }

  @override
  Future<bool> containsKey({
    required String key,
    required Map<String, String> options,
  }) =>
      Future.value(false);

  @override
  Future<void> delete({
    required String key,
    required Map<String, String> options,
  }) =>
      Future.value();

  @override
  Future<void> deleteAll({required Map<String, String> options}) =>
      Future.value();

  @override
  Future<String?> read({
    required String key,
    required Map<String, String> options,
  }) =>
      Future.value();

  @override
  Future<Map<String, String>> readAll({required Map<String, String> options}) =>
      Future.value({});

  @override
  Future<void> write({
    required String key,
    required String value,
    required Map<String, String> options,
  }) =>
      Future.value();

  // @override
  // Future<bool> isCupertinoProtectedDataAvailable() => Future.value(true);
  //
  // @override
  // Stream<bool> get onCupertinoProtectedDataAvailabilityChanged =>
  //     Stream.value(true);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_secure_storage_windows\lib\flutter_secure_storage_windows.dart =====
export 'src/flutter_secure_storage_windows_stub.dart'
    if (dart.library.ffi) 'src/flutter_secure_storage_windows_ffi.dart'
    show FlutterSecureStorageWindows;
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\flutter_secure_storage_windows\test\unit_test.dart =====
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter/services.dart';
import 'package:flutter_secure_storage_platform_interface/flutter_secure_storage_platform_interface.dart';
import 'package:flutter_secure_storage_windows/src/flutter_secure_storage_windows_ffi.dart'
    as ffi;
import 'package:flutter_secure_storage_windows/src/flutter_secure_storage_windows_ffi.dart';
import 'package:flutter_secure_storage_windows/src/flutter_secure_storage_windows_stub.dart'
    as stub;
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  FutureOr<void> cleanUpFiles() async {
    // Clean up current & legacy files.
    final directory = await getApplicationSupportDirectory();
    if (directory.existsSync()) {
      directory
          .listSync(followLinks: false)
          .whereType<File>()
          .where((f) =>
              path.basename(f.path) == encryptedJsonFileName ||
              f.path.endsWith('.secure'),)
          .forEach((f) => f.deleteSync());
    }
  }

  setUpAll(() async {
    await cleanUpFiles();
  });

  tearDown(() async {
    await cleanUpFiles();
  });

  group('Basic test cases', () {
    FlutterSecureStoragePlatform createTarget() {
      TestWidgetsFlutterBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(
        const MethodChannel('plugins.it_nomads.com/flutter_secure_storage'),
        (methodCall) async {
          assert(false, 'MethodChanel is called.');
          return null;
        },
      );
      return ffi.FlutterSecureStorageWindows();
    }

    Map<String, String> createOptions() =>
        {'useBackwardCompatibility': 'false'};

    test(
      'readAll - empty',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        final result = await target.readAll(options: options);
        expect(result, isEmpty);
      }),
    );

    test(
      'readAll - 1 entries',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value = 'VALUE';
        await target.write(key: key, value: value, options: options);
        final result = await target.readAll(options: options);
        expect(result.length, 1);
        expect(result[key], value);
      }),
    );

    test(
      'readAll - 2 entries',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key1 = 'KEY1';
        const value1 = 'VALUE1';
        const key2 = 'KEY2';
        const value2 = 'VALUE2';
        await target.write(key: key1, value: value1, options: options);
        await target.write(key: key2, value: value2, options: options);
        final result = await target.readAll(options: options);
        expect(result.length, 2);
        expect(result[key1], value1);
        expect(result[key2], value2);
      }),
    );

    test(
      'read - exists',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value = 'VALUE';
        await target.write(key: key, value: value, options: options);
        final result = await target.read(key: key, options: options);
        expect(result, isNotNull);
        expect(result, value);
      }),
    );

    test(
      'read - does not exist',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        final result = await target.read(key: key, options: options);
        expect(result, isNull);
      }),
    );

    test(
      'containsKey - exists',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value = 'VALUE';
        await target.write(key: key, value: value, options: options);
        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
      }),
    );

    test(
      'containsKey - does not exist',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        expect(
          await target.containsKey(key: key, options: options),
          isFalse,
        );
      }),
    );

    test(
      'write - new',
      () => withFfi(() async {
        // Just checking file was created. Its contents should be tested via "read" test.

        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value = 'VALUE';
        await target.write(key: key, value: value, options: options);

        final directory = await getApplicationSupportDirectory();
        final file = File(path.join(directory.path, encryptedJsonFileName));
        expect(file.existsSync(), isTrue);
        expect(file.statSync().size, greaterThan(0));
        // May be encrypted
        final content = file.readAsBytesSync();
        expect(
          content,
          isNot(
            Uint8List.fromList(
              utf8.encode('{"$key":"$value"}'),
            ),
          ),
        );
        try {
          final map = jsonDecode(utf8.decode(content));
          if (map is! Map || map[key] != value) {
            throw const FormatException('might be encrypted');
          }

          fail('might not be encrypted');
        } on FormatException catch (_) {
          // OK
        }
      }),
    );

    test(
      'write - overwrite',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value1 = 'VALUE1';
        const value2 = 'VALUE2';
        await target.write(key: key, value: value1, options: options);
        await target.write(key: key, value: value2, options: options);

        final result = await target.read(key: key, options: options);
        expect(result, isNotNull);
        expect(result, value2);

        final results = await target.readAll(options: options);
        expect(results.length, 1);
        expect(results[key], value2);
      }),
    );

    test(
      'delete - exists',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value = 'VALUE';
        await target.write(key: key, value: value, options: options);
        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );

        await target.delete(key: key, options: options);
        expect(
          await target.containsKey(key: key, options: options),
          isFalse,
        );
      }),
    );

    test(
      'delete - does not exist',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        expect(
          await target.containsKey(key: key, options: options),
          isFalse,
        );

        await target.delete(key: key, options: options);

        expect(
          await target.containsKey(key: key, options: options),
          isFalse,
        );
      }),
    );

    test(
      'deleteAll - empty',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        await target.deleteAll(options: options);
        expect(
          await target.readAll(options: options),
          isEmpty,
        );
      }),
    );

    test(
      'deleteAll - 1 entries',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key = 'KEY';
        const value = 'VALUE';
        await target.write(key: key, value: value, options: options);
        await target.deleteAll(options: options);
        expect(
          await target.readAll(options: options),
          isEmpty,
        );
      }),
    );

    test(
      'deleteAll - 2 entries',
      () => withFfi(() async {
        final target = createTarget();
        final options = createOptions();
        const key1 = 'KEY1';
        const value1 = 'VALUE1';
        const key2 = 'KEY2';
        const value2 = 'VALUE2';
        await target.write(key: key1, value: value1, options: options);
        await target.write(key: key2, value: value2, options: options);
        await target.deleteAll(options: options);
        expect(
          await target.readAll(options: options),
          isEmpty,
        );
      }),
    );
  });

  // These cases depend on 'Basic cases' are passed corrrectly.
  // Just test backward compatibility logics.
  group('Backwards compatibilty cases', () {
    FlutterSecureStoragePlatform createTarget(
      Future<Object?> Function(MethodCall) handler,
    ) {
      TestWidgetsFlutterBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(
        const MethodChannel('plugins.it_nomads.com/flutter_secure_storage'),
        handler,
      );
      return ffi.createFlutterSecureStorageWindows(
        MethodChannelFlutterSecureStorage(),
        ffi.DpapiJsonFileMapStorage(),
      );
    }

    Map<String, String> createOptions() => {'useBackwardCompatibility': 'true'};

    test(
      'readAll - empty, empty',
      () => withFfi(() async {
        var readAllCalled = 0;
        var deleteAllCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'readAll':
              readAllCalled++;
              return <String, String>{};
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        final result = await target.readAll(options: options);
        expect(result, isEmpty);
        expect(readAllCalled, 1);
        expect(deleteAllCalled, 0);
      }),
    );
    test(
      'readAll - 1 entry, 1 entry, different keys',
      () => withFfi(() async {
        const newKey = 'KEY1';
        const newValue = 'VALUE1';
        const oldKey = 'KEY2';
        const oldValue = 'VALUE2';

        var readAllCalled = 0;
        var deleteAllCalled = 0;
        var onInit = true;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'readAll':
              readAllCalled++;
              return deleteAllCalled > 0 ? {} : {oldKey: oldValue};
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            case 'delete':
              if (onInit) {
                return null;
              }
          }
          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: newKey, value: newValue, options: options);
        onInit = false;
        final result1 = await target.readAll(options: options);
        expect(result1.length, 2);
        expect(result1[oldKey], oldValue);
        expect(result1[newKey], newValue);
        expect(readAllCalled, 1);
        expect(deleteAllCalled, 1);

        final result2 = await target.readAll(options: options);
        expect(result2.length, 2);
        expect(result2[oldKey], oldValue);
        expect(result2[newKey], newValue);
        expect(readAllCalled, 2);
        expect(deleteAllCalled, 1);
      }),
    );

    test(
      'readAll - 1 entry, 1 entry, same keys',
      () => withFfi(() async {
        const newKey = 'KEY';
        const newValue = 'VALUE1';
        const oldKey = newKey;
        const oldValue = 'VALUE2';

        var readAllCalled = 0;
        var deleteAllCalled = 0;
        var onInit = true;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'readAll':
              readAllCalled++;
              return deleteAllCalled > 0 ? {} : {oldKey: oldValue};
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            case 'delete':
              if (onInit) {
                return null;
              }
          }
          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: newKey, value: newValue, options: options);
        onInit = false;
        final result1 = await target.readAll(options: options);
        expect(result1.length, 1);
        expect(result1[oldKey], newValue);
        expect(result1[newKey], newValue);
        expect(readAllCalled, 1);
        expect(deleteAllCalled, 1);

        final result2 = await target.readAll(options: options);
        expect(result2.length, 1);
        expect(result1[oldKey], newValue);
        expect(result1[newKey], newValue);
        expect(readAllCalled, 2);
        expect(deleteAllCalled, 1);
      }),
    );

    test(
      'readAll - empty, 1entry',
      () => withFfi(() async {
        const oldKey = 'KEY';
        const oldValue = 'VALUE2';

        var readCalled = 0;
        var readAllCalled = 0;
        var deleteAllCalled = 0;
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'read':
              readCalled++;
              return deleteAllCalled > 0
                  ? null
                  : (call.arguments as Map<String, dynamic>)['key'] == oldKey
                      ? oldValue
                      : null;
            case 'readAll':
              readAllCalled++;
              return deleteAllCalled > 0 ? {} : {oldKey: oldValue};
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });

        final options = createOptions();
        final result1 = await target.readAll(options: options);
        expect(result1.length, 1);
        expect(result1[oldKey], oldValue);
        expect(readCalled, 0);
        expect(readAllCalled, 1);
        expect(deleteAllCalled, 1);
        expect(deleteCalled, 0);

        final result2 = await target.readAll(options: options);
        expect(result2.length, 1);
        expect(result2[oldKey], oldValue);
        expect(readCalled, 0);
        expect(readAllCalled, 2);
        expect(deleteAllCalled, 1);
        expect(deleteCalled, 0);

        final result3 = await target.read(key: oldKey, options: options);
        expect(result3, oldValue);
        // auto-migrated
        expect(readCalled, 0);
        expect(readAllCalled, 2);
        expect(deleteAllCalled, 1);
        expect(deleteCalled, 1);
      }),
    );

    test(
      'readAll - 1entry, empty',
      () => withFfi(() async {
        const newKey = 'KEY';
        const newValue = 'VALUE1';

        var readAllCalled = 0;
        var deleteAllCalled = 0;
        var onInit = true;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'readAll':
              readAllCalled++;
              return <String, String>{};
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            case 'delete':
              if (onInit) {
                return null;
              }
          }
          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: newKey, value: newValue, options: options);
        onInit = false;
        final result1 = await target.readAll(options: options);
        expect(result1.length, 1);
        expect(result1[newKey], newValue);
        expect(readAllCalled, 1);
        expect(deleteAllCalled, 0);

        final result2 = await target.readAll(options: options);
        expect(result2.length, 1);
        expect(result1[newKey], newValue);
        expect(readAllCalled, 2);
        expect(deleteAllCalled, 0);
      }),
    );

    test(
      'readAll - 2 entries, 2 entries, same keys and diffrent keys',
      () => withFfi(() async {
        const newKey1 = 'KEY1';
        const newValue1 = 'VALUE1';
        const newKey2 = 'KEY2';
        const newValue2 = 'VALUE2';
        const oldKey1 = 'KEY3';
        const oldValue1 = 'VALUE3';
        const oldKey2 = newKey1;
        const oldValue2 = 'VALUE4';

        var readAllCalled = 0;
        var deleteAllCalled = 0;
        var onInit = true;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'readAll':
              readAllCalled++;
              return deleteAllCalled > 0
                  ? {}
                  : {oldKey1: oldValue1, oldKey2: oldValue2};
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            case 'delete':
              if (onInit) {
                return null;
              }
          }
          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: newKey1, value: newValue1, options: options);
        await target.write(key: newKey2, value: newValue2, options: options);
        onInit = false;
        final result1 = await target.readAll(options: options);
        expect(result1.length, 3);
        expect(result1[newKey1], newValue1);
        expect(result1[newKey2], newValue2);
        expect(result1[oldKey1], oldValue1);
        expect(result1[oldKey2], newValue1);
        expect(readAllCalled, 1);
        expect(deleteAllCalled, 1);

        final result2 = await target.readAll(options: options);
        expect(result2.length, 3);
        expect(result1[newKey1], newValue1);
        expect(result1[newKey2], newValue2);
        expect(result1[oldKey1], oldValue1);
        expect(result1[oldKey2], newValue1);
        expect(readAllCalled, 2);
        expect(deleteAllCalled, 1);
      }),
    );

    test(
      'read - exists, exists',
      () => withFfi(() async {
        const key = 'KEY';
        const newValue = 'VALUE1';
        const oldValue = 'VALUE2';

        var readCalled = 0;
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'read':
              readCalled++;
              return deleteCalled > 0 ? null : {key: oldValue};
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        await target.write(key: key, value: newValue, options: options);
        expect(deleteCalled, 1);
        final result1 = await target.read(key: key, options: options);
        expect(result1, newValue);
        expect(readCalled, 0);
        expect(deleteCalled, 2);

        final result2 = await target.read(key: key, options: options);
        expect(result2, newValue);
        expect(readCalled, 0);
        expect(deleteCalled, 3);
      }),
    );

    test(
      'read - does not exist, exists',
      () => withFfi(() async {
        const key = 'KEY';
        const value = 'VALUE';

        var readCalled = 0;
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'read':
              readCalled++;
              return deleteCalled > 0 ? null : value;
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        final result1 = await target.read(key: key, options: options);
        expect(result1, value);
        expect(readCalled, 1);
        expect(deleteCalled, 1);

        final result2 = await target.read(key: key, options: options);
        expect(result2, value);
        expect(readCalled, 1);
        expect(deleteCalled, 2);
      }),
    );

    test(
      'read - exists, does not exist',
      () => withFfi(() async {
        const key = 'KEY';
        const value = 'VALUE';

        var readCalled = 0;
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'read':
              readCalled++;
              return null;
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        await target.write(key: key, value: value, options: options);
        expect(deleteCalled, 1);

        final result1 = await target.read(key: key, options: options);
        expect(result1, value);
        expect(readCalled, 0);
        expect(deleteCalled, 2);

        final result2 = await target.read(key: key, options: options);
        expect(result2, value);
        expect(readCalled, 0);
        expect(deleteCalled, 3);
      }),
    );

    test(
      'read - does not exist, does not exist',
      () => withFfi(() async {
        const key = 'KEY';

        var readCalled = 0;
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'read':
              readCalled++;
              return null;
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();

        final result1 = await target.read(key: key, options: options);
        expect(result1, isNull);
        expect(readCalled, 1);
        expect(deleteCalled, 1);

        final result2 = await target.read(key: key, options: options);
        expect(result2, isNull);
        expect(readCalled, 2);
        expect(deleteCalled, 2);
      }),
    );

    test(
      'containsKey - exists, exists',
      () => withFfi(() async {
        const key = 'KEY';
        const newValue = 'VALUE1';

        var containsKeyCalled = 0;
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'containsKey':
              containsKeyCalled++;
              return deleteCalled > 0 && (call.arguments as Map<String, dynamic>)['key'] == key;
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        await target.write(key: key, value: newValue, options: options);
        expect(deleteCalled, 1);
        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
        expect(containsKeyCalled, 0);
        expect(deleteCalled, 1);

        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
        expect(containsKeyCalled, 0);
        expect(deleteCalled, 1);
      }),
    );

    test(
      'containsKey - does not exist, exists',
      () => withFfi(() async {
        const key = 'KEY';

        var containsKeyCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'containsKey':
              containsKeyCalled++;
              return (call.arguments as Map<String, dynamic>)['key'] == key;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
        expect(containsKeyCalled, 1);

        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
        expect(containsKeyCalled, 2);
      }),
    );

    test(
      'containsKey - exists, does not exist',
      () => withFfi(() async {
        const key = 'KEY';
        const newValue = 'VALUE1';

        var containsKeyCalled = 0;
        var onInit = true;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'containsKey':
              containsKeyCalled++;
              return false;
            case 'delete':
              if (onInit) {
                return null;
              }
              break;
          }
          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: key, value: newValue, options: options);
        onInit = false;
        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
        expect(containsKeyCalled, 0);

        expect(
          await target.containsKey(key: key, options: options),
          isTrue,
        );
        expect(containsKeyCalled, 0);
      }),
    );

    test(
      'containsKey - does not exist, does not exist',
      () => withFfi(() async {
        const key = 'KEY';

        var containsKeyCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'containsKey':
              containsKeyCalled++;
              return false;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        expect(
          await target.containsKey(key: key, options: options),
          isFalse,
        );
        expect(containsKeyCalled, 1);

        expect(
          await target.containsKey(key: key, options: options),
          isFalse,
        );
        expect(containsKeyCalled, 2);
      }),
    );

    test(
      'write - new',
      () async {
        const key = 'KEY';
        const value = 'VALUE';

        var deleteCalled = 0;
        final target = createTarget((call) async {
          if (call.method == 'delete') {
            deleteCalled++;
            return null;
          }

          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: key, value: value, options: options);
        expect(deleteCalled, 1);

        final result = await target.read(key: key, options: options);
        expect(result, value);
        expect(deleteCalled, 2);
      },
    );

    test(
      'write - overwrite',
      () async {
        const key = 'KEY';
        const value1 = 'VALUE1';
        const value2 = 'VALUE2';

        var deleteCalled = 0;
        final target = createTarget((call) async {
          if (call.method == 'delete') {
            deleteCalled++;
            return null;
          }

          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: key, value: value1, options: options);
        expect(deleteCalled, 1);
        await target.write(key: key, value: value2, options: options);
        expect(deleteCalled, 2);

        final result = await target.read(key: key, options: options);
        expect(result, value2);
        expect(deleteCalled, 3);
      },
    );

    test(
      'delete - exists, any',
      () => withFfi(() async {
        const key = 'KEY';
        const newValue = 'VALUE1';

        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        await target.write(key: key, value: newValue, options: options);
        expect(deleteCalled, 1);
        await target.delete(key: key, options: options);
        expect(deleteCalled, 2);
      }),
    );

    test(
      'delete - does not exist, any',
      () => withFfi(() async {
        var deleteCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'delete':
              deleteCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        await target.delete(key: 'KEY', options: options);
        expect(deleteCalled, 1);
      }),
    );

    test(
      'deleteAll - empty, any',
      () => withFfi(() async {
        var deleteAllCalled = 0;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            default:
              fail('Unexpected method call: ${call.method}');
          }
        });
        final options = createOptions();
        await target.deleteAll(options: options);
        expect(deleteAllCalled, 1);
      }),
    );
    test(
      'deleteAll - 1 entry, any',
      () => withFfi(() async {
        const key = 'KEY';
        const newValue = 'VALUE1';

        var deleteAllCalled = 0;
        var onInit = true;
        final target = createTarget((call) async {
          switch (call.method) {
            case 'deleteAll':
              deleteAllCalled++;
              return null;
            case 'delete':
              if (onInit) {
                return null;
              }
              break;
          }
          fail('Unexpected method call: ${call.method}');
        });
        final options = createOptions();
        await target.write(key: key, value: newValue, options: options);
        onInit = false;
        await target.deleteAll(options: options);
        expect(deleteAllCalled, 1);
      }),
    );
  });

  group('Stub does not work at all', () {
    test(
      'constructor',
      () async {
        expect(
          () => stub.FlutterSecureStorageWindows(),
          throwsAssertionError,
        );
      },
    );
  });

  group('Special charactors handling', () {
    FlutterSecureStoragePlatform createTarget() {
      TestWidgetsFlutterBinding.instance.defaultBinaryMessenger
          .setMockMethodCallHandler(
        const MethodChannel('plugins.it_nomads.com/flutter_secure_storage'),
        (methodCall) async {
          switch (methodCall.method) {
            case 'read':
              return null;
            case 'readAll':
              return <String, String>{};
            case 'containsKey':
              return false;
            case 'write':
              fail('write on MethodChanel causes error for special chars.');
            case 'delete':
            case 'deleteAll':
              return null;
            default:
              fail('Unexpected method call: $methodCall');
          }
        },
      );
      return ffi.FlutterSecureStorageWindows();
    }

    Map<String, String> createOptions() => {'useBackwardCompatibility': 'true'};

    Future<void> testSpecialCharactor(
      String key, {
      String? value,
    }) async {
      final target = createTarget();
      final options = createOptions();

      final realValue = value ?? DateTime.now().toIso8601String();

      await target.write(key: key, value: realValue, options: options);

      expect(await target.containsKey(key: key, options: options), isTrue);
      expect(await target.read(key: key, options: options), realValue);
      expect(await target.readAll(options: options), {key: realValue});
      await target.delete(key: key, options: options);
      expect(await target.containsKey(key: key, options: options), isFalse);
      expect(await target.read(key: key, options: options), isNull);
      expect(await target.readAll(options: options), isEmpty);

      await target.write(key: '$key#1', value: realValue, options: options);
      await target.write(key: '$key#2', value: realValue, options: options);

      expect(
        await target.containsKey(key: '$key#1', options: options),
        isTrue,
      );
      expect(
        await target.containsKey(key: '$key#2', options: options),
        isTrue,
      );
      await target.deleteAll(options: options);

      expect(
        await target.containsKey(key: '$key#1', options: options),
        isFalse,
      );
      expect(
        await target.containsKey(key: '$key#2', options: options),
        isFalse,
      );
    }

    test('URL', () => testSpecialCharactor('http://example.com'));
    test(
      'Long key',
      () => testSpecialCharactor(
        String.fromCharCodes(Iterable.generate(256, (_) => 65 /* 'A' */)),
      ),
    );
    test(
      'Empty key & value',
      () => testSpecialCharactor('', value: ''),
    );

    test('Only casing is differ', () async {
      final target = createTarget();
      final options = createOptions();
      const key1 = 'KEY';
      const key2 = 'key';
      const value1 = 'Value1';
      const value2 = 'Value2';

      await target.write(key: key1, value: value1, options: options);
      await target.write(key: key2, value: value2, options: options);
      final results = await target.readAll(options: options);
      expect(results.length, 2);
      expect(results[key1], value1);
      expect(results[key2], value2);

      expect(await target.read(key: key1, options: options), value1);
      expect(await target.read(key: key2, options: options), value2);
      expect(await target.containsKey(key: key1, options: options), isTrue);
      expect(await target.containsKey(key: key2, options: options), isTrue);

      await target.delete(key: key1, options: options);
      expect(await target.read(key: key1, options: options), isNull);
      expect(await target.read(key: key2, options: options), value2);
      expect(await target.containsKey(key: key1, options: options), isFalse);
      expect(await target.containsKey(key: key2, options: options), isTrue);

      await target.write(key: key2, value: value2, options: options);
      await target.deleteAll(options: options);
      expect(await target.read(key: key1, options: options), isNull);
      expect(await target.read(key: key2, options: options), isNull);
      expect(await target.containsKey(key: key1, options: options), isFalse);
      expect(await target.containsKey(key: key2, options: options), isFalse);
    });
  });
}

bool canTest() {
  if (!Platform.isWindows) {
    markTestSkipped('This test must be run on Windows.');
    return false;
  }

  return true;
}

FutureOr<void> withFfi(
  FutureOr<void> Function() test,
) async {
  if (!canTest()) {
    return;
  }

  await test();
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mime/mime.dart';
import 'package:video_player/video_player.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Image Picker Demo',
      home: MyHomePage(title: 'Image Picker Example'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, this.title});

  final String? title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<XFile>? _mediaFileList;

  // This must be called from within a setState() callback
  void _setImageFileListFromFile(XFile? value) {
    _mediaFileList = value == null ? null : <XFile>[value];
  }

  dynamic _pickImageError;
  bool _isVideo = false;

  VideoPlayerController? _controller;
  VideoPlayerController? _toBeDisposed;
  String? _retrieveDataError;

  final ImagePickerPlatform _picker = ImagePickerPlatform.instance;
  final TextEditingController maxWidthController = TextEditingController();
  final TextEditingController maxHeightController = TextEditingController();
  final TextEditingController qualityController = TextEditingController();

  Future<void> _playVideo(XFile? file) async {
    if (file != null && mounted) {
      await _disposeVideoController();
      final VideoPlayerController controller =
          VideoPlayerController.file(File(file.path));
      _controller = controller;
      await controller.setVolume(1.0);
      await controller.initialize();
      await controller.setLooping(true);
      await controller.play();
      setState(() {});
    }
  }

  Future<void> _onImageButtonPressed(
    ImageSource source, {
    required BuildContext context,
    bool allowMultiple = false,
    bool isMedia = false,
  }) async {
    if (_controller != null) {
      await _controller!.setVolume(0.0);
    }
    if (context.mounted) {
      if (_isVideo) {
        final List<XFile> files;
        if (allowMultiple) {
          files = await _picker.getMultiVideoWithOptions();
        } else {
          final XFile? file = await _picker.getVideo(
              source: source, maxDuration: const Duration(seconds: 10));
          files = <XFile>[if (file != null) file];
        }
        if (files.isNotEmpty && context.mounted) {
          _showPickedSnackBar(context, files);
          // Just play the first file, to keep the example simple.
          await _playVideo(files.first);
        }
      } else if (allowMultiple) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final ImageOptions imageOptions = ImageOptions(
              maxWidth: maxWidth,
              maxHeight: maxHeight,
              imageQuality: quality,
            );
            final List<XFile> pickedFileList = isMedia
                ? await _picker.getMedia(
                    options: MediaOptions(
                      allowMultiple: allowMultiple,
                      imageOptions: imageOptions,
                    ),
                  )
                : await _picker.getMultiImageWithOptions(
                    options: MultiImagePickerOptions(
                      imageOptions: imageOptions,
                    ),
                  );
            if (pickedFileList.isNotEmpty && context.mounted) {
              _showPickedSnackBar(context, pickedFileList);
            }
            setState(() {
              _mediaFileList = pickedFileList;
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      } else if (isMedia) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = <XFile>[];
            final XFile? media = _firstOrNull(await _picker.getMedia(
              options: MediaOptions(
                  allowMultiple: allowMultiple,
                  imageOptions: ImageOptions(
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    imageQuality: quality,
                  )),
            ));

            if (media != null) {
              pickedFileList.add(media);
              setState(() {
                _mediaFileList = pickedFileList;
              });
            }
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      } else {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final XFile? pickedFile = await _picker.getImageFromSource(
              source: source,
              options: ImagePickerOptions(
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                imageQuality: quality,
              ),
            );
            if (pickedFile != null && context.mounted) {
              _showPickedSnackBar(context, <XFile>[pickedFile]);
            }
            setState(() => _setImageFileListFromFile(pickedFile));
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      }
    }
  }

  @override
  void deactivate() {
    if (_controller != null) {
      _controller!.setVolume(0.0);
      _controller!.pause();
    }
    super.deactivate();
  }

  @override
  void dispose() {
    _disposeVideoController();
    maxWidthController.dispose();
    maxHeightController.dispose();
    qualityController.dispose();
    super.dispose();
  }

  Future<void> _disposeVideoController() async {
    if (_toBeDisposed != null) {
      await _toBeDisposed!.dispose();
    }
    _toBeDisposed = _controller;
    _controller = null;
  }

  Widget _previewVideo() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_controller == null) {
      return const Text(
        'You have not yet picked a video',
        textAlign: TextAlign.center,
      );
    }
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: AspectRatioVideo(_controller),
    );
  }

  Widget _previewImages() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_mediaFileList != null) {
      return Semantics(
        label: 'image_picker_example_picked_images',
        child: ListView.builder(
          key: UniqueKey(),
          itemBuilder: (BuildContext context, int index) {
            final XFile image = _mediaFileList![index];
            final String? mime = lookupMimeType(_mediaFileList![index].path);
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                Text(image.name,
                    key: const Key('image_picker_example_picked_image_name')),
                Semantics(
                  label: 'image_picker_example_picked_image',
                  child: mime == null || mime.startsWith('image/')
                      ? Image.file(
                          File(_mediaFileList![index].path),
                          errorBuilder: (BuildContext context, Object error,
                              StackTrace? stackTrace) {
                            return const Center(
                                child:
                                    Text('This image type is not supported'));
                          },
                        )
                      : _buildInlineVideoPlayer(index),
                ),
              ],
            );
          },
          itemCount: _mediaFileList!.length,
        ),
      );
    } else if (_pickImageError != null) {
      return Text(
        'Pick image error: $_pickImageError',
        textAlign: TextAlign.center,
      );
    } else {
      return const Text(
        'You have not yet picked an image.',
        textAlign: TextAlign.center,
      );
    }
  }

  Widget _buildInlineVideoPlayer(int index) {
    final VideoPlayerController controller =
        VideoPlayerController.file(File(_mediaFileList![index].path));
    controller.setVolume(1.0);
    controller.initialize();
    controller.setLooping(true);
    controller.play();
    return Center(child: AspectRatioVideo(controller));
  }

  Widget _handlePreview() {
    if (_isVideo) {
      return _previewVideo();
    } else {
      return _previewImages();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title!),
      ),
      body: Align(
        alignment: Alignment.topCenter,
        child: _handlePreview(),
      ),
      floatingActionButton: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: <Widget>[
          Semantics(
            label: 'image_picker_example_from_gallery',
            child: FloatingActionButton.extended(
              key: const Key('image_picker_example_from_gallery'),
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'image0',
              tooltip: 'Pick image from gallery',
              label: const Text('Pick image from gallery'),
              icon: const Icon(Icons.photo),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                );
              },
              heroTag: 'image1',
              tooltip: 'Pick multiple images',
              label: const Text('Pick multiple images'),
              icon: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMedia: true,
                );
              },
              heroTag: 'media',
              tooltip: 'Pick item from gallery',
              label: const Text('Pick item from gallery'),
              icon: const Icon(Icons.photo_outlined),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  allowMultiple: true,
                  isMedia: true,
                );
              },
              heroTag: 'multipleMedia',
              tooltip: 'Pick multiple items',
              label: const Text('Pick multiple items'),
              icon: const Icon(Icons.photo_library_outlined),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                onPressed: () {
                  _isVideo = false;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'image2',
                tooltip: 'Take a photo',
                label: const Text('Take a photo'),
                icon: const Icon(Icons.camera_alt),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'video',
              tooltip: 'Pick video from gallery',
              label: const Text('Pick video from gallery'),
              icon: const Icon(Icons.video_file),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton.extended(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery,
                    context: context, allowMultiple: true);
              },
              heroTag: 'multiVideo',
              tooltip: 'Pick multiple videos',
              label: const Text('Pick multiple videos'),
              icon: const Icon(Icons.video_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton.extended(
                backgroundColor: Colors.red,
                onPressed: () {
                  _isVideo = true;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'takeVideo',
                tooltip: 'Take a video',
                label: const Text('Take a video'),
                icon: const Icon(Icons.videocam),
              ),
            ),
        ],
      ),
    );
  }

  Text? _getRetrieveErrorWidget() {
    if (_retrieveDataError != null) {
      final Text result = Text(_retrieveDataError!);
      _retrieveDataError = null;
      return result;
    }
    return null;
  }

  Future<void> _displayPickImageDialog(
      BuildContext context, OnPickImageCallback onPick) async {
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('Add optional parameters'),
            content: Column(
              children: <Widget>[
                TextField(
                  controller: maxWidthController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxWidth if desired'),
                ),
                TextField(
                  controller: maxHeightController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxHeight if desired'),
                ),
                TextField(
                  controller: qualityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                      hintText: 'Enter quality if desired'),
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('CANCEL'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                  child: const Text('PICK'),
                  onPressed: () {
                    final double? width = maxWidthController.text.isNotEmpty
                        ? double.parse(maxWidthController.text)
                        : null;
                    final double? height = maxHeightController.text.isNotEmpty
                        ? double.parse(maxHeightController.text)
                        : null;
                    final int? quality = qualityController.text.isNotEmpty
                        ? int.parse(qualityController.text)
                        : null;
                    onPick(width, height, quality);
                    Navigator.of(context).pop();
                  }),
            ],
          );
        });
  }

  void _showPickedSnackBar(BuildContext context, List<XFile> files) {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text('Picked: ${files.map((XFile it) => it.name).join(',')}'),
      duration: const Duration(seconds: 2),
    ));
  }
}

typedef OnPickImageCallback = void Function(
    double? maxWidth, double? maxHeight, int? quality);

class AspectRatioVideo extends StatefulWidget {
  const AspectRatioVideo(this.controller, {super.key});

  final VideoPlayerController? controller;

  @override
  AspectRatioVideoState createState() => AspectRatioVideoState();
}

class AspectRatioVideoState extends State<AspectRatioVideo> {
  VideoPlayerController? get controller => widget.controller;
  bool initialized = false;

  void _onVideoControllerUpdate() {
    if (!mounted) {
      return;
    }
    if (initialized != controller!.value.isInitialized) {
      initialized = controller!.value.isInitialized;
      setState(() {});
    }
  }

  @override
  void initState() {
    super.initState();
    controller!.addListener(_onVideoControllerUpdate);
  }

  @override
  void dispose() {
    controller!.removeListener(_onVideoControllerUpdate);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (initialized) {
      return Center(
        child: AspectRatio(
          aspectRatio: controller!.value.aspectRatio,
          child: VideoPlayer(controller!),
        ),
      );
    } else {
      return Container();
    }
  }
}

T? _firstOrNull<T>(List<T> list) {
  return list.isEmpty ? null : list.first;
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\lib\image_picker_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

/// The Windows implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// Windows.
class ImagePickerWindows extends CameraDelegatingImagePickerPlatform {
  /// Constructs a ImagePickerWindows.
  ImagePickerWindows();

  /// List of image extensions used when picking images
  @visibleForTesting
  static const List<String> imageFormats = <String>[
    'jpg',
    'jpeg',
    'png',
    'bmp',
    'webp',
    'gif',
    'tif',
    'tiff',
    'apng'
  ];

  /// List of video extensions used when picking videos
  @visibleForTesting
  static const List<String> videoFormats = <String>[
    'mov',
    'wmv',
    'mkv',
    'mp4',
    'webm',
    'avi',
    'mpeg',
    'mpg'
  ];

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorWindows();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerWindows();
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are not currently supported. If any
  // of its fields are set, they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Images', extensions: imageFormats);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Videos', extensions: videoFormats);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Images', extensions: imageFormats);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  @override
  Future<List<XFile>> getMultiVideoWithOptions(
      {MultiVideoPickerOptions options =
          const MultiVideoPickerOptions()}) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Videos', extensions: videoFormats);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not
  // supported on Windows. If any of these arguments is supplied,
  // they will be silently ignored by the Windows version of the plugin.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    const XTypeGroup typeGroup = XTypeGroup(
        label: 'images and videos',
        extensions: <String>[...imageFormats, ...videoFormats]);

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\test\image_picker_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'image_picker_windows_test.mocks.dart';

@GenerateMocks(<Type>[FileSelectorPlatform])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Returns the captured type groups from a mock call result, assuming that
  // exactly one call was made and only the type groups were captured.
  List<XTypeGroup> capturedTypeGroups(VerificationResult result) {
    return result.captured.single as List<XTypeGroup>;
  }

  group('ImagePickerWindows', () {
    late ImagePickerWindows plugin;
    late MockFileSelectorPlatform mockFileSelectorPlatform;

    setUp(() {
      plugin = ImagePickerWindows();
      mockFileSelectorPlatform = MockFileSelectorPlatform();

      when(mockFileSelectorPlatform.openFile(
              acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
          .thenAnswer((_) async => null);

      when(mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
          .thenAnswer((_) async => List<XFile>.empty());

      ImagePickerWindows.fileSelector = mockFileSelectorPlatform;
    });

    test('registered instance', () {
      ImagePickerWindows.registerWith();
      expect(ImagePickerPlatform.instance, isA<ImagePickerWindows>());
    });

    group('images', () {
      test('pickImage passes the accepted type groups correctly', () async {
        await plugin.pickImage(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test('getImage passes the accepted type groups correctly', () async {
        await plugin.getImage(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test('getMultiImage passes the accepted type groups correctly', () async {
        await plugin.getMultiImage();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test(
          'getImageFromSource throws StateError when source is camera with no delegate',
          () async {
        await expectLater(plugin.getImageFromSource(source: ImageSource.camera),
            throwsStateError);
      });

      test('getMultiImage passes the accepted type groups correctly', () async {
        await plugin.getMultiImage();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });
    });

    group('videos', () {
      test('pickVideo passes the accepted type groups correctly', () async {
        await plugin.pickVideo(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });

      test('getVideo passes the accepted type groups correctly', () async {
        await plugin.getVideo(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });

      test('getVideo calls delegate when source is camera', () async {
        const String fakePath = '/tmp/foo';
        plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
        expect((await plugin.getVideo(source: ImageSource.camera))!.path,
            fakePath);
      });

      test('getVideo throws StateError when source is camera with no delegate',
          () async {
        await expectLater(
            plugin.getVideo(source: ImageSource.camera), throwsStateError);
      });

      test('getMultiVideoWithOptions passes the accepted type groups correctly',
          () async {
        await plugin.getMultiVideoWithOptions();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });
    });

    group('media', () {
      test('getMedia passes the accepted type groups correctly', () async {
        await plugin.getMedia(options: const MediaOptions(allowMultiple: true));

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions, <String>[
          ...ImagePickerWindows.imageFormats,
          ...ImagePickerWindows.videoFormats
        ]);
      });

      test('multiple media handles an empty path response gracefully',
          () async {
        expect(
            await plugin.getMedia(
              options: const MediaOptions(
                allowMultiple: true,
              ),
            ),
            <String>[]);
      });

      test('single media handles an empty path response gracefully', () async {
        expect(
            await plugin.getMedia(
              options: const MediaOptions(
                allowMultiple: false,
              ),
            ),
            <String>[]);
      });
    });
  });
}

class FakeCameraDelegate extends ImagePickerCameraDelegate {
  FakeCameraDelegate({this.result});

  XFile? result;

  @override
  Future<XFile?> takePhoto(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }

  @override
  Future<XFile?> takeVideo(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\image_picker_windows\test\image_picker_windows_test.mocks.dart =====
// Mocks generated by Mockito 5.4.4 from annotations
// in image_picker_windows/test/image_picker_windows_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [FileSelectorPlatform].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSelectorPlatform extends _i1.Mock
    implements _i2.FileSelectorPlatform {
  MockFileSelectorPlatform() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i2.XFile?> openFile({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFile,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<_i2.XFile?>.value(),
      ) as _i3.Future<_i2.XFile?>);

  @override
  _i3.Future<List<_i2.XFile>> openFiles({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFiles,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<_i2.XFile>>.value(<_i2.XFile>[]),
      ) as _i3.Future<List<_i2.XFile>>);

  @override
  _i3.Future<String?> getSavePath({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSavePath,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #suggestedName: suggestedName,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<_i2.FileSaveLocation?> getSaveLocation({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    _i2.SaveDialogOptions? options = const _i2.SaveDialogOptions(),
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSaveLocation,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #options: options,
          },
        ),
        returnValue: _i3.Future<_i2.FileSaveLocation?>.value(),
      ) as _i3.Future<_i2.FileSaveLocation?>);

  @override
  _i3.Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPath,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);

  @override
  _i3.Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPaths,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<String>>.value(<String>[]),
      ) as _i3.Future<List<String>>);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\integration_test\path_provider_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });

  testWidgets('getDownloadsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloads');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  String? _cacheDirectory = 'Unknown';

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? documentsDirectory;
    String? cacheDirectory;
    final PathProviderWindows provider = PathProviderWindows();

    try {
      tempDirectory = await provider.getTemporaryPath();
    } catch (exception) {
      tempDirectory = 'Failed to get temp directory: $exception';
    }
    try {
      downloadsDirectory = await provider.getDownloadsPath();
    } catch (exception) {
      downloadsDirectory = 'Failed to get downloads directory: $exception';
    }

    try {
      documentsDirectory = await provider.getApplicationDocumentsPath();
    } catch (exception) {
      documentsDirectory = 'Failed to get documents directory: $exception';
    }

    try {
      appSupportDirectory = await provider.getApplicationSupportPath();
    } catch (exception) {
      appSupportDirectory = 'Failed to get app support directory: $exception';
    }

    try {
      cacheDirectory = await provider.getApplicationCachePath();
    } catch (exception) {
      cacheDirectory = 'Failed to get cache directory: $exception';
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _documentsDirectory = documentsDirectory;
      _cacheDirectory = cacheDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Cache Directory: $_cacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\folders.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: non_constant_identifier_names

// ignore: avoid_classes_with_only_static_members
/// A class containing the GUID references for each of the documented Windows
/// known folders. A property of this class may be passed to the `getPath`
/// method in the [PathProvidersWindows] class to retrieve a known folder from
/// Windows.
// These constants come from
// https://learn.microsoft.com/windows/win32/shell/knownfolderid
class WindowsKnownFolder {
  /// The file system directory that is used to store administrative tools for
  /// an individual user. The MMC will save customized consoles to this
  /// directory, and it will roam with the user.
  static String get AdminTools => '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}';

  /// The file system directory that acts as a staging area for files waiting to
  /// be written to a CD. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data\Microsoft\CD Burning.
  static String get CDBurning => '{9E52AB10-F80D-49DF-ACB8-4330F5687855}';

  /// The file system directory that contains administrative tools for all users
  /// of the computer.
  static String get CommonAdminTools =>
      '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}';

  /// The file system directory that contains the directories for the common
  /// program groups that appear on the Start menu for all users. A typical path
  /// is C:\Documents and Settings\All Users\Start Menu\Programs.
  static String get CommonPrograms => '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}';

  /// The file system directory that contains the programs and folders that
  /// appear on the Start menu for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu.
  static String get CommonStartMenu => '{A4115719-D62E-491D-AA7C-E74B8BE3B067}';

  /// The file system directory that contains the programs that appear in the
  /// Startup folder for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu\Programs\Startup.
  static String get CommonStartup => '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}';

  /// The file system directory that contains the templates that are available
  /// to all users. A typical path is C:\Documents and Settings\All
  /// Users\Templates.
  static String get CommonTemplates => '{B94237E7-57AC-4347-9151-B08C6C32D1F7}';

  /// The virtual folder that represents My Computer, containing everything on
  /// the local computer: storage devices, printers, and Control Panel. The
  /// folder can also contain mapped network drives.
  static String get ComputerFolder => '{0AC0837C-BBF8-452A-850D-79D08E667CA7}';

  /// The virtual folder that represents Network Connections, that contains
  /// network and dial-up connections.
  static String get ConnectionsFolder =>
      '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}';

  /// The virtual folder that contains icons for the Control Panel applications.
  static String get ControlPanelFolder =>
      '{82A74AEB-AEB4-465C-A014-D097EE346D63}';

  /// The file system directory that serves as a common repository for Internet
  /// cookies. A typical path is C:\Documents and Settings\username\Cookies.
  static String get Cookies => '{2B0F765D-C0E9-4171-908E-08A611B84FF6}';

  /// The virtual folder that represents the Windows desktop, the root of the
  /// namespace.
  static String get Desktop => '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}';

  /// The virtual folder that represents the My Documents desktop item.
  static String get Documents => '{FDD39AD0-238F-46AF-ADB4-6C85480369C7}';

  /// The file system directory that serves as a repository for Internet
  /// downloads.
  static String get Downloads => '{374DE290-123F-4565-9164-39C4925E467B}';

  /// The file system directory that serves as a common repository for the
  /// user's favorite items. A typical path is C:\Documents and
  /// Settings\username\Favorites.
  static String get Favorites => '{1777F761-68AD-4D8A-87BD-30B759FA33DD}';

  /// A virtual folder that contains fonts. A typical path is C:\Windows\Fonts.
  static String get Fonts => '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}';

  /// The file system directory that serves as a common repository for Internet
  /// history items.
  static String get History => '{D9DC8A3B-B784-432E-A781-5A1130A75963}';

  /// The file system directory that serves as a common repository for temporary
  /// Internet files. A typical path is C:\Documents and Settings\username\Local
  /// Settings\Temporary Internet Files.
  static String get InternetCache => '{352481E8-33BE-4251-BA85-6007CAEDCF9D}';

  /// A virtual folder for Internet Explorer.
  static String get InternetFolder => '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}';

  /// The file system directory that serves as a data repository for local
  /// (nonroaming) applications. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data.
  static String get LocalAppData => '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}';

  /// The file system directory that serves as a common repository for music
  /// files. A typical path is C:\Documents and Settings\User\My Documents\My
  /// Music.
  static String get Music => '{4BD8D571-6D19-48D3-BE97-422220080E43}';

  /// A file system directory that contains the link objects that may exist in
  /// the My Network Places virtual folder. A typical path is C:\Documents and
  /// Settings\username\NetHood.
  static String get NetHood => '{C5ABBF53-E17F-4121-8900-86626FC2C973}';

  /// The folder that represents other computers in your workgroup.
  static String get NetworkFolder => '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}';

  /// The file system directory that serves as a common repository for image
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Pictures.
  static String get Pictures => '{33E28130-4E1E-4676-835A-98395C3BC3BB}';

  /// The file system directory that contains the link objects that can exist in
  /// the Printers virtual folder. A typical path is C:\Documents and
  /// Settings\username\PrintHood.
  static String get PrintHood => '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}';

  /// The virtual folder that contains installed printers.
  static String get PrintersFolder => '{76FC4E2D-D6AD-4519-A663-37BD56068185}';

  /// The user's profile folder. A typical path is C:\Users\username.
  /// Applications should not create files or folders at this level.
  static String get Profile => '{5E6C858F-0E22-4760-9AFE-EA3317B67173}';

  /// The file system directory that contains application data for all users. A
  /// typical path is C:\Documents and Settings\All Users\Application Data. This
  /// folder is used for application data that is not user specific. For
  /// example, an application can store a spell-check dictionary, a database of
  /// clip art, or a log file in the CSIDL_COMMON_APPDATA folder. This
  /// information will not roam and is available to anyone using the computer.
  static String get ProgramData => '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}';

  /// The Program Files folder. A typical path is C:\Program Files.
  static String get ProgramFiles => '{905e63b6-c1bf-494e-b29c-65b732d3d21a}';

  /// The common Program Files folder. A typical path is C:\Program
  /// Files\Common.
  static String get ProgramFilesCommon =>
      '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}';

  /// On 64-bit systems, a link to the common Program Files folder. A typical path is
  /// C:\Program Files\Common Files.
  static String get ProgramFilesCommonX64 =>
      '{6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}';

  /// On 64-bit systems, a link to the 32-bit common Program Files folder. A
  /// typical path is C:\Program Files (x86)\Common Files. On 32-bit systems, a
  /// link to the Common Program Files folder.
  static String get ProgramFilesCommonX86 =>
      '{DE974D24-D9C6-4D3E-BF91-F4455120B917}';

  /// On 64-bit systems, a link to the Program Files folder. A typical path is
  /// C:\Program Files.
  static String get ProgramFilesX64 => '{6D809377-6AF0-444b-8957-A3773F02200E}';

  /// On 64-bit systems, a link to the 32-bit Program Files folder. A typical
  /// path is C:\Program Files (x86). On 32-bit systems, a link to the Common
  /// Program Files folder.
  static String get ProgramFilesX86 => '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}';

  /// The file system directory that contains the user's program groups (which
  /// are themselves file system directories).
  static String get Programs => '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}';

  /// The file system directory that contains files and folders that appear on
  /// the desktop for all users. A typical path is C:\Documents and Settings\All
  /// Users\Desktop.
  static String get PublicDesktop => '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}';

  /// The file system directory that contains documents that are common to all
  /// users. A typical path is C:\Documents and Settings\All Users\Documents.
  static String get PublicDocuments => '{ED4824AF-DCE4-45A8-81E2-FC7965083634}';

  /// The file system directory that serves as a repository for music files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Music.
  static String get PublicMusic => '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}';

  /// The file system directory that serves as a repository for image files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Pictures.
  static String get PublicPictures => '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}';

  /// The file system directory that serves as a repository for video files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Videos.
  static String get PublicVideos => '{2400183A-6185-49FB-A2D8-4A392A602BA3}';

  /// The file system directory that contains shortcuts to the user's most
  /// recently used documents. A typical path is C:\Documents and
  /// Settings\username\My Recent Documents.
  static String get Recent => '{AE50C081-EBD2-438A-8655-8A092E34987A}';

  /// The virtual folder that contains the objects in the user's Recycle Bin.
  static String get RecycleBinFolder =>
      '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}';

  /// The file system directory that contains resource data. A typical path is
  /// C:\Windows\Resources.
  static String get ResourceDir => '{8AD10C31-2ADB-4296-A8F7-E4701232C972}';

  /// The file system directory that serves as a common repository for
  /// application-specific data. A typical path is C:\Documents and
  /// Settings\username\Application Data.
  static String get RoamingAppData => '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}';

  /// The file system directory that contains Send To menu items. A typical path
  /// is C:\Documents and Settings\username\SendTo.
  static String get SendTo => '{8983036C-27C0-404B-8F08-102D10DCFD74}';

  /// The file system directory that contains Start menu items. A typical path
  /// is C:\Documents and Settings\username\Start Menu.
  static String get StartMenu => '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}';

  /// The file system directory that corresponds to the user's Startup program
  /// group. The system starts these programs whenever the associated user logs
  /// on. A typical path is C:\Documents and Settings\username\Start
  /// Menu\Programs\Startup.
  static String get Startup => '{B97D20BB-F46A-4C97-BA10-5E3608430854}';

  /// The Windows System folder. A typical path is C:\Windows\System32.
  static String get System => '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}';

  /// The 32-bit Windows System folder. On 32-bit systems, this is typically
  /// C:\Windows\system32. On 64-bit systems, this is typically
  /// C:\Windows\syswow64.
  static String get SystemX86 => '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}';

  /// The file system directory that serves as a common repository for document
  /// templates. A typical path is C:\Documents and Settings\username\Templates.
  static String get Templates => '{A63293E8-664E-48DB-A079-DF759E0509F7}';

  /// The file system directory that serves as a common repository for video
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Videos.
  static String get Videos => '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}';

  /// The Windows directory or SYSROOT. This corresponds to the %windir% or
  /// %SYSTEMROOT% environment variables. A typical path is C:\Windows.
  static String get Windows => '{F38BF404-1D43-42F2-9305-67DE0B28FC23}';
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\folders_stub.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Stub version of the actual class.
class WindowsKnownFolder {}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\guid.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

/// Representation of the Win32 GUID struct.
// For the layout of this struct, see
// https://learn.microsoft.com/windows/win32/api/guiddef/ns-guiddef-guid
@Packed(4)
base class GUID extends Struct {
  /// Native Data1 field.
  @Uint32()
  external int data1;

  /// Native Data2 field.
  @Uint16()
  external int data2;

  /// Native Data3 field.
  @Uint16()
  external int data3;

  /// Native Data4 field.
  // This should be an eight-element byte array, but there's no such annotation.
  @Uint64()
  external int data4;

  /// Parses a GUID string, with optional enclosing "{}"s and optional "-"s,
  /// into data.
  void parse(String guid) {
    final String hexOnly = guid.replaceAll(RegExp(r'[{}-]'), '');
    if (hexOnly.length != 32) {
      throw ArgumentError.value(guid, 'guid', 'Invalid GUID string');
    }
    final ByteData bytes = ByteData(16);
    for (int i = 0; i < 16; ++i) {
      bytes.setUint8(
          i, int.parse(hexOnly.substring(i * 2, i * 2 + 2), radix: 16));
    }
    data1 = bytes.getInt32(0);
    data2 = bytes.getInt16(4);
    data3 = bytes.getInt16(6);
    // [bytes] is big endian, but the host is little endian, so a default
    // big-endian read would reverse the bytes. Since data4 is supposed to be
    // a byte array, the order should be preserved, so do a little-endian read.
    // https://en.wikipedia.org/wiki/Universally_unique_identifier#Encoding
    data4 = bytes.getInt64(8, Endian.little);
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\path_provider_windows_real.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

import 'folders.dart';
import 'guid.dart';
import 'win32_wrappers.dart';

/// Constant for en-US language used in VersionInfo keys.
@visibleForTesting
const String languageEn = '0409';

/// Constant for CP1252 encoding used in VersionInfo keys
@visibleForTesting
const String encodingCP1252 = '04e4';

/// Constant for Unicode encoding used in VersionInfo keys
@visibleForTesting
const String encodingUnicode = '04b0';

/// Wraps the Win32 VerQueryValue API call.
///
/// This class exists to allow injecting alternate metadata in tests without
/// building multiple custom test binaries.
@visibleForTesting
class VersionInfoQuerier {
  /// Returns the value for [key] in [versionInfo]s in section with given
  /// language and encoding, or null if there is no such entry,
  /// or if versionInfo is null.
  ///
  /// See https://docs.microsoft.com/windows/win32/menurc/versioninfo-resource
  /// for list of possible language and encoding values.
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    assert(language.isNotEmpty);
    assert(encoding.isNotEmpty);
    if (versionInfo == null) {
      return null;
    }
    final Pointer<Utf16> keyPath =
        '\\StringFileInfo\\$language$encoding\\$key'.toNativeUtf16();
    final Pointer<UINT> length = calloc<UINT>();
    final Pointer<Pointer<Utf16>> valueAddress = calloc<Pointer<Utf16>>();
    try {
      if (VerQueryValue(versionInfo, keyPath, valueAddress, length) == 0) {
        return null;
      }
      return valueAddress.value.toDartString();
    } finally {
      calloc.free(keyPath);
      calloc.free(length);
      calloc.free(valueAddress);
    }
  }
}

/// The Windows implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Windows.
class PathProviderWindows extends PathProviderPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// The object to use for performing VerQueryValue calls.
  @visibleForTesting
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// This is typically the same as the TMP environment variable.
  @override
  Future<String?> getTemporaryPath() async {
    final Pointer<Utf16> buffer = calloc<Uint16>(MAX_PATH + 1).cast<Utf16>();
    String path;

    try {
      final int length = GetTempPath(MAX_PATH, buffer);

      if (length == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      } else {
        path = buffer.toDartString();

        // GetTempPath adds a trailing backslash, but SHGetKnownFolderPath does
        // not. Strip off trailing backslash for consistency with other methods
        // here.
        if (path.endsWith(r'\')) {
          path = path.substring(0, path.length - 1);
        }
      }

      // Ensure that the directory exists, since GetTempPath doesn't.
      final Directory directory = Directory(path);
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }

      return path;
    } finally {
      calloc.free(buffer);
    }
  }

  @override
  Future<String?> getApplicationSupportPath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.RoamingAppData);

  @override
  Future<String?> getApplicationDocumentsPath() =>
      getPath(WindowsKnownFolder.Documents);

  @override
  Future<String?> getApplicationCachePath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.LocalAppData);

  @override
  Future<String?> getDownloadsPath() => getPath(WindowsKnownFolder.Downloads);

  /// Retrieve any known folder from Windows.
  ///
  /// folderID is a GUID that represents a specific known folder ID, drawn from
  /// [WindowsKnownFolder].
  Future<String?> getPath(String folderID) {
    final Pointer<Pointer<Utf16>> pathPtrPtr = calloc<Pointer<Utf16>>();
    final Pointer<GUID> knownFolderID = calloc<GUID>()..ref.parse(folderID);

    try {
      final int hr = SHGetKnownFolderPath(
        knownFolderID,
        KF_FLAG_DEFAULT,
        NULL,
        pathPtrPtr,
      );

      if (FAILED(hr)) {
        if (hr == E_INVALIDARG || hr == E_FAIL) {
          throw _createWin32Exception(hr);
        }
        return Future<String?>.value();
      }

      final String path = pathPtrPtr.value.toDartString();
      return Future<String>.value(path);
    } finally {
      calloc.free(pathPtrPtr);
      calloc.free(knownFolderID);
    }
  }

  String? _getStringValue(Pointer<Uint8>? infoBuffer, String key) =>
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingCP1252) ??
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingUnicode);

  /// Returns the relative path string to append to the root directory returned
  /// by Win32 APIs for application storage (such as RoamingAppDir) to get a
  /// directory that is unique to the application.
  ///
  /// The convention is to use company-name\product-name\. This will use that if
  /// possible, using the data in the VERSIONINFO resource, with the following
  /// fallbacks:
  /// - If the company name isn't there, that component will be dropped.
  /// - If the product name isn't there, it will use the exe's filename (without
  ///   extension).
  String _getApplicationSpecificSubdirectory() {
    String? companyName;
    String? productName;

    final Pointer<Utf16> moduleNameBuffer =
        calloc<WCHAR>(MAX_PATH + 1).cast<Utf16>();
    final Pointer<DWORD> unused = calloc<DWORD>();
    Pointer<BYTE>? infoBuffer;
    try {
      // Get the module name.
      final int moduleNameLength =
          GetModuleFileName(0, moduleNameBuffer, MAX_PATH);
      if (moduleNameLength == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      }

      // From that, load the VERSIONINFO resource
      final int infoSize = GetFileVersionInfoSize(moduleNameBuffer, unused);
      if (infoSize != 0) {
        infoBuffer = calloc<BYTE>(infoSize);
        if (GetFileVersionInfo(moduleNameBuffer, 0, infoSize, infoBuffer) ==
            0) {
          calloc.free(infoBuffer);
          infoBuffer = null;
        }
      }
      companyName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'CompanyName'));
      productName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'ProductName'));

      // If there was no product name, use the executable name.
      productName ??=
          path.basenameWithoutExtension(moduleNameBuffer.toDartString());

      return companyName != null
          ? path.join(companyName, productName)
          : productName;
    } finally {
      calloc.free(moduleNameBuffer);
      calloc.free(unused);
      if (infoBuffer != null) {
        calloc.free(infoBuffer);
      }
    }
  }

  /// Makes [rawString] safe as a directory component. See
  /// https://docs.microsoft.com/windows/win32/fileio/naming-a-file#naming-conventions
  ///
  /// If after sanitizing the string is empty, returns null.
  String? _sanitizedDirectoryName(String? rawString) {
    if (rawString == null) {
      return null;
    }
    String sanitized = rawString
        // Replace banned characters.
        .replaceAll(RegExp(r'[<>:"/\\|?*]'), '_')
        // Remove trailing whitespace.
        .trimRight()
        // Ensure that it does not end with a '.'.
        .replaceAll(RegExp(r'[.]+$'), '');
    const int kMaxComponentLength = 255;
    if (sanitized.length > kMaxComponentLength) {
      sanitized = sanitized.substring(0, kMaxComponentLength);
    }
    return sanitized.isEmpty ? null : sanitized;
  }

  Future<String?> _createApplicationSubdirectory(String folderId) async {
    final String? baseDir = await getPath(folderId);
    if (baseDir == null) {
      return null;
    }
    final Directory directory =
        Directory(path.join(baseDir, _getApplicationSpecificSubdirectory()));
    // Ensure that the directory exists if possible, since it will on other
    // platforms. If the name is longer than MAXPATH, creating will fail, so
    // skip that step; it's up to the client to decide what to do with the path
    // in that case (e.g., using a short path).
    if (directory.path.length <= MAX_PATH) {
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }
    }
    return directory.path;
  }
}

Exception _createWin32Exception(int errorCode) {
  return PlatformException(
      code: 'Win32 Error',
      // TODO(stuartmorgan): Consider getting the system error message via
      // FormatMessage if it turns out to be necessary for debugging issues.
      // Plugin-client-level usability isn't a major consideration since per
      // https://github.com/flutter/flutter/blob/master/docs/ecosystem/contributing/README.md#platform-exception-handling
      // any case that comes up in practice should be handled and returned
      // via a plugin-specific exception, not this fallback.
      message: 'Error code 0x${errorCode.toRadixString(16)}');
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\path_provider_windows_stub.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// A stub implementation to satisfy compilation of multi-platform packages that
/// depend on path_provider_windows. This should never actually be created.
///
/// Notably, because path_provider needs to manually register
/// path_provider_windows, anything with a transitive dependency on
/// path_provider will also depend on path_provider_windows, not just at the
/// pubspec level but the code level.
class PathProviderWindows extends PathProviderPlatform {
  /// Errors on attempted instantiation of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be created.
  PathProviderWindows() : assert(false);

  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// Stub; see comment on VersionInfoQuerier.
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// Match PathProviderWindows so that the analyzer won't report invalid
  /// overrides if tests provide fake PathProviderWindows implementations.
  Future<String> getPath(String folderID) async => '';
}

/// Stub to satisfy the analyzer, which doesn't seem to handle conditional
/// exports correctly.
class VersionInfoQuerier {}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\src\win32_wrappers.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The types and functions here correspond directly to corresponding Windows
// types and functions, so the Windows docs are the definitive source of
// documentation.
// ignore_for_file: public_member_api_docs

import 'dart:ffi';

import 'package:ffi/ffi.dart';

import 'guid.dart';

typedef BOOL = Int32;
typedef BYTE = Uint8;
typedef DWORD = Uint32;
typedef UINT = Uint32;
typedef HANDLE = IntPtr;
typedef HMODULE = HANDLE;
typedef HRESULT = Int32;
typedef LPCVOID = Pointer<NativeType>;
typedef LPCWSTR = Pointer<Utf16>;
typedef LPDWORD = Pointer<DWORD>;
typedef LPWSTR = Pointer<Utf16>;
typedef LPVOID = Pointer<NativeType>;
typedef PUINT = Pointer<UINT>;
typedef PWSTR = Pointer<Pointer<Utf16>>;
typedef WCHAR = Uint16;

const int NULL = 0;

// https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry
const int MAX_PATH = 260;

// https://learn.microsoft.com/windows/win32/seccrypto/common-hresult-values
// ignore: non_constant_identifier_names
final int E_FAIL = 0x80004005.toSigned(32);
// ignore: non_constant_identifier_names
final int E_INVALIDARG = 0x80070057.toSigned(32);

// https://learn.microsoft.com/windows/win32/api/winerror/nf-winerror-failed#remarks
// ignore: non_constant_identifier_names
bool FAILED(int hr) => hr < 0;

// https://learn.microsoft.com/windows/win32/api/shlobj_core/ne-shlobj_core-known_folder_flag
const int KF_FLAG_DEFAULT = 0x00000000;

final DynamicLibrary _dllKernel32 = DynamicLibrary.open('kernel32.dll');
final DynamicLibrary _dllVersion = DynamicLibrary.open('version.dll');
final DynamicLibrary _dllShell32 = DynamicLibrary.open('shell32.dll');

// https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath
typedef _FFITypeSHGetKnownFolderPath = HRESULT Function(
    Pointer<GUID>, DWORD, HANDLE, PWSTR);
typedef FFITypeSHGetKnownFolderPathDart = int Function(
    Pointer<GUID>, int, int, Pointer<Pointer<Utf16>>);
// ignore: non_constant_identifier_names
final FFITypeSHGetKnownFolderPathDart SHGetKnownFolderPath =
    _dllShell32.lookupFunction<_FFITypeSHGetKnownFolderPath,
        FFITypeSHGetKnownFolderPathDart>('SHGetKnownFolderPath');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfow
typedef _FFITypeGetFileVersionInfoW = BOOL Function(
    LPCWSTR, DWORD, DWORD, LPVOID);
typedef FFITypeGetFileVersionInfoW = int Function(
    Pointer<Utf16>, int, int, Pointer<NativeType>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoW GetFileVersionInfo = _dllVersion
    .lookupFunction<_FFITypeGetFileVersionInfoW, FFITypeGetFileVersionInfoW>(
        'GetFileVersionInfoW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizew
typedef _FFITypeGetFileVersionInfoSizeW = DWORD Function(LPCWSTR, LPDWORD);
typedef FFITypeGetFileVersionInfoSizeW = int Function(
    Pointer<Utf16>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoSizeW GetFileVersionInfoSize =
    _dllVersion.lookupFunction<_FFITypeGetFileVersionInfoSizeW,
        FFITypeGetFileVersionInfoSizeW>('GetFileVersionInfoSizeW');

// https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
typedef _FFITypeGetLastError = DWORD Function();
typedef FFITypeGetLastError = int Function();
// ignore: non_constant_identifier_names
final FFITypeGetLastError GetLastError = _dllKernel32
    .lookupFunction<_FFITypeGetLastError, FFITypeGetLastError>('GetLastError');

// https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew
typedef _FFITypeGetModuleFileNameW = DWORD Function(HMODULE, LPWSTR, DWORD);
typedef FFITypeGetModuleFileNameW = int Function(int, Pointer<Utf16>, int);
// ignore: non_constant_identifier_names
final FFITypeGetModuleFileNameW GetModuleFileName = _dllKernel32.lookupFunction<
    _FFITypeGetModuleFileNameW,
    FFITypeGetModuleFileNameW>('GetModuleFileNameW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluew
typedef _FFITypeVerQueryValueW = BOOL Function(LPCVOID, LPCWSTR, LPVOID, PUINT);
typedef FFITypeVerQueryValueW = int Function(
    Pointer<NativeType>, Pointer<Utf16>, Pointer<NativeType>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeVerQueryValueW VerQueryValue =
    _dllVersion.lookupFunction<_FFITypeVerQueryValueW, FFITypeVerQueryValueW>(
        'VerQueryValueW');

// https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppathw
typedef _FFITypeGetTempPathW = DWORD Function(DWORD, LPWSTR);
typedef FFITypeGetTempPathW = int Function(int, Pointer<Utf16>);
// ignore: non_constant_identifier_names
final FFITypeGetTempPathW GetTempPath = _dllKernel32
    .lookupFunction<_FFITypeGetTempPathW, FFITypeGetTempPathW>('GetTempPathW');
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\lib\path_provider_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// path_provider_windows is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'src/folders_stub.dart' if (dart.library.ffi) 'src/folders.dart';
export 'src/path_provider_windows_stub.dart'
    if (dart.library.ffi) 'src/path_provider_windows_real.dart';
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\test\guid_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/src/guid.dart';

void main() {
  test('has correct byte representation', () async {
    final Pointer<GUID> guid = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final ByteData data = ByteData(16)
      ..setInt32(0, guid.ref.data1, Endian.little)
      ..setInt16(4, guid.ref.data2, Endian.little)
      ..setInt16(6, guid.ref.data3, Endian.little)
      ..setInt64(8, guid.ref.data4, Endian.little);
    expect(data.getUint8(0), 0x33);
    expect(data.getUint8(1), 0x22);
    expect(data.getUint8(2), 0x11);
    expect(data.getUint8(3), 0x00);
    expect(data.getUint8(4), 0x55);
    expect(data.getUint8(5), 0x44);
    expect(data.getUint8(6), 0x77);
    expect(data.getUint8(7), 0x66);
    expect(data.getUint8(8), 0x88);
    expect(data.getUint8(9), 0x99);
    expect(data.getUint8(10), 0xAA);
    expect(data.getUint8(11), 0xBB);
    expect(data.getUint8(12), 0xCC);
    expect(data.getUint8(13), 0xDD);
    expect(data.getUint8(14), 0xEE);
    expect(data.getUint8(15), 0xFF);

    calloc.free(guid);
  });

  test('handles alternate forms', () async {
    final Pointer<GUID> guid1 = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final Pointer<GUID> guid2 = calloc<GUID>()
      ..ref.parse('00112233445566778899AABBCCDDEEFF');

    expect(guid1.ref.data1, guid2.ref.data1);
    expect(guid1.ref.data2, guid2.ref.data2);
    expect(guid1.ref.data3, guid2.ref.data3);
    expect(guid1.ref.data4, guid2.ref.data4);

    calloc.free(guid1);
    calloc.free(guid2);
  });

  test('throws for bad data', () async {
    final Pointer<GUID> guid = calloc<GUID>();

    expect(() => guid.ref.parse('{00112233-4455-6677-88'), throwsArgumentError);

    calloc.free(guid);
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\path_provider_windows\test\path_provider_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:path_provider_windows/src/path_provider_windows_real.dart'
    show encodingCP1252, encodingUnicode, languageEn;

// A fake VersionInfoQuerier that just returns preset responses.
class FakeVersionInfoQuerier implements VersionInfoQuerier {
  FakeVersionInfoQuerier(
    this.responses, {
    this.language = languageEn,
    this.encoding = encodingUnicode,
  });

  final String language;
  final String encoding;
  final Map<String, String> responses;

  // ignore: unreachable_from_main
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    if (language == this.language && encoding == this.encoding) {
      return responses[key];
    } else {
      return null;
    }
  }
}

void main() {
  test('registered instance', () {
    PathProviderWindows.registerWith();
    expect(PathProviderPlatform.instance, isA<PathProviderWindows>());
  });

  test('getTemporaryPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    expect(await pathProvider.getTemporaryPath(), contains(r'C:\'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with no version info', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier =
        FakeVersionInfoQuerier(<String, String>{});
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in CP1252', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in Unicode', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test(
      'getApplicationSupportPath with full version info in Unsupported Encoding',
      () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, language: '0000', encoding: '0000');
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with missing company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with problematic values', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'A <Bad> Company: Name.',
      'ProductName': r'A"/Terrible\|App?*Name',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(
          path,
          endsWith(
              r'AppData\Roaming\A _Bad_ Company_ Name\A__Terrible__App__Name'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with a completely invalid company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'..',
      'ProductName': r'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with very long app name', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String truncatedName = 'A' * 255;
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': truncatedName * 2,
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, endsWith('\\$truncatedName'));
    // The directory won't exist, since it's longer than MAXPATH, so don't check
    // that here.
  }, skip: !Platform.isWindows);

  test('getApplicationDocumentsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getApplicationDocumentsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Documents'));
  }, skip: !Platform.isWindows);

  test('getApplicationCachePath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationCachePath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Local\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getDownloadsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getDownloadsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Downloads'));
  }, skip: !Platform.isWindows);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\permission_handler_windows\example\lib\main.dart =====
import 'package:baseflow_plugin_template/baseflow_plugin_template.dart';
import 'package:flutter/material.dart';
import 'package:permission_handler_platform_interface/permission_handler_platform_interface.dart';

void main() {
  runApp(BaseflowPluginExample(
      pluginName: 'Permission Handler',
      githubURL: 'https://github.com/Baseflow/flutter-permission-handler',
      pubDevURL: 'https://pub.dev/packages/permission_handler',
      pages: [PermissionHandlerWidget.createPage()]));
}

///Defines the main theme color
final MaterialColor themeMaterialColor =
    BaseflowPluginExample.createMaterialColor(
        const Color.fromRGBO(48, 49, 60, 1));

/// A Flutter application demonstrating the functionality of this plugin
class PermissionHandlerWidget extends StatefulWidget {
  /// Create a page containing the functionality of this plugin
  static ExamplePage createPage() {
    return ExamplePage(
        Icons.location_on, (context) => PermissionHandlerWidget());
  }

  @override
  _PermissionHandlerWidgetState createState() =>
      _PermissionHandlerWidgetState();
}

class _PermissionHandlerWidgetState extends State<PermissionHandlerWidget> {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: ListView(
          children: Permission.values
              .where((permission) {
                return permission != Permission.unknown &&
                    permission != Permission.mediaLibrary &&
                    permission != Permission.photos &&
                    permission != Permission.photosAddOnly &&
                    permission != Permission.reminders &&
                    permission != Permission.appTrackingTransparency &&
                    permission != Permission.criticalAlerts;
              })
              .map((permission) => PermissionWidget(permission))
              .toList()),
    );
  }
}

/// Permission widget containing information about the passed [Permission]
class PermissionWidget extends StatefulWidget {
  /// Constructs a [PermissionWidget] for the supplied [Permission]
  const PermissionWidget(this._permission);

  final Permission _permission;

  @override
  _PermissionState createState() => _PermissionState(_permission);
}

class _PermissionState extends State<PermissionWidget> {
  _PermissionState(this._permission);

  final Permission _permission;
  final PermissionHandlerPlatform _permissionHandler =
      PermissionHandlerPlatform.instance;
  PermissionStatus _permissionStatus = PermissionStatus.denied;

  @override
  void initState() {
    super.initState();

    _listenForPermissionStatus();
  }

  void _listenForPermissionStatus() async {
    final status = await _permissionHandler.checkPermissionStatus(_permission);
    setState(() => _permissionStatus = status);
  }

  Color getPermissionColor() {
    switch (_permissionStatus) {
      case PermissionStatus.denied:
        return Colors.red;
      case PermissionStatus.granted:
        return Colors.green;
      case PermissionStatus.limited:
        return Colors.orange;
      default:
        return Colors.grey;
    }
  }

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(
        _permission.toString(),
        style: Theme.of(context).textTheme.bodyLarge,
      ),
      subtitle: Text(
        _permissionStatus.toString(),
        style: TextStyle(color: getPermissionColor()),
      ),
      trailing: (_permission is PermissionWithService)
          ? IconButton(
              icon: const Icon(
                Icons.info,
                color: Colors.white,
              ),
              onPressed: () {
                checkServiceStatus(
                    context, _permission as PermissionWithService);
              })
          : null,
      onTap: () {
        requestPermission(_permission);
      },
    );
  }

  void checkServiceStatus(
      BuildContext context, PermissionWithService permission) async {
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
      content: Text(
          (await _permissionHandler.checkServiceStatus(permission)).toString()),
    ));
  }

  Future<void> requestPermission(Permission permission) async {
    final status = await _permissionHandler.requestPermissions([permission]);

    setState(() {
      print(status);
      _permissionStatus = status[permission] ?? PermissionStatus.denied;
      print(_permissionStatus);
    });
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\integration_test\shared_preferences_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesWindows', () {
    late SharedPreferencesWindows preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesWindows();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesWindowsOptions emptyOptions =
        SharedPreferencesWindowsOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncWindows).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesWindowsOptions options =
      const SharedPreferencesWindowsOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\lib\shared_preferences_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Windows implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
class SharedPreferencesWindows extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesWindows].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesWindows instance = SharedPreferencesWindows();

  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesWindows();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncWindows.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _readFromFile(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Windows implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
base class SharedPreferencesAsyncWindows
    extends SharedPreferencesAsyncPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncWindows();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesWindowsOptions options,
  ) async {
    _cachedPreferences = await _readFromFile(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs = Map<String, Object>.from(
        await _readPreferences(windowsOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _readFromFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderWindows();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file.
Future<Map<String, Object>> _readFromFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Windows specific SharedPreferences Options.
class SharedPreferencesWindowsOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesWindowsOptions.
  const SharedPreferencesWindowsOptions({
    this.fileName = 'shared_preferences', // Same as current defaults.
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesWindowsOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesWindowsOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesWindowsOptions) {
      return options;
    }
    return const SharedPreferencesWindowsOptions();
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\fake_path_provider_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

/// Fake implementation of PathProviderWindows that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Windows.
class FakePathProviderWindows extends PathProviderPlatform
    implements PathProviderWindows {
  @override
  late VersionInfoQuerier versionInfoQuerier;

  @override
  Future<String?> getApplicationSupportPath() async => r'C:\appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;

  @override
  Future<String> getPath(String folderID) async => '';
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\legacy_shared_preferences_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesWindows.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesWindows getPreferences() {
    final SharedPreferencesWindows prefs = SharedPreferencesWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesWindows.registerWith();
    expect(SharedPreferencesStorePlatform.instance,
        isA<SharedPreferencesWindows>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters with Prefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\shared_preferences_windows\test\shared_preferences_windows_async_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesAsyncWindows.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesWindowsOptions emptyOptions =
      SharedPreferencesWindowsOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  SharedPreferencesAsyncWindows getPreferences() {
    final SharedPreferencesAsyncWindows prefs = SharedPreferencesAsyncWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\example\integration_test\url_launcher_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('canLaunch', (WidgetTester _) async {
    final UrlLauncherPlatform launcher = UrlLauncherPlatform.instance;

    expect(await launcher.canLaunch('randomstring'), false);

    // Generally all devices should have some default browser.
    expect(await launcher.canLaunch('http://flutter.dev'), true);
  });
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\example\lib\main.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  Future<void>? _launched;

  Future<void> _launchInBrowser(String url) async {
    if (await UrlLauncherPlatform.instance.canLaunch(url)) {
      await UrlLauncherPlatform.instance.launch(
        url,
        useSafariVC: false,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: <String, String>{},
      );
    } else {
      throw Exception('Could not launch $url');
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  @override
  Widget build(BuildContext context) {
    const String toLaunch = 'https://www.cylog.org/headers/';
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(toLaunch),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\example\test_driver\integration_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\lib\src\messages.g.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v21.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
}

class UrlLauncherApi {
  /// Constructor for [UrlLauncherApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UrlLauncherApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String __pigeon_messageChannelSuffix;

  Future<bool> canLaunchUrl(String url) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.url_launcher_windows.UrlLauncherApi.canLaunchUrl$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[url]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> launchUrl(String url) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.url_launcher_windows.UrlLauncherApi.launchUrl$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[url]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\lib\url_launcher_windows.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/foundation.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [UrlLauncherPlatform] for Windows.
class UrlLauncherWindows extends UrlLauncherPlatform {
  /// Creates a new plugin implementation instance.
  UrlLauncherWindows({
    @visibleForTesting UrlLauncherApi? api,
  }) : _hostApi = api ?? UrlLauncherApi();

  final UrlLauncherApi _hostApi;

  /// Registers this class as the default instance of [UrlLauncherPlatform].
  static void registerWith() {
    UrlLauncherPlatform.instance = UrlLauncherWindows();
  }

  @override
  final LinkDelegate? linkDelegate = null;

  @override
  Future<bool> canLaunch(String url) {
    return _hostApi.canLaunchUrl(url);
  }

  @override
  Future<bool> launch(
    String url, {
    required bool useSafariVC,
    required bool useWebView,
    required bool enableJavaScript,
    required bool enableDomStorage,
    required bool universalLinksOnly,
    required Map<String, String> headers,
    String? webOnlyWindowName,
  }) async {
    return _hostApi.launchUrl(url);
  }

  @override
  Future<bool> supportsMode(PreferredLaunchMode mode) async {
    return mode == PreferredLaunchMode.platformDefault ||
        mode == PreferredLaunchMode.externalApplication;
  }

  @override
  Future<bool> supportsCloseForMode(PreferredLaunchMode mode) async {
    // No supported mode is closeable.
    return false;
  }
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\pigeons\messages.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  cppOptions: CppOptions(namespace: 'url_launcher_windows'),
  cppHeaderOut: 'windows/messages.g.h',
  cppSourceOut: 'windows/messages.g.cpp',
  copyrightHeader: 'pigeons/copyright.txt',
))
@HostApi(dartHostTestHandler: 'TestUrlLauncherApi')
abstract class UrlLauncherApi {
  bool canLaunchUrl(String url);
  bool launchUrl(String url);
}
===== C:\flutter_apps\im_legends\windows\flutter\ephemeral\.plugin_symlinks\url_launcher_windows\test\url_launcher_windows_test.dart =====
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';
import 'package:url_launcher_windows/src/messages.g.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

void main() {
  late _FakeUrlLauncherApi api;
  late UrlLauncherWindows plugin;

  setUp(() {
    api = _FakeUrlLauncherApi();
    plugin = UrlLauncherWindows(api: api);
  });

  test('registers instance', () {
    UrlLauncherWindows.registerWith();
    expect(UrlLauncherPlatform.instance, isA<UrlLauncherWindows>());
  });

  group('canLaunch', () {
    test('handles true', () async {
      api.canLaunch = true;

      final bool result = await plugin.canLaunch('http://example.com/');

      expect(result, isTrue);
      expect(api.argument, 'http://example.com/');
    });

    test('handles false', () async {
      api.canLaunch = false;

      final bool result = await plugin.canLaunch('http://example.com/');

      expect(result, isFalse);
      expect(api.argument, 'http://example.com/');
    });
  });

  group('launch', () {
    test('handles success', () async {
      api.canLaunch = true;

      expect(
          await plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          true);
      expect(api.argument, 'http://example.com/');
    });

    test('handles failure', () async {
      api.canLaunch = false;

      expect(
          await plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          false);
      expect(api.argument, 'http://example.com/');
    });

    test('handles errors', () async {
      api.throwError = true;

      await expectLater(
          plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          throwsA(isA<PlatformException>()));
      expect(api.argument, 'http://example.com/');
    });
  });

  group('supportsMode', () {
    test('returns true for platformDefault', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(await launcher.supportsMode(PreferredLaunchMode.platformDefault),
          true);
    });

    test('returns true for external application', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(
          await launcher.supportsMode(PreferredLaunchMode.externalApplication),
          true);
    });

    test('returns false for other modes', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(
          await launcher
              .supportsMode(PreferredLaunchMode.externalNonBrowserApplication),
          false);
      expect(await launcher.supportsMode(PreferredLaunchMode.inAppBrowserView),
          false);
      expect(
          await launcher.supportsMode(PreferredLaunchMode.inAppWebView), false);
    });
  });

  test('supportsCloseForMode returns false', () async {
    final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
    expect(
        await launcher
            .supportsCloseForMode(PreferredLaunchMode.platformDefault),
        false);
    expect(
        await launcher
            .supportsCloseForMode(PreferredLaunchMode.externalApplication),
        false);
  });
}

class _FakeUrlLauncherApi implements UrlLauncherApi {
  /// The argument that was passed to an API call.
  String? argument;

  /// Controls the behavior of the fake canLaunch implementations.
  ///
  /// - [canLaunchUrl] returns this value.
  /// - [launchUrl] returns this value if [throwError] is false.
  bool canLaunch = false;

  /// Whether to throw a platform exception.
  bool throwError = false;

  @override
  Future<bool> canLaunchUrl(String url) async {
    argument = url;
    return canLaunch;
  }

  @override
  Future<bool> launchUrl(String url) async {
    argument = url;
    if (throwError) {
      throw PlatformException(code: 'Failed');
    }
    return canLaunch;
  }
}
